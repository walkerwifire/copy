"use strict";
(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([[1618], {
    7387: function(e, t, r) {
        let a, n, o, i, l, s, u;
        r.d(t, {
            D5: function() {
                return a4
            },
            Jx: function() {
                return es
            },
            Pv: function() {
                return eu
            },
            UH: function() {
                return I.UH
            },
            vc: function() {
                return Y
            }
        });
        var p, c, h, d, f, m, y, g, v, b, x, w, S, k, _, C, E, A, L, T, M, P, $ = r(7748), I = r(28), z = r(5445), j = r(4871), R = r(1143), O = Object.defineProperty, U = e => {
            throw TypeError(e)
        }
        , N = (e, t, r) => t in e ? O(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r, F = (e, t, r) => N(e, "symbol" != typeof t ? t + "" : t, r), q = (e, t, r) => t.has(e) || U("Cannot " + r), D = (e, t, r) => (q(e, t, "read from private field"),
        r ? r.call(e) : t.get(e)), B = (e, t, r) => t.has(e) ? U("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), G = (e, t, r, a) => (q(e, t, "write to private field"),
        a ? a.call(e, r) : t.set(e, r),
        r), V = (e, t, r) => (q(e, t, "access private method"),
        r);
        let H = {
            VISITOR: {
                code: null,
                flag: "visitor",
                name: "Visitor",
                latin: !0,
                isMode: !0,
                geocoding: !1
            },
            VISITOR_ENGLISH: {
                code: null,
                flag: "visitor_en",
                name: "Visitor English",
                latin: !0,
                isMode: !0,
                geocoding: !1
            },
            STYLE: {
                code: null,
                flag: "style",
                name: "Style",
                latin: !1,
                isMode: !0,
                geocoding: !1
            },
            STYLE_LOCK: {
                code: null,
                flag: "style_lock",
                name: "Style Lock",
                latin: !1,
                isMode: !0,
                geocoding: !1
            },
            ...I.SQ
        };
        function X() {
            if (typeof navigator > "u") {
                let e = Intl.DateTimeFormat().resolvedOptions().locale.split("-")[0];
                return (0,
                I.x$)(e) || H.ENGLISH
            }
            return Array.from(new Set(navigator.languages.map(e => e.split("-")[0]))).map(e => (0,
            I.x$)(e)).filter(e => e)[0] ?? H.LOCAL
        }
        let K = {
            maptilerLogoURL: "https://api.maptiler.com/resources/logo.svg",
            maptilerURL: "https://www.maptiler.com/",
            maptilerApiHost: "api.maptiler.com",
            telemetryURL: "https://api.maptiler.com/metrics",
            rtlPluginURL: "https://cdn.maptiler.com/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.min.js",
            primaryLanguage: H.STYLE,
            secondaryLanguage: H.LOCAL,
            terrainSourceURL: "https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json",
            terrainSourceId: "maptiler-terrain"
        };
        Object.freeze(K);
        let Z = (0,
        j.Z)();
        class W extends z {
            constructor() {
                super(...arguments),
                F(this, "primaryLanguage", K.primaryLanguage),
                F(this, "secondaryLanguage"),
                F(this, "session", !0),
                F(this, "caching", !0),
                F(this, "telemetry", !0),
                F(this, "_unit", "metric"),
                F(this, "_apiKey", "")
            }
            set unit(e) {
                this._unit = e,
                this.emit("unit", e)
            }
            get unit() {
                return this._unit
            }
            set apiKey(e) {
                this._apiKey = e,
                I.vc.apiKey = e,
                this.emit("apiKey", e)
            }
            get apiKey() {
                return this._apiKey
            }
            set fetch(e) {
                I.vc.fetch = e
            }
            get fetch() {
                return I.vc.fetch
            }
        }
        let Y = new W
          , J = "localcache_source"
          , Q = "localcache"
          , ee = "u" > typeof caches
          , {addProtocol: et} = $;
        async function er() {
            return a || (a = await caches.open("maptiler_sdk")),
            a
        }
        let ea = 0;
        async function en() {
            let e = await er()
              , t = await e.keys();
            for (let r of t.slice(0, Math.max(t.length - 1e3, 0)))
                e.delete(r)
        }
        function eo(e, t) {
            let r = null;
            try {
                r = new URL(e)
            } catch {
                return {
                    url: e
                }
            }
            return r.host === K.maptilerApiHost && (r.searchParams.has("key") || r.searchParams.append("key", Y.apiKey),
            Y.session && r.searchParams.append("mtsid", Z)),
            {
                url: function(e, t) {
                    if (ee && Y.caching && Y.session && e.host === K.maptilerApiHost) {
                        if ("Source" === t && e.href.includes("tiles.json"))
                            return e.href.replace("https://", `${J}://`);
                        if ("Tile" === t || "Glyphs" === t)
                            return e.href.replace("https://", `${Q}://`)
                    }
                    return e.href
                }(r, t)
            }
        }
        function ei(e) {
            return (t, r) => {
                if (null != e) {
                    let a = e(t, r)
                      , n = eo((null == a ? void 0 : a.url) ?? "", r);
                    return {
                        ...a,
                        ...n
                    }
                }
                return eo(t, r)
            }
        }
        function el(e, t) {
            return !(!Array.isArray(e) || 2 !== e.length || "get" !== e[0] || "string" != typeof e[1] || t && !e[1].startsWith("name:") || !t && "name" !== e[1])
        }
        let es = class extends $.Marker {
            addTo(e) {
                return super.addTo(e)
            }
        }
        ;
        class eu extends $.NavigationControl {
            onAdd(e) {
                return super.onAdd(e)
            }
        }
        class ep extends $.GeolocateControl {
            onAdd(e) {
                return super.onAdd(e)
            }
        }
        class ec extends $.LogoControl {
            onAdd(e) {
                return super.onAdd(e)
            }
        }
        class eh extends $.ScaleControl {
            onAdd(e) {
                return super.onAdd(e)
            }
        }
        class ed extends $.FullscreenControl {
            onAdd(e) {
                return super.onAdd(e)
            }
        }
        class ef extends ec {
            constructor(e={}) {
                super(e),
                F(this, "logoURL", ""),
                F(this, "linkURL", ""),
                this.logoURL = e.logoURL ?? K.maptilerLogoURL,
                this.linkURL = e.linkURL ?? K.maptilerURL
            }
            onAdd(e) {
                this._map = e,
                this._compact = this.options.compact ?? !1,
                this._container = window.document.createElement("div"),
                this._container.className = "maplibregl-ctrl";
                let t = window.document.createElement("a");
                return t.style.backgroundRepeat = "no-repeat",
                t.style.cursor = "pointer",
                t.style.display = "block",
                t.style.height = "23px",
                t.style.margin = "0 0 -4px -4px",
                t.style.overflow = "hidden",
                t.style.width = "88px",
                t.style.backgroundImage = `url(${this.logoURL})`,
                t.style.backgroundSize = "100px 30px",
                t.style.width = "100px",
                t.style.height = "30px",
                t.target = "_blank",
                t.rel = "noopener",
                t.href = this.linkURL,
                t.setAttribute("aria-label", "MapTiler logo"),
                t.setAttribute("rel", "noopener"),
                this._container.appendChild(t),
                this._container.style.display = "block",
                this._map.on("resize", this._updateCompact),
                this._updateCompact(),
                this._container
            }
        }
        var em = {
            $version: 8,
            $root: {
                version: {
                    required: !0,
                    type: "enum",
                    values: [8]
                },
                name: {
                    type: "string"
                },
                metadata: {
                    type: "*"
                },
                center: {
                    type: "array",
                    value: "number"
                },
                centerAltitude: {
                    type: "number"
                },
                zoom: {
                    type: "number"
                },
                bearing: {
                    type: "number",
                    default: 0,
                    period: 360,
                    units: "degrees"
                },
                pitch: {
                    type: "number",
                    default: 0,
                    units: "degrees"
                },
                roll: {
                    type: "number",
                    default: 0,
                    units: "degrees"
                },
                state: {
                    type: "state",
                    default: {}
                },
                light: {
                    type: "light"
                },
                sky: {
                    type: "sky"
                },
                projection: {
                    type: "projection"
                },
                terrain: {
                    type: "terrain"
                },
                sources: {
                    required: !0,
                    type: "sources"
                },
                sprite: {
                    type: "sprite"
                },
                glyphs: {
                    type: "string"
                },
                transition: {
                    type: "transition"
                },
                layers: {
                    required: !0,
                    type: "array",
                    value: "layer"
                }
            },
            sources: {
                "*": {
                    type: "source"
                }
            },
            source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"],
            source_vector: {
                type: {
                    required: !0,
                    type: "enum",
                    values: {
                        vector: {}
                    }
                },
                url: {
                    type: "string"
                },
                tiles: {
                    type: "array",
                    value: "string"
                },
                bounds: {
                    type: "array",
                    value: "number",
                    length: 4,
                    default: [-180, -85.051129, 180, 85.051129]
                },
                scheme: {
                    type: "enum",
                    values: {
                        xyz: {},
                        tms: {}
                    },
                    default: "xyz"
                },
                minzoom: {
                    type: "number",
                    default: 0
                },
                maxzoom: {
                    type: "number",
                    default: 22
                },
                attribution: {
                    type: "string"
                },
                promoteId: {
                    type: "promoteId"
                },
                volatile: {
                    type: "boolean",
                    default: !1
                },
                "*": {
                    type: "*"
                }
            },
            source_raster: {
                type: {
                    required: !0,
                    type: "enum",
                    values: {
                        raster: {}
                    }
                },
                url: {
                    type: "string"
                },
                tiles: {
                    type: "array",
                    value: "string"
                },
                bounds: {
                    type: "array",
                    value: "number",
                    length: 4,
                    default: [-180, -85.051129, 180, 85.051129]
                },
                minzoom: {
                    type: "number",
                    default: 0
                },
                maxzoom: {
                    type: "number",
                    default: 22
                },
                tileSize: {
                    type: "number",
                    default: 512,
                    units: "pixels"
                },
                scheme: {
                    type: "enum",
                    values: {
                        xyz: {},
                        tms: {}
                    },
                    default: "xyz"
                },
                attribution: {
                    type: "string"
                },
                volatile: {
                    type: "boolean",
                    default: !1
                },
                "*": {
                    type: "*"
                }
            },
            source_raster_dem: {
                type: {
                    required: !0,
                    type: "enum",
                    values: {
                        "raster-dem": {}
                    }
                },
                url: {
                    type: "string"
                },
                tiles: {
                    type: "array",
                    value: "string"
                },
                bounds: {
                    type: "array",
                    value: "number",
                    length: 4,
                    default: [-180, -85.051129, 180, 85.051129]
                },
                minzoom: {
                    type: "number",
                    default: 0
                },
                maxzoom: {
                    type: "number",
                    default: 22
                },
                tileSize: {
                    type: "number",
                    default: 512,
                    units: "pixels"
                },
                attribution: {
                    type: "string"
                },
                encoding: {
                    type: "enum",
                    values: {
                        terrarium: {},
                        mapbox: {},
                        custom: {}
                    },
                    default: "mapbox"
                },
                redFactor: {
                    type: "number",
                    default: 1
                },
                blueFactor: {
                    type: "number",
                    default: 1
                },
                greenFactor: {
                    type: "number",
                    default: 1
                },
                baseShift: {
                    type: "number",
                    default: 0
                },
                volatile: {
                    type: "boolean",
                    default: !1
                },
                "*": {
                    type: "*"
                }
            },
            source_geojson: {
                type: {
                    required: !0,
                    type: "enum",
                    values: {
                        geojson: {}
                    }
                },
                data: {
                    required: !0,
                    type: "*"
                },
                maxzoom: {
                    type: "number",
                    default: 18
                },
                attribution: {
                    type: "string"
                },
                buffer: {
                    type: "number",
                    default: 128,
                    maximum: 512,
                    minimum: 0
                },
                filter: {
                    type: "*"
                },
                tolerance: {
                    type: "number",
                    default: .375
                },
                cluster: {
                    type: "boolean",
                    default: !1
                },
                clusterRadius: {
                    type: "number",
                    default: 50,
                    minimum: 0
                },
                clusterMaxZoom: {
                    type: "number"
                },
                clusterMinPoints: {
                    type: "number"
                },
                clusterProperties: {
                    type: "*"
                },
                lineMetrics: {
                    type: "boolean",
                    default: !1
                },
                generateId: {
                    type: "boolean",
                    default: !1
                },
                promoteId: {
                    type: "promoteId"
                }
            },
            source_video: {
                type: {
                    required: !0,
                    type: "enum",
                    values: {
                        video: {}
                    }
                },
                urls: {
                    required: !0,
                    type: "array",
                    value: "string"
                },
                coordinates: {
                    required: !0,
                    type: "array",
                    length: 4,
                    value: {
                        type: "array",
                        length: 2,
                        value: "number"
                    }
                }
            },
            source_image: {
                type: {
                    required: !0,
                    type: "enum",
                    values: {
                        image: {}
                    }
                },
                url: {
                    required: !0,
                    type: "string"
                },
                coordinates: {
                    required: !0,
                    type: "array",
                    length: 4,
                    value: {
                        type: "array",
                        length: 2,
                        value: "number"
                    }
                }
            },
            layer: {
                id: {
                    type: "string",
                    required: !0
                },
                type: {
                    type: "enum",
                    values: {
                        fill: {},
                        line: {},
                        symbol: {},
                        circle: {},
                        heatmap: {},
                        "fill-extrusion": {},
                        raster: {},
                        hillshade: {},
                        "color-relief": {},
                        background: {}
                    },
                    required: !0
                },
                metadata: {
                    type: "*"
                },
                source: {
                    type: "string"
                },
                "source-layer": {
                    type: "string"
                },
                minzoom: {
                    type: "number",
                    minimum: 0,
                    maximum: 24
                },
                maxzoom: {
                    type: "number",
                    minimum: 0,
                    maximum: 24
                },
                filter: {
                    type: "filter"
                },
                layout: {
                    type: "layout"
                },
                paint: {
                    type: "paint"
                }
            },
            layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"],
            layout_background: {
                visibility: {
                    type: "enum",
                    values: {
                        visible: {},
                        none: {}
                    },
                    default: "visible",
                    "property-type": "constant"
                }
            },
            layout_fill: {
                "fill-sort-key": {
                    type: "number",
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "data-driven"
                },
                visibility: {
                    type: "enum",
                    values: {
                        visible: {},
                        none: {}
                    },
                    default: "visible",
                    "property-type": "constant"
                }
            },
            layout_circle: {
                "circle-sort-key": {
                    type: "number",
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "data-driven"
                },
                visibility: {
                    type: "enum",
                    values: {
                        visible: {},
                        none: {}
                    },
                    default: "visible",
                    "property-type": "constant"
                }
            },
            layout_heatmap: {
                visibility: {
                    type: "enum",
                    values: {
                        visible: {},
                        none: {}
                    },
                    default: "visible",
                    "property-type": "constant"
                }
            },
            "layout_fill-extrusion": {
                visibility: {
                    type: "enum",
                    values: {
                        visible: {},
                        none: {}
                    },
                    default: "visible",
                    "property-type": "constant"
                }
            },
            layout_line: {
                "line-cap": {
                    type: "enum",
                    values: {
                        butt: {},
                        round: {},
                        square: {}
                    },
                    default: "butt",
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "line-join": {
                    type: "enum",
                    values: {
                        bevel: {},
                        round: {},
                        miter: {}
                    },
                    default: "miter",
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "data-driven"
                },
                "line-miter-limit": {
                    type: "number",
                    default: 2,
                    requires: [{
                        "line-join": "miter"
                    }],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "line-round-limit": {
                    type: "number",
                    default: 1.05,
                    requires: [{
                        "line-join": "round"
                    }],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "line-sort-key": {
                    type: "number",
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "data-driven"
                },
                visibility: {
                    type: "enum",
                    values: {
                        visible: {},
                        none: {}
                    },
                    default: "visible",
                    "property-type": "constant"
                }
            },
            layout_symbol: {
                "symbol-placement": {
                    type: "enum",
                    values: {
                        point: {},
                        line: {},
                        "line-center": {}
                    },
                    default: "point",
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "symbol-spacing": {
                    type: "number",
                    default: 250,
                    minimum: 1,
                    units: "pixels",
                    requires: [{
                        "symbol-placement": "line"
                    }],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "symbol-avoid-edges": {
                    type: "boolean",
                    default: !1,
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "symbol-sort-key": {
                    type: "number",
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "data-driven"
                },
                "symbol-z-order": {
                    type: "enum",
                    values: {
                        auto: {},
                        "viewport-y": {},
                        source: {}
                    },
                    default: "auto",
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "icon-allow-overlap": {
                    type: "boolean",
                    default: !1,
                    requires: ["icon-image", {
                        "!": "icon-overlap"
                    }],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "icon-overlap": {
                    type: "enum",
                    values: {
                        never: {},
                        always: {},
                        cooperative: {}
                    },
                    requires: ["icon-image"],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "icon-ignore-placement": {
                    type: "boolean",
                    default: !1,
                    requires: ["icon-image"],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "icon-optional": {
                    type: "boolean",
                    default: !1,
                    requires: ["icon-image", "text-field"],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "icon-rotation-alignment": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {},
                        auto: {}
                    },
                    default: "auto",
                    requires: ["icon-image"],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "icon-size": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    units: "factor of the original icon size",
                    requires: ["icon-image"],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "data-driven"
                },
                "icon-text-fit": {
                    type: "enum",
                    values: {
                        none: {},
                        width: {},
                        height: {},
                        both: {}
                    },
                    default: "none",
                    requires: ["icon-image", "text-field"],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "icon-text-fit-padding": {
                    type: "array",
                    value: "number",
                    length: 4,
                    default: [0, 0, 0, 0],
                    units: "pixels",
                    requires: ["icon-image", "text-field", {
                        "icon-text-fit": ["both", "width", "height"]
                    }],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "icon-image": {
                    type: "resolvedImage",
                    tokens: !0,
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "data-driven"
                },
                "icon-rotate": {
                    type: "number",
                    default: 0,
                    period: 360,
                    units: "degrees",
                    requires: ["icon-image"],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "data-driven"
                },
                "icon-padding": {
                    type: "padding",
                    default: [2],
                    units: "pixels",
                    requires: ["icon-image"],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "data-driven"
                },
                "icon-keep-upright": {
                    type: "boolean",
                    default: !1,
                    requires: ["icon-image", {
                        "icon-rotation-alignment": "map"
                    }, {
                        "symbol-placement": ["line", "line-center"]
                    }],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "icon-offset": {
                    type: "array",
                    value: "number",
                    length: 2,
                    default: [0, 0],
                    requires: ["icon-image"],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "data-driven"
                },
                "icon-anchor": {
                    type: "enum",
                    values: {
                        center: {},
                        left: {},
                        right: {},
                        top: {},
                        bottom: {},
                        "top-left": {},
                        "top-right": {},
                        "bottom-left": {},
                        "bottom-right": {}
                    },
                    default: "center",
                    requires: ["icon-image"],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "data-driven"
                },
                "icon-pitch-alignment": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {},
                        auto: {}
                    },
                    default: "auto",
                    requires: ["icon-image"],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "text-pitch-alignment": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {},
                        auto: {}
                    },
                    default: "auto",
                    requires: ["text-field"],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "text-rotation-alignment": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {},
                        "viewport-glyph": {},
                        auto: {}
                    },
                    default: "auto",
                    requires: ["text-field"],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "text-field": {
                    type: "formatted",
                    default: "",
                    tokens: !0,
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "data-driven"
                },
                "text-font": {
                    type: "array",
                    value: "string",
                    default: ["Open Sans Regular", "Arial Unicode MS Regular"],
                    requires: ["text-field"],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "data-driven"
                },
                "text-size": {
                    type: "number",
                    default: 16,
                    minimum: 0,
                    units: "pixels",
                    requires: ["text-field"],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "data-driven"
                },
                "text-max-width": {
                    type: "number",
                    default: 10,
                    minimum: 0,
                    units: "ems",
                    requires: ["text-field"],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "data-driven"
                },
                "text-line-height": {
                    type: "number",
                    default: 1.2,
                    units: "ems",
                    requires: ["text-field"],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "text-letter-spacing": {
                    type: "number",
                    default: 0,
                    units: "ems",
                    requires: ["text-field"],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "data-driven"
                },
                "text-justify": {
                    type: "enum",
                    values: {
                        auto: {},
                        left: {},
                        center: {},
                        right: {}
                    },
                    default: "center",
                    requires: ["text-field"],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "data-driven"
                },
                "text-radial-offset": {
                    type: "number",
                    units: "ems",
                    default: 0,
                    requires: ["text-field"],
                    "property-type": "data-driven",
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature"]
                    }
                },
                "text-variable-anchor": {
                    type: "array",
                    value: "enum",
                    values: {
                        center: {},
                        left: {},
                        right: {},
                        top: {},
                        bottom: {},
                        "top-left": {},
                        "top-right": {},
                        "bottom-left": {},
                        "bottom-right": {}
                    },
                    requires: ["text-field", {
                        "symbol-placement": ["point"]
                    }],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "text-variable-anchor-offset": {
                    type: "variableAnchorOffsetCollection",
                    requires: ["text-field", {
                        "symbol-placement": ["point"]
                    }],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "data-driven"
                },
                "text-anchor": {
                    type: "enum",
                    values: {
                        center: {},
                        left: {},
                        right: {},
                        top: {},
                        bottom: {},
                        "top-left": {},
                        "top-right": {},
                        "bottom-left": {},
                        "bottom-right": {}
                    },
                    default: "center",
                    requires: ["text-field", {
                        "!": "text-variable-anchor"
                    }],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "data-driven"
                },
                "text-max-angle": {
                    type: "number",
                    default: 45,
                    units: "degrees",
                    requires: ["text-field", {
                        "symbol-placement": ["line", "line-center"]
                    }],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "text-writing-mode": {
                    type: "array",
                    value: "enum",
                    values: {
                        horizontal: {},
                        vertical: {}
                    },
                    requires: ["text-field", {
                        "symbol-placement": ["point"]
                    }],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "text-rotate": {
                    type: "number",
                    default: 0,
                    period: 360,
                    units: "degrees",
                    requires: ["text-field"],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "data-driven"
                },
                "text-padding": {
                    type: "number",
                    default: 2,
                    minimum: 0,
                    units: "pixels",
                    requires: ["text-field"],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "text-keep-upright": {
                    type: "boolean",
                    default: !0,
                    requires: ["text-field", {
                        "text-rotation-alignment": "map"
                    }, {
                        "symbol-placement": ["line", "line-center"]
                    }],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "text-transform": {
                    type: "enum",
                    values: {
                        none: {},
                        uppercase: {},
                        lowercase: {}
                    },
                    default: "none",
                    requires: ["text-field"],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "data-driven"
                },
                "text-offset": {
                    type: "array",
                    value: "number",
                    units: "ems",
                    length: 2,
                    default: [0, 0],
                    requires: ["text-field", {
                        "!": "text-radial-offset"
                    }],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "data-driven"
                },
                "text-allow-overlap": {
                    type: "boolean",
                    default: !1,
                    requires: ["text-field", {
                        "!": "text-overlap"
                    }],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "text-overlap": {
                    type: "enum",
                    values: {
                        never: {},
                        always: {},
                        cooperative: {}
                    },
                    requires: ["text-field"],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "text-ignore-placement": {
                    type: "boolean",
                    default: !1,
                    requires: ["text-field"],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "text-optional": {
                    type: "boolean",
                    default: !1,
                    requires: ["text-field", "icon-image"],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                visibility: {
                    type: "enum",
                    values: {
                        visible: {},
                        none: {}
                    },
                    default: "visible",
                    "property-type": "constant"
                }
            },
            layout_raster: {
                visibility: {
                    type: "enum",
                    values: {
                        visible: {},
                        none: {}
                    },
                    default: "visible",
                    "property-type": "constant"
                }
            },
            layout_hillshade: {
                visibility: {
                    type: "enum",
                    values: {
                        visible: {},
                        none: {}
                    },
                    default: "visible",
                    "property-type": "constant"
                }
            },
            "layout_color-relief": {
                visibility: {
                    type: "enum",
                    values: {
                        visible: {},
                        none: {}
                    },
                    default: "visible",
                    "property-type": "constant"
                }
            },
            filter: {
                type: "array",
                value: "*"
            },
            filter_operator: {
                type: "enum",
                values: {
                    "==": {},
                    "!=": {},
                    ">": {},
                    ">=": {},
                    "<": {},
                    "<=": {},
                    in: {},
                    "!in": {},
                    all: {},
                    any: {},
                    none: {},
                    has: {},
                    "!has": {}
                }
            },
            geometry_type: {
                type: "enum",
                values: {
                    Point: {},
                    LineString: {},
                    Polygon: {}
                }
            },
            function: {
                expression: {
                    type: "expression"
                },
                stops: {
                    type: "array",
                    value: "function_stop"
                },
                base: {
                    type: "number",
                    default: 1,
                    minimum: 0
                },
                property: {
                    type: "string",
                    default: "$zoom"
                },
                type: {
                    type: "enum",
                    values: {
                        identity: {},
                        exponential: {},
                        interval: {},
                        categorical: {}
                    },
                    default: "exponential"
                },
                colorSpace: {
                    type: "enum",
                    values: {
                        rgb: {},
                        lab: {},
                        hcl: {}
                    },
                    default: "rgb"
                },
                default: {
                    type: "*",
                    required: !1
                }
            },
            function_stop: {
                type: "array",
                minimum: 0,
                maximum: 24,
                value: ["number", "color"],
                length: 2
            },
            expression: {
                type: "array",
                value: "*",
                minimum: 1
            },
            light: {
                anchor: {
                    type: "enum",
                    default: "viewport",
                    values: {
                        map: {},
                        viewport: {}
                    },
                    "property-type": "data-constant",
                    transition: !1,
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    }
                },
                position: {
                    type: "array",
                    default: [1.15, 210, 30],
                    length: 3,
                    value: "number",
                    "property-type": "data-constant",
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    }
                },
                color: {
                    type: "color",
                    "property-type": "data-constant",
                    default: "#ffffff",
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    transition: !0
                },
                intensity: {
                    type: "number",
                    "property-type": "data-constant",
                    default: .5,
                    minimum: 0,
                    maximum: 1,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    transition: !0
                }
            },
            sky: {
                "sky-color": {
                    type: "color",
                    "property-type": "data-constant",
                    default: "#88C6FC",
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    transition: !0
                },
                "horizon-color": {
                    type: "color",
                    "property-type": "data-constant",
                    default: "#ffffff",
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    transition: !0
                },
                "fog-color": {
                    type: "color",
                    "property-type": "data-constant",
                    default: "#ffffff",
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    transition: !0
                },
                "fog-ground-blend": {
                    type: "number",
                    "property-type": "data-constant",
                    default: .5,
                    minimum: 0,
                    maximum: 1,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    transition: !0
                },
                "horizon-fog-blend": {
                    type: "number",
                    "property-type": "data-constant",
                    default: .8,
                    minimum: 0,
                    maximum: 1,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    transition: !0
                },
                "sky-horizon-blend": {
                    type: "number",
                    "property-type": "data-constant",
                    default: .8,
                    minimum: 0,
                    maximum: 1,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    transition: !0
                },
                "atmosphere-blend": {
                    type: "number",
                    "property-type": "data-constant",
                    default: .8,
                    minimum: 0,
                    maximum: 1,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    transition: !0
                }
            },
            terrain: {
                source: {
                    type: "string",
                    required: !0
                },
                exaggeration: {
                    type: "number",
                    minimum: 0,
                    default: 1
                }
            },
            projection: {
                type: {
                    type: "projectionDefinition",
                    default: "mercator",
                    "property-type": "data-constant",
                    transition: !1,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    }
                }
            },
            paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"],
            paint_fill: {
                "fill-antialias": {
                    type: "boolean",
                    default: !0,
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "fill-opacity": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "fill-color": {
                    type: "color",
                    default: "#000000",
                    transition: !0,
                    requires: [{
                        "!": "fill-pattern"
                    }],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "fill-outline-color": {
                    type: "color",
                    transition: !0,
                    requires: [{
                        "!": "fill-pattern"
                    }, {
                        "fill-antialias": !0
                    }],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "fill-translate": {
                    type: "array",
                    value: "number",
                    length: 2,
                    default: [0, 0],
                    transition: !0,
                    units: "pixels",
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "fill-translate-anchor": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {}
                    },
                    default: "map",
                    requires: ["fill-translate"],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "fill-pattern": {
                    type: "resolvedImage",
                    transition: !0,
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "cross-faded-data-driven"
                }
            },
            "paint_fill-extrusion": {
                "fill-extrusion-opacity": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "fill-extrusion-color": {
                    type: "color",
                    default: "#000000",
                    transition: !0,
                    requires: [{
                        "!": "fill-extrusion-pattern"
                    }],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "fill-extrusion-translate": {
                    type: "array",
                    value: "number",
                    length: 2,
                    default: [0, 0],
                    transition: !0,
                    units: "pixels",
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "fill-extrusion-translate-anchor": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {}
                    },
                    default: "map",
                    requires: ["fill-extrusion-translate"],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "fill-extrusion-pattern": {
                    type: "resolvedImage",
                    transition: !0,
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "cross-faded-data-driven"
                },
                "fill-extrusion-height": {
                    type: "number",
                    default: 0,
                    minimum: 0,
                    units: "meters",
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "fill-extrusion-base": {
                    type: "number",
                    default: 0,
                    minimum: 0,
                    units: "meters",
                    transition: !0,
                    requires: ["fill-extrusion-height"],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "fill-extrusion-vertical-gradient": {
                    type: "boolean",
                    default: !0,
                    transition: !1,
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                }
            },
            paint_line: {
                "line-opacity": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "line-color": {
                    type: "color",
                    default: "#000000",
                    transition: !0,
                    requires: [{
                        "!": "line-pattern"
                    }],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "line-translate": {
                    type: "array",
                    value: "number",
                    length: 2,
                    default: [0, 0],
                    transition: !0,
                    units: "pixels",
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "line-translate-anchor": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {}
                    },
                    default: "map",
                    requires: ["line-translate"],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "line-width": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    transition: !0,
                    units: "pixels",
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "line-gap-width": {
                    type: "number",
                    default: 0,
                    minimum: 0,
                    transition: !0,
                    units: "pixels",
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "line-offset": {
                    type: "number",
                    default: 0,
                    transition: !0,
                    units: "pixels",
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "line-blur": {
                    type: "number",
                    default: 0,
                    minimum: 0,
                    transition: !0,
                    units: "pixels",
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "line-dasharray": {
                    type: "array",
                    value: "number",
                    minimum: 0,
                    transition: !0,
                    units: "line widths",
                    requires: [{
                        "!": "line-pattern"
                    }],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "cross-faded"
                },
                "line-pattern": {
                    type: "resolvedImage",
                    transition: !0,
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom", "feature"]
                    },
                    "property-type": "cross-faded-data-driven"
                },
                "line-gradient": {
                    type: "color",
                    transition: !1,
                    requires: [{
                        "!": "line-dasharray"
                    }, {
                        "!": "line-pattern"
                    }, {
                        source: "geojson",
                        has: {
                            lineMetrics: !0
                        }
                    }],
                    expression: {
                        interpolated: !0,
                        parameters: ["line-progress"]
                    },
                    "property-type": "color-ramp"
                }
            },
            paint_circle: {
                "circle-radius": {
                    type: "number",
                    default: 5,
                    minimum: 0,
                    transition: !0,
                    units: "pixels",
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "circle-color": {
                    type: "color",
                    default: "#000000",
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "circle-blur": {
                    type: "number",
                    default: 0,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "circle-opacity": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "circle-translate": {
                    type: "array",
                    value: "number",
                    length: 2,
                    default: [0, 0],
                    transition: !0,
                    units: "pixels",
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "circle-translate-anchor": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {}
                    },
                    default: "map",
                    requires: ["circle-translate"],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "circle-pitch-scale": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {}
                    },
                    default: "map",
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "circle-pitch-alignment": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {}
                    },
                    default: "viewport",
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "circle-stroke-width": {
                    type: "number",
                    default: 0,
                    minimum: 0,
                    transition: !0,
                    units: "pixels",
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "circle-stroke-color": {
                    type: "color",
                    default: "#000000",
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "circle-stroke-opacity": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                }
            },
            paint_heatmap: {
                "heatmap-radius": {
                    type: "number",
                    default: 30,
                    minimum: 1,
                    transition: !0,
                    units: "pixels",
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "heatmap-weight": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    transition: !1,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "heatmap-intensity": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "heatmap-color": {
                    type: "color",
                    default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"],
                    transition: !1,
                    expression: {
                        interpolated: !0,
                        parameters: ["heatmap-density"]
                    },
                    "property-type": "color-ramp"
                },
                "heatmap-opacity": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                }
            },
            paint_symbol: {
                "icon-opacity": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    requires: ["icon-image"],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "icon-color": {
                    type: "color",
                    default: "#000000",
                    transition: !0,
                    requires: ["icon-image"],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "icon-halo-color": {
                    type: "color",
                    default: "rgba(0, 0, 0, 0)",
                    transition: !0,
                    requires: ["icon-image"],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "icon-halo-width": {
                    type: "number",
                    default: 0,
                    minimum: 0,
                    transition: !0,
                    units: "pixels",
                    requires: ["icon-image"],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "icon-halo-blur": {
                    type: "number",
                    default: 0,
                    minimum: 0,
                    transition: !0,
                    units: "pixels",
                    requires: ["icon-image"],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "icon-translate": {
                    type: "array",
                    value: "number",
                    length: 2,
                    default: [0, 0],
                    transition: !0,
                    units: "pixels",
                    requires: ["icon-image"],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "icon-translate-anchor": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {}
                    },
                    default: "map",
                    requires: ["icon-image", "icon-translate"],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "text-opacity": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    requires: ["text-field"],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "text-color": {
                    type: "color",
                    default: "#000000",
                    transition: !0,
                    overridable: !0,
                    requires: ["text-field"],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "text-halo-color": {
                    type: "color",
                    default: "rgba(0, 0, 0, 0)",
                    transition: !0,
                    requires: ["text-field"],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "text-halo-width": {
                    type: "number",
                    default: 0,
                    minimum: 0,
                    transition: !0,
                    units: "pixels",
                    requires: ["text-field"],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "text-halo-blur": {
                    type: "number",
                    default: 0,
                    minimum: 0,
                    transition: !0,
                    units: "pixels",
                    requires: ["text-field"],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom", "feature", "feature-state"]
                    },
                    "property-type": "data-driven"
                },
                "text-translate": {
                    type: "array",
                    value: "number",
                    length: 2,
                    default: [0, 0],
                    transition: !0,
                    units: "pixels",
                    requires: ["text-field"],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "text-translate-anchor": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {}
                    },
                    default: "map",
                    requires: ["text-field", "text-translate"],
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                }
            },
            paint_raster: {
                "raster-opacity": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "raster-hue-rotate": {
                    type: "number",
                    default: 0,
                    period: 360,
                    transition: !0,
                    units: "degrees",
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "raster-brightness-min": {
                    type: "number",
                    default: 0,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "raster-brightness-max": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "raster-saturation": {
                    type: "number",
                    default: 0,
                    minimum: -1,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "raster-contrast": {
                    type: "number",
                    default: 0,
                    minimum: -1,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "raster-resampling": {
                    type: "enum",
                    values: {
                        linear: {},
                        nearest: {}
                    },
                    default: "linear",
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "raster-fade-duration": {
                    type: "number",
                    default: 300,
                    minimum: 0,
                    transition: !1,
                    units: "milliseconds",
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                }
            },
            paint_hillshade: {
                "hillshade-illumination-direction": {
                    type: "numberArray",
                    default: 335,
                    minimum: 0,
                    maximum: 359,
                    transition: !1,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "hillshade-illumination-altitude": {
                    type: "numberArray",
                    default: 45,
                    minimum: 0,
                    maximum: 90,
                    transition: !1,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "hillshade-illumination-anchor": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {}
                    },
                    default: "viewport",
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "hillshade-exaggeration": {
                    type: "number",
                    default: .5,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "hillshade-shadow-color": {
                    type: "colorArray",
                    default: "#000000",
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "hillshade-highlight-color": {
                    type: "colorArray",
                    default: "#FFFFFF",
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "hillshade-accent-color": {
                    type: "color",
                    default: "#000000",
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "hillshade-method": {
                    type: "enum",
                    values: {
                        standard: {},
                        basic: {},
                        combined: {},
                        igor: {},
                        multidirectional: {}
                    },
                    default: "standard",
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                }
            },
            "paint_color-relief": {
                "color-relief-opacity": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "color-relief-color": {
                    type: "color",
                    transition: !1,
                    expression: {
                        interpolated: !0,
                        parameters: ["elevation"]
                    },
                    "property-type": "color-ramp"
                }
            },
            paint_background: {
                "background-color": {
                    type: "color",
                    default: "#000000",
                    transition: !0,
                    requires: [{
                        "!": "background-pattern"
                    }],
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                },
                "background-pattern": {
                    type: "resolvedImage",
                    transition: !0,
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom"]
                    },
                    "property-type": "cross-faded"
                },
                "background-opacity": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: ["zoom"]
                    },
                    "property-type": "data-constant"
                }
            },
            transition: {
                duration: {
                    type: "number",
                    default: 300,
                    minimum: 0,
                    units: "milliseconds"
                },
                delay: {
                    type: "number",
                    default: 0,
                    minimum: 0,
                    units: "milliseconds"
                }
            },
            "property-type": {
                "data-driven": {
                    type: "property-type"
                },
                "cross-faded": {
                    type: "property-type"
                },
                "cross-faded-data-driven": {
                    type: "property-type"
                },
                "color-ramp": {
                    type: "property-type"
                },
                "data-constant": {
                    type: "property-type"
                },
                constant: {
                    type: "property-type"
                }
            },
            promoteId: {
                "*": {
                    type: "string"
                }
            }
        };
        class ey {
            constructor(e, t, r, a) {
                this.message = (e ? `${e}: ` : "") + r,
                a && (this.identifier = a),
                null != t && t.__line__ && (this.line = t.__line__)
            }
        }
        function eg(e, ...t) {
            for (let r of t)
                for (let t in r)
                    e[t] = r[t];
            return e
        }
        class ev extends Error {
            constructor(e, t) {
                super(t),
                this.message = t,
                this.key = e
            }
        }
        class eb {
            constructor(e, t=[]) {
                for (let[r,a] of (this.parent = e,
                this.bindings = {},
                t))
                    this.bindings[r] = a
            }
            concat(e) {
                return new eb(this,e)
            }
            get(e) {
                if (this.bindings[e])
                    return this.bindings[e];
                if (this.parent)
                    return this.parent.get(e);
                throw Error(`${e} not found in scope.`)
            }
            has(e) {
                return !!this.bindings[e] || !!this.parent && this.parent.has(e)
            }
        }
        let ex = {
            kind: "null"
        }
          , ew = {
            kind: "number"
        }
          , eS = {
            kind: "string"
        }
          , ek = {
            kind: "boolean"
        }
          , e_ = {
            kind: "color"
        }
          , eC = {
            kind: "projectionDefinition"
        }
          , eE = {
            kind: "object"
        }
          , eA = {
            kind: "value"
        }
          , eL = {
            kind: "collator"
        }
          , eT = {
            kind: "formatted"
        }
          , eM = {
            kind: "padding"
        }
          , eP = {
            kind: "colorArray"
        }
          , e$ = {
            kind: "numberArray"
        }
          , eI = {
            kind: "resolvedImage"
        }
          , ez = {
            kind: "variableAnchorOffsetCollection"
        };
        function ej(e, t) {
            return {
                kind: "array",
                itemType: e,
                N: t
            }
        }
        function eR(e) {
            if ("array" !== e.kind)
                return e.kind;
            {
                let t = eR(e.itemType);
                return "number" == typeof e.N ? `array<${t}, ${e.N}>` : "value" === e.itemType.kind ? "array" : `array<${t}>`
            }
        }
        let eO = [ex, ew, eS, ek, e_, eC, eT, eE, ej(eA), eM, e$, eP, eI, ez];
        function eU(e, t) {
            if ("error" === t.kind)
                return null;
            if ("array" === e.kind) {
                if ("array" === t.kind && (0 === t.N && "value" === t.itemType.kind || !eU(e.itemType, t.itemType)) && ("number" != typeof e.N || e.N === t.N))
                    return null
            } else {
                if (e.kind === t.kind)
                    return null;
                if ("value" === e.kind) {
                    for (let e of eO)
                        if (!eU(e, t))
                            return null
                }
            }
            return `Expected ${eR(e)} but found ${eR(t)} instead.`
        }
        function eN(e, t) {
            return t.some(t => t.kind === e.kind)
        }
        function eF(e, t) {
            return t.some(t => "null" === t ? null === e : "array" === t ? Array.isArray(e) : "object" === t ? e && !Array.isArray(e) && "object" == typeof e : t === typeof e)
        }
        function eq(e, t) {
            return "array" === e.kind && "array" === t.kind ? e.itemType.kind === t.itemType.kind && "number" == typeof e.N : e.kind === t.kind
        }
        let eD = 4 / 29
          , eB = 6 / 29
          , eG = 6 / 29 * 3 * (6 / 29)
          , eV = 6 / 29 * (6 / 29) * (6 / 29)
          , eH = Math.PI / 180
          , eX = 180 / Math.PI;
        function eK(e) {
            return (e %= 360) < 0 && (e += 360),
            e
        }
        function eZ([e,t,r,a]) {
            let n, o;
            let i = eY((.2225045 * (e = eW(e)) + .7168786 * (t = eW(t)) + .0606169 * (r = eW(r))) / 1);
            e === t && t === r ? n = o = i : (n = eY((.4360747 * e + .3850649 * t + .1430804 * r) / .96422),
            o = eY((.0139322 * e + .0971045 * t + .7141733 * r) / .82521));
            let l = 116 * i - 16;
            return [l < 0 ? 0 : l, 500 * (n - i), 200 * (i - o), a]
        }
        function eW(e) {
            return e <= .04045 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4)
        }
        function eY(e) {
            return e > eV ? Math.pow(e, 1 / 3) : e / eG + eD
        }
        function eJ([e,t,r,a]) {
            let n = (e + 16) / 116
              , o = isNaN(t) ? n : n + t / 500
              , i = isNaN(r) ? n : n - r / 200;
            return n = 1 * e0(n),
            [eQ(3.1338561 * (o = .96422 * e0(o)) - 1.6168667 * n - .4906146 * (i = .82521 * e0(i))), eQ(-.9787684 * o + 1.9161415 * n + .033454 * i), eQ(.0719453 * o - .2289914 * n + 1.4052427 * i), a]
        }
        function eQ(e) {
            return (e = e <= .00304 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - .055) < 0 ? 0 : e > 1 ? 1 : e
        }
        function e0(e) {
            return e > eB ? e * e * e : eG * (e - eD)
        }
        let e1 = Object.hasOwn || function(e, t) {
            return Object.prototype.hasOwnProperty.call(e, t)
        }
        ;
        function e2(e, t) {
            return e1(e, t) ? e[t] : void 0
        }
        function e5(e) {
            return parseInt(e.padEnd(2, e), 16) / 255
        }
        function e3(e, t) {
            return e4(t ? e / 100 : e, 0, 1)
        }
        function e4(e, t, r) {
            return Math.min(Math.max(t, e), r)
        }
        function e8(e) {
            return !e.some(Number.isNaN)
        }
        let e6 = {
            aliceblue: [240, 248, 255],
            antiquewhite: [250, 235, 215],
            aqua: [0, 255, 255],
            aquamarine: [127, 255, 212],
            azure: [240, 255, 255],
            beige: [245, 245, 220],
            bisque: [255, 228, 196],
            black: [0, 0, 0],
            blanchedalmond: [255, 235, 205],
            blue: [0, 0, 255],
            blueviolet: [138, 43, 226],
            brown: [165, 42, 42],
            burlywood: [222, 184, 135],
            cadetblue: [95, 158, 160],
            chartreuse: [127, 255, 0],
            chocolate: [210, 105, 30],
            coral: [255, 127, 80],
            cornflowerblue: [100, 149, 237],
            cornsilk: [255, 248, 220],
            crimson: [220, 20, 60],
            cyan: [0, 255, 255],
            darkblue: [0, 0, 139],
            darkcyan: [0, 139, 139],
            darkgoldenrod: [184, 134, 11],
            darkgray: [169, 169, 169],
            darkgreen: [0, 100, 0],
            darkgrey: [169, 169, 169],
            darkkhaki: [189, 183, 107],
            darkmagenta: [139, 0, 139],
            darkolivegreen: [85, 107, 47],
            darkorange: [255, 140, 0],
            darkorchid: [153, 50, 204],
            darkred: [139, 0, 0],
            darksalmon: [233, 150, 122],
            darkseagreen: [143, 188, 143],
            darkslateblue: [72, 61, 139],
            darkslategray: [47, 79, 79],
            darkslategrey: [47, 79, 79],
            darkturquoise: [0, 206, 209],
            darkviolet: [148, 0, 211],
            deeppink: [255, 20, 147],
            deepskyblue: [0, 191, 255],
            dimgray: [105, 105, 105],
            dimgrey: [105, 105, 105],
            dodgerblue: [30, 144, 255],
            firebrick: [178, 34, 34],
            floralwhite: [255, 250, 240],
            forestgreen: [34, 139, 34],
            fuchsia: [255, 0, 255],
            gainsboro: [220, 220, 220],
            ghostwhite: [248, 248, 255],
            gold: [255, 215, 0],
            goldenrod: [218, 165, 32],
            gray: [128, 128, 128],
            green: [0, 128, 0],
            greenyellow: [173, 255, 47],
            grey: [128, 128, 128],
            honeydew: [240, 255, 240],
            hotpink: [255, 105, 180],
            indianred: [205, 92, 92],
            indigo: [75, 0, 130],
            ivory: [255, 255, 240],
            khaki: [240, 230, 140],
            lavender: [230, 230, 250],
            lavenderblush: [255, 240, 245],
            lawngreen: [124, 252, 0],
            lemonchiffon: [255, 250, 205],
            lightblue: [173, 216, 230],
            lightcoral: [240, 128, 128],
            lightcyan: [224, 255, 255],
            lightgoldenrodyellow: [250, 250, 210],
            lightgray: [211, 211, 211],
            lightgreen: [144, 238, 144],
            lightgrey: [211, 211, 211],
            lightpink: [255, 182, 193],
            lightsalmon: [255, 160, 122],
            lightseagreen: [32, 178, 170],
            lightskyblue: [135, 206, 250],
            lightslategray: [119, 136, 153],
            lightslategrey: [119, 136, 153],
            lightsteelblue: [176, 196, 222],
            lightyellow: [255, 255, 224],
            lime: [0, 255, 0],
            limegreen: [50, 205, 50],
            linen: [250, 240, 230],
            magenta: [255, 0, 255],
            maroon: [128, 0, 0],
            mediumaquamarine: [102, 205, 170],
            mediumblue: [0, 0, 205],
            mediumorchid: [186, 85, 211],
            mediumpurple: [147, 112, 219],
            mediumseagreen: [60, 179, 113],
            mediumslateblue: [123, 104, 238],
            mediumspringgreen: [0, 250, 154],
            mediumturquoise: [72, 209, 204],
            mediumvioletred: [199, 21, 133],
            midnightblue: [25, 25, 112],
            mintcream: [245, 255, 250],
            mistyrose: [255, 228, 225],
            moccasin: [255, 228, 181],
            navajowhite: [255, 222, 173],
            navy: [0, 0, 128],
            oldlace: [253, 245, 230],
            olive: [128, 128, 0],
            olivedrab: [107, 142, 35],
            orange: [255, 165, 0],
            orangered: [255, 69, 0],
            orchid: [218, 112, 214],
            palegoldenrod: [238, 232, 170],
            palegreen: [152, 251, 152],
            paleturquoise: [175, 238, 238],
            palevioletred: [219, 112, 147],
            papayawhip: [255, 239, 213],
            peachpuff: [255, 218, 185],
            peru: [205, 133, 63],
            pink: [255, 192, 203],
            plum: [221, 160, 221],
            powderblue: [176, 224, 230],
            purple: [128, 0, 128],
            rebeccapurple: [102, 51, 153],
            red: [255, 0, 0],
            rosybrown: [188, 143, 143],
            royalblue: [65, 105, 225],
            saddlebrown: [139, 69, 19],
            salmon: [250, 128, 114],
            sandybrown: [244, 164, 96],
            seagreen: [46, 139, 87],
            seashell: [255, 245, 238],
            sienna: [160, 82, 45],
            silver: [192, 192, 192],
            skyblue: [135, 206, 235],
            slateblue: [106, 90, 205],
            slategray: [112, 128, 144],
            slategrey: [112, 128, 144],
            snow: [255, 250, 250],
            springgreen: [0, 255, 127],
            steelblue: [70, 130, 180],
            tan: [210, 180, 140],
            teal: [0, 128, 128],
            thistle: [216, 191, 216],
            tomato: [255, 99, 71],
            turquoise: [64, 224, 208],
            violet: [238, 130, 238],
            wheat: [245, 222, 179],
            white: [255, 255, 255],
            whitesmoke: [245, 245, 245],
            yellow: [255, 255, 0],
            yellowgreen: [154, 205, 50]
        };
        function e7(e, t, r) {
            return e.map( (e, a) => e + r * (t[a] - e))
        }
        class e9 {
            constructor(e, t, r, a=1, n=!0) {
                this.r = e,
                this.g = t,
                this.b = r,
                this.a = a,
                n || (this.r *= a,
                this.g *= a,
                this.b *= a,
                a || this.overwriteGetter("rgb", [e, t, r, a]))
            }
            static parse(e) {
                if (e instanceof e9)
                    return e;
                if ("string" != typeof e)
                    return;
                let t = function(e) {
                    if ("transparent" === (e = e.toLowerCase().trim()))
                        return [0, 0, 0, 0];
                    let t = e2(e6, e);
                    if (t) {
                        let[e,r,a] = t;
                        return [e / 255, r / 255, a / 255, 1]
                    }
                    if (e.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(e)) {
                        let t = e.length < 6 ? 1 : 2
                          , r = 1;
                        return [e5(e.slice(r, r += t)), e5(e.slice(r, r += t)), e5(e.slice(r, r += t)), e5(e.slice(r, r + t) || "ff")]
                    }
                    if (e.startsWith("rgb")) {
                        let t = e.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                        if (t) {
                            let[e,r,a,n,o,i,l,s,u,p,c,h] = t
                              , d = [n || " ", l || " ", p].join("");
                            if ("  " === d || "  /" === d || ",," === d || ",,," === d) {
                                let e = [a, i, u].join("")
                                  , t = "%%%" === e ? 100 : "" === e ? 255 : 0;
                                if (t) {
                                    let e = [e4(+r / t, 0, 1), e4(+o / t, 0, 1), e4(+s / t, 0, 1), c ? e3(+c, h) : 1];
                                    if (e8(e))
                                        return e
                                }
                            }
                            return
                        }
                    }
                    let r = e.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                    if (r) {
                        let[e,t,a,n,o,i,l,s,u] = r
                          , p = [a || " ", o || " ", l].join("");
                        if ("  " === p || "  /" === p || ",," === p || ",,," === p) {
                            let e = [+t, e4(+n, 0, 100), e4(+i, 0, 100), s ? e3(+s, u) : 1];
                            if (e8(e))
                                return function([e,t,r,a]) {
                                    function n(a) {
                                        let n = (a + e / 30) % 12
                                          , o = t * Math.min(r, 1 - r);
                                        return r - o * Math.max(-1, Math.min(n - 3, 9 - n, 1))
                                    }
                                    return e = eK(e),
                                    t /= 100,
                                    r /= 100,
                                    [n(0), n(8), n(4), a]
                                }(e)
                        }
                    }
                }(e);
                if (t)
                    return new e9(...t,!1)
            }
            get rgb() {
                let {r: e, g: t, b: r, a} = this
                  , n = a || 1 / 0;
                return this.overwriteGetter("rgb", [e / n, t / n, r / n, a])
            }
            get hcl() {
                return this.overwriteGetter("hcl", function(e) {
                    let[t,r,a,n] = eZ(e)
                      , o = Math.sqrt(r * r + a * a);
                    return [Math.round(1e4 * o) ? eK(Math.atan2(a, r) * eX) : NaN, o, t, n]
                }(this.rgb))
            }
            get lab() {
                return this.overwriteGetter("lab", eZ(this.rgb))
            }
            overwriteGetter(e, t) {
                return Object.defineProperty(this, e, {
                    value: t
                }),
                t
            }
            toString() {
                let[e,t,r,a] = this.rgb;
                return `rgba(${[e, t, r].map(e => Math.round(255 * e)).join(",")},${a})`
            }
            static interpolate(e, t, r, a="rgb") {
                switch (a) {
                case "rgb":
                    {
                        let[a,n,o,i] = e7(e.rgb, t.rgb, r);
                        return new e9(a,n,o,i,!1)
                    }
                case "hcl":
                    {
                        let a, n;
                        let[o,i,l,s] = e.hcl
                          , [u,p,c,h] = t.hcl;
                        if (isNaN(o) || isNaN(u))
                            isNaN(o) ? isNaN(u) ? a = NaN : (a = u,
                            (1 === l || 0 === l) && (n = p)) : (a = o,
                            (1 === c || 0 === c) && (n = i));
                        else {
                            let e = u - o;
                            u > o && e > 180 ? e -= 360 : u < o && o - u > 180 && (e += 360),
                            a = o + r * e
                        }
                        let[d,f,m,y] = function([e,t,r,a]) {
                            return eJ([r, Math.cos(e = isNaN(e) ? 0 : e * eH) * t, Math.sin(e) * t, a])
                        }([a, n ?? i + r * (p - i), l + r * (c - l), s + r * (h - s)]);
                        return new e9(d,f,m,y,!1)
                    }
                case "lab":
                    {
                        let[a,n,o,i] = eJ(e7(e.lab, t.lab, r));
                        return new e9(a,n,o,i,!1)
                    }
                }
            }
        }
        e9.black = new e9(0,0,0,1),
        e9.white = new e9(1,1,1,1),
        e9.transparent = new e9(0,0,0,0),
        e9.red = new e9(1,0,0,1);
        class te {
            constructor(e, t, r) {
                e ? this.sensitivity = t ? "variant" : "case" : this.sensitivity = t ? "accent" : "base",
                this.locale = r,
                this.collator = new Intl.Collator(this.locale ? this.locale : [],{
                    sensitivity: this.sensitivity,
                    usage: "search"
                })
            }
            compare(e, t) {
                return this.collator.compare(e, t)
            }
            resolvedLocale() {
                return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale
            }
        }
        let tt = ["bottom", "center", "top"];
        class tr {
            constructor(e, t, r, a, n, o) {
                this.text = e,
                this.image = t,
                this.scale = r,
                this.fontStack = a,
                this.textColor = n,
                this.verticalAlign = o
            }
        }
        class ta {
            constructor(e) {
                this.sections = e
            }
            static fromString(e) {
                return new ta([new tr(e,null,null,null,null,null)])
            }
            isEmpty() {
                return 0 === this.sections.length || !this.sections.some(e => 0 !== e.text.length || e.image && 0 !== e.image.name.length)
            }
            static factory(e) {
                return e instanceof ta ? e : ta.fromString(e)
            }
            toString() {
                return 0 === this.sections.length ? "" : this.sections.map(e => e.text).join("")
            }
        }
        class tn {
            constructor(e) {
                this.values = e.slice()
            }
            static parse(e) {
                if (e instanceof tn)
                    return e;
                if ("number" == typeof e)
                    return new tn([e, e, e, e]);
                if (Array.isArray(e) && !(e.length < 1 || e.length > 4)) {
                    for (let t of e)
                        if ("number" != typeof t)
                            return;
                    switch (e.length) {
                    case 1:
                        e = [e[0], e[0], e[0], e[0]];
                        break;
                    case 2:
                        e = [e[0], e[1], e[0], e[1]];
                        break;
                    case 3:
                        e = [e[0], e[1], e[2], e[1]]
                    }
                    return new tn(e)
                }
            }
            toString() {
                return JSON.stringify(this.values)
            }
            static interpolate(e, t, r) {
                return new tn(e7(e.values, t.values, r))
            }
        }
        class to {
            constructor(e) {
                this.values = e.slice()
            }
            static parse(e) {
                if (e instanceof to)
                    return e;
                if ("number" == typeof e)
                    return new to([e]);
                if (Array.isArray(e)) {
                    for (let t of e)
                        if ("number" != typeof t)
                            return;
                    return new to(e)
                }
            }
            toString() {
                return JSON.stringify(this.values)
            }
            static interpolate(e, t, r) {
                return new to(e7(e.values, t.values, r))
            }
        }
        class ti {
            constructor(e) {
                this.values = e.slice()
            }
            static parse(e) {
                if (e instanceof ti)
                    return e;
                if ("string" == typeof e) {
                    let t = e9.parse(e);
                    return t ? new ti([t]) : void 0
                }
                if (!Array.isArray(e))
                    return;
                let t = [];
                for (let r of e) {
                    if ("string" != typeof r)
                        return;
                    let e = e9.parse(r);
                    if (!e)
                        return;
                    t.push(e)
                }
                return new ti(t)
            }
            toString() {
                return JSON.stringify(this.values)
            }
            static interpolate(e, t, r, a="rgb") {
                let n = [];
                if (e.values.length != t.values.length)
                    throw Error(`colorArray: Arrays have mismatched length (${e.values.length} vs. ${t.values.length}), cannot interpolate.`);
                for (let o = 0; o < e.values.length; o++)
                    n.push(e9.interpolate(e.values[o], t.values[o], r, a));
                return new ti(n)
            }
        }
        class tl extends Error {
            constructor(e) {
                super(e),
                this.name = "RuntimeError"
            }
            toJSON() {
                return this.message
            }
        }
        let ts = new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class tu {
            constructor(e) {
                this.values = e.slice()
            }
            static parse(e) {
                if (e instanceof tu)
                    return e;
                if (!(!Array.isArray(e) || e.length < 1 || e.length % 2 != 0)) {
                    for (let t = 0; t < e.length; t += 2) {
                        let r = e[t]
                          , a = e[t + 1];
                        if ("string" != typeof r || !ts.has(r) || !Array.isArray(a) || 2 !== a.length || "number" != typeof a[0] || "number" != typeof a[1])
                            return
                    }
                    return new tu(e)
                }
            }
            toString() {
                return JSON.stringify(this.values)
            }
            static interpolate(e, t, r) {
                let a = e.values
                  , n = t.values;
                if (a.length !== n.length)
                    throw new tl(`Cannot interpolate values of different length. from: ${e.toString()}, to: ${t.toString()}`);
                let o = [];
                for (let e = 0; e < a.length; e += 2) {
                    if (a[e] !== n[e])
                        throw new tl(`Cannot interpolate values containing mismatched anchors. from[${e}]: ${a[e]}, to[${e}]: ${n[e]}`);
                    o.push(a[e]);
                    let[t,i] = a[e + 1]
                      , [l,s] = n[e + 1];
                    o.push([t + r * (l - t), i + r * (s - i)])
                }
                return new tu(o)
            }
        }
        class tp {
            constructor(e) {
                this.name = e.name,
                this.available = e.available
            }
            toString() {
                return this.name
            }
            static fromString(e) {
                return e ? new tp({
                    name: e,
                    available: !1
                }) : null
            }
        }
        class tc {
            constructor(e, t, r) {
                this.from = e,
                this.to = t,
                this.transition = r
            }
            static interpolate(e, t, r) {
                return new tc(e,t,r)
            }
            static parse(e) {
                return e instanceof tc ? e : Array.isArray(e) && 3 === e.length && "string" == typeof e[0] && "string" == typeof e[1] && "number" == typeof e[2] ? new tc(e[0],e[1],e[2]) : "object" == typeof e && "string" == typeof e.from && "string" == typeof e.to && "number" == typeof e.transition ? new tc(e.from,e.to,e.transition) : "string" == typeof e ? new tc(e,e,1) : void 0
            }
        }
        function th(e, t, r, a) {
            return "number" == typeof e && e >= 0 && e <= 255 && "number" == typeof t && t >= 0 && t <= 255 && "number" == typeof r && r >= 0 && r <= 255 ? typeof a > "u" || "number" == typeof a && a >= 0 && a <= 1 ? null : `Invalid rgba value [${[e, t, r, a].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof a ? [e, t, r, a] : [e, t, r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`
        }
        function td(e) {
            if (null === e || "string" == typeof e || "boolean" == typeof e || "number" == typeof e || e instanceof tc || e instanceof e9 || e instanceof te || e instanceof ta || e instanceof tn || e instanceof to || e instanceof ti || e instanceof tu || e instanceof tp)
                return !0;
            if (Array.isArray(e)) {
                for (let t of e)
                    if (!td(t))
                        return !1;
                return !0
            }
            if ("object" != typeof e)
                return !1;
            for (let t in e)
                if (!td(e[t]))
                    return !1;
            return !0
        }
        function tf(e) {
            if (null === e)
                return ex;
            if ("string" == typeof e)
                return eS;
            if ("boolean" == typeof e)
                return ek;
            if ("number" == typeof e)
                return ew;
            if (e instanceof e9)
                return e_;
            if (e instanceof tc)
                return eC;
            if (e instanceof te)
                return eL;
            if (e instanceof ta)
                return eT;
            if (e instanceof tn)
                return eM;
            if (e instanceof to)
                return e$;
            if (e instanceof ti)
                return eP;
            if (e instanceof tu)
                return ez;
            if (e instanceof tp)
                return eI;
            if (!Array.isArray(e))
                return eE;
            {
                let t;
                let r = e.length;
                for (let r of e) {
                    let e = tf(r);
                    if (t) {
                        if (t === e)
                            continue;
                        t = eA;
                        break
                    }
                    t = e
                }
                return ej(t || eA, r)
            }
        }
        function tm(e) {
            let t = typeof e;
            return null === e ? "" : "string" === t || "number" === t || "boolean" === t ? String(e) : e instanceof e9 || e instanceof tc || e instanceof ta || e instanceof tn || e instanceof to || e instanceof ti || e instanceof tu || e instanceof tp ? e.toString() : JSON.stringify(e)
        }
        class ty {
            constructor(e, t) {
                this.type = e,
                this.value = t
            }
            static parse(e, t) {
                if (2 !== e.length)
                    return t.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
                if (!td(e[1]))
                    return t.error("invalid value");
                let r = e[1]
                  , a = tf(r)
                  , n = t.expectedType;
                return "array" === a.kind && 0 === a.N && n && "array" === n.kind && ("number" != typeof n.N || 0 === n.N) && (a = n),
                new ty(a,r)
            }
            evaluate() {
                return this.value
            }
            eachChild() {}
            outputDefined() {
                return !0
            }
        }
        let tg = {
            string: eS,
            number: ew,
            boolean: ek,
            object: eE
        };
        class tv {
            constructor(e, t) {
                this.type = e,
                this.args = t
            }
            static parse(e, t) {
                if (e.length < 2)
                    return t.error("Expected at least one argument.");
                let r = 1, a, n = e[0];
                if ("array" === n) {
                    let n, o;
                    if (e.length > 2) {
                        let a = e[1];
                        if ("string" != typeof a || !(a in tg) || "object" === a)
                            return t.error('The item type argument of "array" must be one of string, number, boolean', 1);
                        n = tg[a],
                        r++
                    } else
                        n = eA;
                    if (e.length > 3) {
                        if (null !== e[2] && ("number" != typeof e[2] || e[2] < 0 || e[2] !== Math.floor(e[2])))
                            return t.error('The length argument to "array" must be a positive integer literal', 2);
                        o = e[2],
                        r++
                    }
                    a = ej(n, o)
                } else {
                    if (!tg[n])
                        throw Error(`Types doesn't contain name = ${n}`);
                    a = tg[n]
                }
                let o = [];
                for (; r < e.length; r++) {
                    let a = t.parse(e[r], r, eA);
                    if (!a)
                        return null;
                    o.push(a)
                }
                return new tv(a,o)
            }
            evaluate(e) {
                for (let t = 0; t < this.args.length; t++) {
                    let r = this.args[t].evaluate(e);
                    if (!eU(this.type, tf(r)))
                        return r;
                    if (t === this.args.length - 1)
                        throw new tl(`Expected value to be of type ${eR(this.type)}, but found ${eR(tf(r))} instead.`)
                }
                throw Error()
            }
            eachChild(e) {
                this.args.forEach(e)
            }
            outputDefined() {
                return this.args.every(e => e.outputDefined())
            }
        }
        let tb = {
            "to-boolean": ek,
            "to-color": e_,
            "to-number": ew,
            "to-string": eS
        };
        class tx {
            constructor(e, t) {
                this.type = e,
                this.args = t
            }
            static parse(e, t) {
                if (e.length < 2)
                    return t.error("Expected at least one argument.");
                let r = e[0];
                if (!tb[r])
                    throw Error(`Can't parse ${r} as it is not part of the known types`);
                if (("to-boolean" === r || "to-string" === r) && 2 !== e.length)
                    return t.error("Expected one argument.");
                let a = tb[r]
                  , n = [];
                for (let r = 1; r < e.length; r++) {
                    let a = t.parse(e[r], r, eA);
                    if (!a)
                        return null;
                    n.push(a)
                }
                return new tx(a,n)
            }
            evaluate(e) {
                switch (this.type.kind) {
                case "boolean":
                    return !!this.args[0].evaluate(e);
                case "color":
                    {
                        let t, r;
                        for (let a of this.args) {
                            if (t = a.evaluate(e),
                            r = null,
                            t instanceof e9)
                                return t;
                            if ("string" == typeof t) {
                                let r = e.parseColor(t);
                                if (r)
                                    return r
                            } else if (Array.isArray(t) && !(r = t.length < 3 || t.length > 4 ? `Invalid rgba value ${JSON.stringify(t)}: expected an array containing either three or four numeric values.` : th(t[0], t[1], t[2], t[3])))
                                return new e9(t[0] / 255,t[1] / 255,t[2] / 255,t[3])
                        }
                        throw new tl(r || `Could not parse color from value '${"string" == typeof t ? t : JSON.stringify(t)}'`)
                    }
                case "padding":
                    {
                        let t;
                        for (let r of this.args) {
                            t = r.evaluate(e);
                            let a = tn.parse(t);
                            if (a)
                                return a
                        }
                        throw new tl(`Could not parse padding from value '${"string" == typeof t ? t : JSON.stringify(t)}'`)
                    }
                case "numberArray":
                    {
                        let t;
                        for (let r of this.args) {
                            t = r.evaluate(e);
                            let a = to.parse(t);
                            if (a)
                                return a
                        }
                        throw new tl(`Could not parse numberArray from value '${"string" == typeof t ? t : JSON.stringify(t)}'`)
                    }
                case "colorArray":
                    {
                        let t;
                        for (let r of this.args) {
                            t = r.evaluate(e);
                            let a = ti.parse(t);
                            if (a)
                                return a
                        }
                        throw new tl(`Could not parse colorArray from value '${"string" == typeof t ? t : JSON.stringify(t)}'`)
                    }
                case "variableAnchorOffsetCollection":
                    {
                        let t;
                        for (let r of this.args) {
                            t = r.evaluate(e);
                            let a = tu.parse(t);
                            if (a)
                                return a
                        }
                        throw new tl(`Could not parse variableAnchorOffsetCollection from value '${"string" == typeof t ? t : JSON.stringify(t)}'`)
                    }
                case "number":
                    {
                        let t = null;
                        for (let r of this.args) {
                            if (null === (t = r.evaluate(e)))
                                return 0;
                            let a = Number(t);
                            if (!isNaN(a))
                                return a
                        }
                        throw new tl(`Could not convert ${JSON.stringify(t)} to number.`)
                    }
                case "formatted":
                    return ta.fromString(tm(this.args[0].evaluate(e)));
                case "resolvedImage":
                    return tp.fromString(tm(this.args[0].evaluate(e)));
                case "projectionDefinition":
                    return this.args[0].evaluate(e);
                default:
                    return tm(this.args[0].evaluate(e))
                }
            }
            eachChild(e) {
                this.args.forEach(e)
            }
            outputDefined() {
                return this.args.every(e => e.outputDefined())
            }
        }
        let tw = ["Unknown", "Point", "LineString", "Polygon"];
        class tS {
            constructor() {
                this.globals = null,
                this.feature = null,
                this.featureState = null,
                this.formattedSection = null,
                this._parseColorCache = new Map,
                this.availableImages = null,
                this.canonical = null
            }
            id() {
                return this.feature && "id"in this.feature ? this.feature.id : null
            }
            geometryType() {
                return this.feature ? "number" == typeof this.feature.type ? tw[this.feature.type] : this.feature.type : null
            }
            geometry() {
                return this.feature && "geometry"in this.feature ? this.feature.geometry : null
            }
            canonicalID() {
                return this.canonical
            }
            properties() {
                return this.feature && this.feature.properties || {}
            }
            parseColor(e) {
                let t = this._parseColorCache.get(e);
                return t || (t = e9.parse(e),
                this._parseColorCache.set(e, t)),
                t
            }
        }
        class tk {
            constructor(e, t, r=[], a, n=new eb, o=[]) {
                this.registry = e,
                this.path = r,
                this.key = r.map(e => `[${e}]`).join(""),
                this.scope = n,
                this.errors = o,
                this.expectedType = a,
                this._isConstant = t
            }
            parse(e, t, r, a, n={}) {
                return t ? this.concat(t, r, a)._parse(e, n) : this._parse(e, n)
            }
            _parse(e, t) {
                function r(e, t, r) {
                    return "assert" === r ? new tv(t,[e]) : "coerce" === r ? new tx(t,[e]) : e
                }
                if ((null === e || "string" == typeof e || "boolean" == typeof e || "number" == typeof e) && (e = ["literal", e]),
                !Array.isArray(e))
                    return typeof e > "u" ? this.error("'undefined' value invalid. Use null instead.") : "object" == typeof e ? this.error('Bare objects invalid. Use ["literal", {...}] instead.') : this.error(`Expected an array, but found ${typeof e} instead.`);
                {
                    if (0 === e.length)
                        return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                    let a = e[0];
                    if ("string" != typeof a)
                        return this.error(`Expression name must be a string, but found ${typeof a} instead. If you wanted a literal array, use ["literal", [...]].`, 0),
                        null;
                    let n = this.registry[a];
                    if (n) {
                        let a = n.parse(e, this);
                        if (!a)
                            return null;
                        if (this.expectedType) {
                            let e = this.expectedType
                              , n = a.type;
                            if (("string" === e.kind || "number" === e.kind || "boolean" === e.kind || "object" === e.kind || "array" === e.kind) && "value" === n.kind)
                                a = r(a, e, t.typeAnnotation || "assert");
                            else if ("projectionDefinition" === e.kind && ["string", "array"].includes(n.kind) || ["color", "formatted", "resolvedImage"].includes(e.kind) && ["value", "string"].includes(n.kind) || ["padding", "numberArray"].includes(e.kind) && ["value", "number", "array"].includes(n.kind) || "colorArray" === e.kind && ["value", "string", "array"].includes(n.kind) || "variableAnchorOffsetCollection" === e.kind && ["value", "array"].includes(n.kind))
                                a = r(a, e, t.typeAnnotation || "coerce");
                            else if (this.checkSubtype(e, n))
                                return null
                        }
                        if (!(a instanceof ty) && "resolvedImage" !== a.type.kind && this._isConstant(a)) {
                            let e = new tS;
                            try {
                                a = new ty(a.type,a.evaluate(e))
                            } catch (e) {
                                return this.error(e.message),
                                null
                            }
                        }
                        return a
                    }
                    return this.error(`Unknown expression "${a}". If you wanted a literal array, use ["literal", [...]].`, 0)
                }
            }
            concat(e, t, r) {
                let a = "number" == typeof e ? this.path.concat(e) : this.path
                  , n = r ? this.scope.concat(r) : this.scope;
                return new tk(this.registry,this._isConstant,a,t || null,n,this.errors)
            }
            error(e, ...t) {
                let r = `${this.key}${t.map(e => `[${e}]`).join("")}`;
                this.errors.push(new ev(r,e))
            }
            checkSubtype(e, t) {
                let r = eU(e, t);
                return r && this.error(r),
                r
            }
        }
        class t_ {
            constructor(e, t) {
                this.type = t.type,
                this.bindings = [].concat(e),
                this.result = t
            }
            evaluate(e) {
                return this.result.evaluate(e)
            }
            eachChild(e) {
                for (let t of this.bindings)
                    e(t[1]);
                e(this.result)
            }
            static parse(e, t) {
                if (e.length < 4)
                    return t.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
                let r = [];
                for (let a = 1; a < e.length - 1; a += 2) {
                    let n = e[a];
                    if ("string" != typeof n)
                        return t.error(`Expected string, but found ${typeof n} instead.`, a);
                    if (/[^a-zA-Z0-9_]/.test(n))
                        return t.error("Variable names must contain only alphanumeric characters or '_'.", a);
                    let o = t.parse(e[a + 1], a + 1);
                    if (!o)
                        return null;
                    r.push([n, o])
                }
                let a = t.parse(e[e.length - 1], e.length - 1, t.expectedType, r);
                return a ? new t_(r,a) : null
            }
            outputDefined() {
                return this.result.outputDefined()
            }
        }
        class tC {
            constructor(e, t) {
                this.type = t.type,
                this.name = e,
                this.boundExpression = t
            }
            static parse(e, t) {
                if (2 !== e.length || "string" != typeof e[1])
                    return t.error("'var' expression requires exactly one string literal argument.");
                let r = e[1];
                return t.scope.has(r) ? new tC(r,t.scope.get(r)) : t.error(`Unknown variable "${r}". Make sure "${r}" has been bound in an enclosing "let" expression before using it.`, 1)
            }
            evaluate(e) {
                return this.boundExpression.evaluate(e)
            }
            eachChild() {}
            outputDefined() {
                return !1
            }
        }
        class tE {
            constructor(e, t, r) {
                this.type = e,
                this.index = t,
                this.input = r
            }
            static parse(e, t) {
                if (3 !== e.length)
                    return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
                let r = t.parse(e[1], 1, ew)
                  , a = t.parse(e[2], 2, ej(t.expectedType || eA));
                return r && a ? new tE(a.type.itemType,r,a) : null
            }
            evaluate(e) {
                let t = this.index.evaluate(e)
                  , r = this.input.evaluate(e);
                if (t < 0)
                    throw new tl(`Array index out of bounds: ${t} < 0.`);
                if (t >= r.length)
                    throw new tl(`Array index out of bounds: ${t} > ${r.length - 1}.`);
                if (t !== Math.floor(t))
                    throw new tl(`Array index must be an integer, but found ${t} instead.`);
                return r[t]
            }
            eachChild(e) {
                e(this.index),
                e(this.input)
            }
            outputDefined() {
                return !1
            }
        }
        class tA {
            constructor(e, t) {
                this.type = ek,
                this.needle = e,
                this.haystack = t
            }
            static parse(e, t) {
                if (3 !== e.length)
                    return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
                let r = t.parse(e[1], 1, eA)
                  , a = t.parse(e[2], 2, eA);
                return r && a ? eN(r.type, [ek, eS, ew, ex, eA]) ? new tA(r,a) : t.error(`Expected first argument to be of type boolean, string, number or null, but found ${eR(r.type)} instead`) : null
            }
            evaluate(e) {
                let t = this.needle.evaluate(e)
                  , r = this.haystack.evaluate(e);
                if (!r)
                    return !1;
                if (!eF(t, ["boolean", "string", "number", "null"]))
                    throw new tl(`Expected first argument to be of type boolean, string, number or null, but found ${eR(tf(t))} instead.`);
                if (!eF(r, ["string", "array"]))
                    throw new tl(`Expected second argument to be of type array or string, but found ${eR(tf(r))} instead.`);
                return r.indexOf(t) >= 0
            }
            eachChild(e) {
                e(this.needle),
                e(this.haystack)
            }
            outputDefined() {
                return !0
            }
        }
        class tL {
            constructor(e, t, r) {
                this.type = ew,
                this.needle = e,
                this.haystack = t,
                this.fromIndex = r
            }
            static parse(e, t) {
                if (e.length <= 2 || e.length >= 5)
                    return t.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
                let r = t.parse(e[1], 1, eA)
                  , a = t.parse(e[2], 2, eA);
                if (!r || !a)
                    return null;
                if (!eN(r.type, [ek, eS, ew, ex, eA]))
                    return t.error(`Expected first argument to be of type boolean, string, number or null, but found ${eR(r.type)} instead`);
                if (4 !== e.length)
                    return new tL(r,a);
                {
                    let n = t.parse(e[3], 3, ew);
                    return n ? new tL(r,a,n) : null
                }
            }
            evaluate(e) {
                let t;
                let r = this.needle.evaluate(e)
                  , a = this.haystack.evaluate(e);
                if (!eF(r, ["boolean", "string", "number", "null"]))
                    throw new tl(`Expected first argument to be of type boolean, string, number or null, but found ${eR(tf(r))} instead.`);
                if (this.fromIndex && (t = this.fromIndex.evaluate(e)),
                eF(a, ["string"])) {
                    let e = a.indexOf(r, t);
                    return -1 === e ? -1 : [...a.slice(0, e)].length
                }
                if (eF(a, ["array"]))
                    return a.indexOf(r, t);
                throw new tl(`Expected second argument to be of type array or string, but found ${eR(tf(a))} instead.`)
            }
            eachChild(e) {
                e(this.needle),
                e(this.haystack),
                this.fromIndex && e(this.fromIndex)
            }
            outputDefined() {
                return !1
            }
        }
        class tT {
            constructor(e, t, r, a, n, o) {
                this.inputType = e,
                this.type = t,
                this.input = r,
                this.cases = a,
                this.outputs = n,
                this.otherwise = o
            }
            static parse(e, t) {
                let r, a;
                if (e.length < 5)
                    return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
                if (e.length % 2 != 1)
                    return t.error("Expected an even number of arguments.");
                t.expectedType && "value" !== t.expectedType.kind && (a = t.expectedType);
                let n = {}
                  , o = [];
                for (let i = 2; i < e.length - 1; i += 2) {
                    let l = e[i]
                      , s = e[i + 1];
                    Array.isArray(l) || (l = [l]);
                    let u = t.concat(i);
                    if (0 === l.length)
                        return u.error("Expected at least one branch label.");
                    for (let e of l) {
                        if ("number" != typeof e && "string" != typeof e)
                            return u.error("Branch labels must be numbers or strings.");
                        if ("number" == typeof e && Math.abs(e) > Number.MAX_SAFE_INTEGER)
                            return u.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                        if ("number" == typeof e && Math.floor(e) !== e)
                            return u.error("Numeric branch labels must be integer values.");
                        if (r) {
                            if (u.checkSubtype(r, tf(e)))
                                return null
                        } else
                            r = tf(e);
                        if ("u" > typeof n[String(e)])
                            return u.error("Branch labels must be unique.");
                        n[String(e)] = o.length
                    }
                    let p = t.parse(s, i, a);
                    if (!p)
                        return null;
                    a = a || p.type,
                    o.push(p)
                }
                let i = t.parse(e[1], 1, eA);
                if (!i)
                    return null;
                let l = t.parse(e[e.length - 1], e.length - 1, a);
                return !l || "value" !== i.type.kind && t.concat(1).checkSubtype(r, i.type) ? null : new tT(r,a,i,n,o,l)
            }
            evaluate(e) {
                let t = this.input.evaluate(e);
                return (tf(t) === this.inputType && this.outputs[this.cases[t]] || this.otherwise).evaluate(e)
            }
            eachChild(e) {
                e(this.input),
                this.outputs.forEach(e),
                e(this.otherwise)
            }
            outputDefined() {
                return this.outputs.every(e => e.outputDefined()) && this.otherwise.outputDefined()
            }
        }
        class tM {
            constructor(e, t, r) {
                this.type = e,
                this.branches = t,
                this.otherwise = r
            }
            static parse(e, t) {
                let r;
                if (e.length < 4)
                    return t.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
                if (e.length % 2 != 0)
                    return t.error("Expected an odd number of arguments.");
                t.expectedType && "value" !== t.expectedType.kind && (r = t.expectedType);
                let a = [];
                for (let n = 1; n < e.length - 1; n += 2) {
                    let o = t.parse(e[n], n, ek);
                    if (!o)
                        return null;
                    let i = t.parse(e[n + 1], n + 1, r);
                    if (!i)
                        return null;
                    a.push([o, i]),
                    r = r || i.type
                }
                let n = t.parse(e[e.length - 1], e.length - 1, r);
                if (!n)
                    return null;
                if (!r)
                    throw Error("Can't infer output type");
                return new tM(r,a,n)
            }
            evaluate(e) {
                for (let[t,r] of this.branches)
                    if (t.evaluate(e))
                        return r.evaluate(e);
                return this.otherwise.evaluate(e)
            }
            eachChild(e) {
                for (let[t,r] of this.branches)
                    e(t),
                    e(r);
                e(this.otherwise)
            }
            outputDefined() {
                return this.branches.every( ([e,t]) => t.outputDefined()) && this.otherwise.outputDefined()
            }
        }
        class tP {
            constructor(e, t, r, a) {
                this.type = e,
                this.input = t,
                this.beginIndex = r,
                this.endIndex = a
            }
            static parse(e, t) {
                if (e.length <= 2 || e.length >= 5)
                    return t.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
                let r = t.parse(e[1], 1, eA)
                  , a = t.parse(e[2], 2, ew);
                if (!r || !a)
                    return null;
                if (!eN(r.type, [ej(eA), eS, eA]))
                    return t.error(`Expected first argument to be of type array or string, but found ${eR(r.type)} instead`);
                if (4 !== e.length)
                    return new tP(r.type,r,a);
                {
                    let n = t.parse(e[3], 3, ew);
                    return n ? new tP(r.type,r,a,n) : null
                }
            }
            evaluate(e) {
                let t;
                let r = this.input.evaluate(e)
                  , a = this.beginIndex.evaluate(e);
                if (this.endIndex && (t = this.endIndex.evaluate(e)),
                eF(r, ["string"]))
                    return [...r].slice(a, t).join("");
                if (eF(r, ["array"]))
                    return r.slice(a, t);
                throw new tl(`Expected first argument to be of type array or string, but found ${eR(tf(r))} instead.`)
            }
            eachChild(e) {
                e(this.input),
                e(this.beginIndex),
                this.endIndex && e(this.endIndex)
            }
            outputDefined() {
                return !1
            }
        }
        function t$(e, t) {
            let r = e.length - 1, a = 0, n = r, o = 0, i, l;
            for (; a <= n; )
                if (i = e[o = Math.floor((a + n) / 2)],
                l = e[o + 1],
                i <= t) {
                    if (o === r || t < l)
                        return o;
                    a = o + 1
                } else if (i > t)
                    n = o - 1;
                else
                    throw new tl("Input is not a number.");
            return 0
        }
        class tI {
            constructor(e, t, r) {
                for (let[a,n] of (this.type = e,
                this.input = t,
                this.labels = [],
                this.outputs = [],
                r))
                    this.labels.push(a),
                    this.outputs.push(n)
            }
            static parse(e, t) {
                if (e.length - 1 < 4)
                    return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
                if ((e.length - 1) % 2 != 0)
                    return t.error("Expected an even number of arguments.");
                let r = t.parse(e[1], 1, ew);
                if (!r)
                    return null;
                let a = []
                  , n = null;
                t.expectedType && "value" !== t.expectedType.kind && (n = t.expectedType);
                for (let r = 1; r < e.length; r += 2) {
                    let o = 1 === r ? -1 / 0 : e[r]
                      , i = e[r + 1]
                      , l = r
                      , s = r + 1;
                    if ("number" != typeof o)
                        return t.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', l);
                    if (a.length && a[a.length - 1][0] >= o)
                        return t.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', l);
                    let u = t.parse(i, s, n);
                    if (!u)
                        return null;
                    n = n || u.type,
                    a.push([o, u])
                }
                return new tI(n,r,a)
            }
            evaluate(e) {
                let t = this.labels
                  , r = this.outputs;
                if (1 === t.length)
                    return r[0].evaluate(e);
                let a = this.input.evaluate(e);
                if (a <= t[0])
                    return r[0].evaluate(e);
                let n = t.length;
                return a >= t[n - 1] ? r[n - 1].evaluate(e) : r[t$(t, a)].evaluate(e)
            }
            eachChild(e) {
                for (let t of (e(this.input),
                this.outputs))
                    e(t)
            }
            outputDefined() {
                return this.outputs.every(e => e.outputDefined())
            }
        }
        var tz = (p = function() {
            if (d)
                return h;
            function e(e, t, r, a) {
                this.cx = 3 * e,
                this.bx = 3 * (r - e) - this.cx,
                this.ax = 1 - this.cx - this.bx,
                this.cy = 3 * t,
                this.by = 3 * (a - t) - this.cy,
                this.ay = 1 - this.cy - this.by,
                this.p1x = e,
                this.p1y = t,
                this.p2x = r,
                this.p2y = a
            }
            return d = 1,
            h = e,
            e.prototype = {
                sampleCurveX: function(e) {
                    return ((this.ax * e + this.bx) * e + this.cx) * e
                },
                sampleCurveY: function(e) {
                    return ((this.ay * e + this.by) * e + this.cy) * e
                },
                sampleCurveDerivativeX: function(e) {
                    return (3 * this.ax * e + 2 * this.bx) * e + this.cx
                },
                solveCurveX: function(e, t) {
                    if (void 0 === t && (t = 1e-6),
                    e < 0)
                        return 0;
                    if (e > 1)
                        return 1;
                    for (var r = e, a = 0; a < 8; a++) {
                        var n = this.sampleCurveX(r) - e;
                        if (Math.abs(n) < t)
                            return r;
                        var o = this.sampleCurveDerivativeX(r);
                        if (1e-6 > Math.abs(o))
                            break;
                        r -= n / o
                    }
                    var i = 0
                      , l = 1;
                    for (r = e,
                    a = 0; a < 20 && !(Math.abs((n = this.sampleCurveX(r)) - e) < t); a++)
                        e > n ? i = r : l = r,
                        r = (l - i) * .5 + i;
                    return r
                },
                solve: function(e, t) {
                    return this.sampleCurveY(this.solveCurveX(e, t))
                }
            },
            h
        }()) && p.__esModule && Object.prototype.hasOwnProperty.call(p, "default") ? p.default : p;
        class tj {
            constructor(e, t, r, a, n) {
                for (let[o,i] of (this.type = e,
                this.operator = t,
                this.interpolation = r,
                this.input = a,
                this.labels = [],
                this.outputs = [],
                n))
                    this.labels.push(o),
                    this.outputs.push(i)
            }
            static interpolationFactor(e, t, r, a) {
                let n = 0;
                if ("exponential" === e.name)
                    n = tR(t, e.base, r, a);
                else if ("linear" === e.name)
                    n = tR(t, 1, r, a);
                else if ("cubic-bezier" === e.name) {
                    let o = e.controlPoints;
                    n = new tz(o[0],o[1],o[2],o[3]).solve(tR(t, 1, r, a))
                }
                return n
            }
            static parse(e, t) {
                let[r,a,n,...o] = e;
                if (!Array.isArray(a) || 0 === a.length)
                    return t.error("Expected an interpolation type expression.", 1);
                if ("linear" === a[0])
                    a = {
                        name: "linear"
                    };
                else if ("exponential" === a[0]) {
                    let e = a[1];
                    if ("number" != typeof e)
                        return t.error("Exponential interpolation requires a numeric base.", 1, 1);
                    a = {
                        name: "exponential",
                        base: e
                    }
                } else {
                    if ("cubic-bezier" !== a[0])
                        return t.error(`Unknown interpolation type ${String(a[0])}`, 1, 0);
                    let e = a.slice(1);
                    if (4 !== e.length || e.some(e => "number" != typeof e || e < 0 || e > 1))
                        return t.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                    a = {
                        name: "cubic-bezier",
                        controlPoints: e
                    }
                }
                if (e.length - 1 < 4)
                    return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
                if ((e.length - 1) % 2 != 0)
                    return t.error("Expected an even number of arguments.");
                if (!(n = t.parse(n, 2, ew)))
                    return null;
                let i = []
                  , l = null;
                ("interpolate-hcl" === r || "interpolate-lab" === r) && t.expectedType != eP ? l = e_ : t.expectedType && "value" !== t.expectedType.kind && (l = t.expectedType);
                for (let e = 0; e < o.length; e += 2) {
                    let r = o[e]
                      , a = o[e + 1]
                      , n = e + 3
                      , s = e + 4;
                    if ("number" != typeof r)
                        return t.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', n);
                    if (i.length && i[i.length - 1][0] >= r)
                        return t.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', n);
                    let u = t.parse(a, s, l);
                    if (!u)
                        return null;
                    l = l || u.type,
                    i.push([r, u])
                }
                return eq(l, ew) || eq(l, eC) || eq(l, e_) || eq(l, eM) || eq(l, e$) || eq(l, eP) || eq(l, ez) || eq(l, ej(ew)) ? new tj(l,r,a,n,i) : t.error(`Type ${eR(l)} is not interpolatable.`)
            }
            evaluate(e) {
                let t = this.labels
                  , r = this.outputs;
                if (1 === t.length)
                    return r[0].evaluate(e);
                let a = this.input.evaluate(e);
                if (a <= t[0])
                    return r[0].evaluate(e);
                let n = t.length;
                if (a >= t[n - 1])
                    return r[n - 1].evaluate(e);
                let o = t$(t, a)
                  , i = t[o]
                  , l = t[o + 1]
                  , s = tj.interpolationFactor(this.interpolation, a, i, l)
                  , u = r[o].evaluate(e)
                  , p = r[o + 1].evaluate(e);
                switch (this.operator) {
                case "interpolate":
                    switch (this.type.kind) {
                    case "number":
                        return u + s * (p - u);
                    case "color":
                        return e9.interpolate(u, p, s);
                    case "padding":
                        return tn.interpolate(u, p, s);
                    case "colorArray":
                        return ti.interpolate(u, p, s);
                    case "numberArray":
                        return to.interpolate(u, p, s);
                    case "variableAnchorOffsetCollection":
                        return tu.interpolate(u, p, s);
                    case "array":
                        return e7(u, p, s);
                    case "projectionDefinition":
                        return tc.interpolate(u, p, s)
                    }
                case "interpolate-hcl":
                    switch (this.type.kind) {
                    case "color":
                        return e9.interpolate(u, p, s, "hcl");
                    case "colorArray":
                        return ti.interpolate(u, p, s, "hcl")
                    }
                case "interpolate-lab":
                    switch (this.type.kind) {
                    case "color":
                        return e9.interpolate(u, p, s, "lab");
                    case "colorArray":
                        return ti.interpolate(u, p, s, "lab")
                    }
                }
            }
            eachChild(e) {
                for (let t of (e(this.input),
                this.outputs))
                    e(t)
            }
            outputDefined() {
                return this.outputs.every(e => e.outputDefined())
            }
        }
        function tR(e, t, r, a) {
            let n = a - r
              , o = e - r;
            return 0 === n ? 0 : 1 === t ? o / n : (Math.pow(t, o) - 1) / (Math.pow(t, n) - 1)
        }
        e9.interpolate,
        tn.interpolate,
        to.interpolate,
        ti.interpolate,
        tu.interpolate;
        class tO {
            constructor(e, t) {
                this.type = e,
                this.args = t
            }
            static parse(e, t) {
                if (e.length < 2)
                    return t.error("Expected at least one argument.");
                let r = null
                  , a = t.expectedType;
                a && "value" !== a.kind && (r = a);
                let n = [];
                for (let a of e.slice(1)) {
                    let e = t.parse(a, 1 + n.length, r, void 0, {
                        typeAnnotation: "omit"
                    });
                    if (!e)
                        return null;
                    r = r || e.type,
                    n.push(e)
                }
                if (!r)
                    throw Error("No output type");
                return a && n.some(e => eU(a, e.type)) ? new tO(eA,n) : new tO(r,n)
            }
            evaluate(e) {
                let t = null, r = 0, a;
                for (let n of this.args)
                    if (r++,
                    (t = n.evaluate(e)) && t instanceof tp && !t.available && (a || (a = t.name),
                    t = null,
                    r === this.args.length && (t = a)),
                    null !== t)
                        break;
                return t
            }
            eachChild(e) {
                this.args.forEach(e)
            }
            outputDefined() {
                return this.args.every(e => e.outputDefined())
            }
        }
        function tU(e, t) {
            return "==" === e || "!=" === e ? "boolean" === t.kind || "string" === t.kind || "number" === t.kind || "null" === t.kind || "value" === t.kind : "string" === t.kind || "number" === t.kind || "value" === t.kind
        }
        function tN(e, t, r, a) {
            return 0 === a.compare(t, r)
        }
        function tF(e, t, r) {
            let a = "==" !== e && "!=" !== e;
            return class n {
                constructor(e, t, r) {
                    this.type = ek,
                    this.lhs = e,
                    this.rhs = t,
                    this.collator = r,
                    this.hasUntypedArgument = "value" === e.type.kind || "value" === t.type.kind
                }
                static parse(e, t) {
                    if (3 !== e.length && 4 !== e.length)
                        return t.error("Expected two or three arguments.");
                    let r = e[0]
                      , o = t.parse(e[1], 1, eA);
                    if (!o)
                        return null;
                    if (!tU(r, o.type))
                        return t.concat(1).error(`"${r}" comparisons are not supported for type '${eR(o.type)}'.`);
                    let i = t.parse(e[2], 2, eA);
                    if (!i)
                        return null;
                    if (!tU(r, i.type))
                        return t.concat(2).error(`"${r}" comparisons are not supported for type '${eR(i.type)}'.`);
                    if (o.type.kind !== i.type.kind && "value" !== o.type.kind && "value" !== i.type.kind)
                        return t.error(`Cannot compare types '${eR(o.type)}' and '${eR(i.type)}'.`);
                    a && ("value" === o.type.kind && "value" !== i.type.kind ? o = new tv(i.type,[o]) : "value" !== o.type.kind && "value" === i.type.kind && (i = new tv(o.type,[i])));
                    let l = null;
                    if (4 === e.length) {
                        if ("string" !== o.type.kind && "string" !== i.type.kind && "value" !== o.type.kind && "value" !== i.type.kind)
                            return t.error("Cannot use collator to compare non-string types.");
                        if (!(l = t.parse(e[3], 3, eL)))
                            return null
                    }
                    return new n(o,i,l)
                }
                evaluate(n) {
                    let o = this.lhs.evaluate(n)
                      , i = this.rhs.evaluate(n);
                    if (a && this.hasUntypedArgument) {
                        let t = tf(o)
                          , r = tf(i);
                        if (t.kind !== r.kind || !("string" === t.kind || "number" === t.kind))
                            throw new tl(`Expected arguments for "${e}" to be (string, string) or (number, number), but found (${t.kind}, ${r.kind}) instead.`)
                    }
                    if (this.collator && !a && this.hasUntypedArgument) {
                        let e = tf(o)
                          , r = tf(i);
                        if ("string" !== e.kind || "string" !== r.kind)
                            return t(n, o, i)
                    }
                    return this.collator ? r(n, o, i, this.collator.evaluate(n)) : t(n, o, i)
                }
                eachChild(e) {
                    e(this.lhs),
                    e(this.rhs),
                    this.collator && e(this.collator)
                }
                outputDefined() {
                    return !0
                }
            }
        }
        let tq = tF("==", function(e, t, r) {
            return t === r
        }, tN)
          , tD = tF("!=", function(e, t, r) {
            return t !== r
        }, function(e, t, r, a) {
            return !tN(e, t, r, a)
        })
          , tB = tF("<", function(e, t, r) {
            return t < r
        }, function(e, t, r, a) {
            return 0 > a.compare(t, r)
        })
          , tG = tF(">", function(e, t, r) {
            return t > r
        }, function(e, t, r, a) {
            return a.compare(t, r) > 0
        })
          , tV = tF("<=", function(e, t, r) {
            return t <= r
        }, function(e, t, r, a) {
            return 0 >= a.compare(t, r)
        })
          , tH = tF(">=", function(e, t, r) {
            return t >= r
        }, function(e, t, r, a) {
            return a.compare(t, r) >= 0
        });
        class tX {
            constructor(e, t, r) {
                this.type = eL,
                this.locale = r,
                this.caseSensitive = e,
                this.diacriticSensitive = t
            }
            static parse(e, t) {
                if (2 !== e.length)
                    return t.error("Expected one argument.");
                let r = e[1];
                if ("object" != typeof r || Array.isArray(r))
                    return t.error("Collator options argument must be an object.");
                let a = t.parse(void 0 !== r["case-sensitive"] && r["case-sensitive"], 1, ek);
                if (!a)
                    return null;
                let n = t.parse(void 0 !== r["diacritic-sensitive"] && r["diacritic-sensitive"], 1, ek);
                if (!n)
                    return null;
                let o = null;
                return !r.locale || (o = t.parse(r.locale, 1, eS)) ? new tX(a,n,o) : null
            }
            evaluate(e) {
                return new te(this.caseSensitive.evaluate(e),this.diacriticSensitive.evaluate(e),this.locale ? this.locale.evaluate(e) : null)
            }
            eachChild(e) {
                e(this.caseSensitive),
                e(this.diacriticSensitive),
                this.locale && e(this.locale)
            }
            outputDefined() {
                return !1
            }
        }
        class tK {
            constructor(e, t, r, a, n) {
                this.type = eS,
                this.number = e,
                this.locale = t,
                this.currency = r,
                this.minFractionDigits = a,
                this.maxFractionDigits = n
            }
            static parse(e, t) {
                if (3 !== e.length)
                    return t.error("Expected two arguments.");
                let r = t.parse(e[1], 1, ew);
                if (!r)
                    return null;
                let a = e[2];
                if ("object" != typeof a || Array.isArray(a))
                    return t.error("NumberFormat options argument must be an object.");
                let n = null;
                if (a.locale && !(n = t.parse(a.locale, 1, eS)))
                    return null;
                let o = null;
                if (a.currency && !(o = t.parse(a.currency, 1, eS)))
                    return null;
                let i = null;
                if (a["min-fraction-digits"] && !(i = t.parse(a["min-fraction-digits"], 1, ew)))
                    return null;
                let l = null;
                return !a["max-fraction-digits"] || (l = t.parse(a["max-fraction-digits"], 1, ew)) ? new tK(r,n,o,i,l) : null
            }
            evaluate(e) {
                return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [],{
                    style: this.currency ? "currency" : "decimal",
                    currency: this.currency ? this.currency.evaluate(e) : void 0,
                    minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0,
                    maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0
                }).format(this.number.evaluate(e))
            }
            eachChild(e) {
                e(this.number),
                this.locale && e(this.locale),
                this.currency && e(this.currency),
                this.minFractionDigits && e(this.minFractionDigits),
                this.maxFractionDigits && e(this.maxFractionDigits)
            }
            outputDefined() {
                return !1
            }
        }
        class tZ {
            constructor(e) {
                this.type = eT,
                this.sections = e
            }
            static parse(e, t) {
                if (e.length < 2)
                    return t.error("Expected at least one argument.");
                let r = e[1];
                if (!Array.isArray(r) && "object" == typeof r)
                    return t.error("First argument must be an image or text section.");
                let a = []
                  , n = !1;
                for (let r = 1; r <= e.length - 1; ++r) {
                    let o = e[r];
                    if (n && "object" == typeof o && !Array.isArray(o)) {
                        n = !1;
                        let e = null;
                        if (o["font-scale"] && !(e = t.parse(o["font-scale"], 1, ew)))
                            return null;
                        let r = null;
                        if (o["text-font"] && !(r = t.parse(o["text-font"], 1, ej(eS))))
                            return null;
                        let i = null;
                        if (o["text-color"] && !(i = t.parse(o["text-color"], 1, e_)))
                            return null;
                        let l = null;
                        if (o["vertical-align"]) {
                            if ("string" == typeof o["vertical-align"] && !tt.includes(o["vertical-align"]))
                                return t.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${o["vertical-align"]}' instead.`);
                            if (!(l = t.parse(o["vertical-align"], 1, eS)))
                                return null
                        }
                        let s = a[a.length - 1];
                        s.scale = e,
                        s.font = r,
                        s.textColor = i,
                        s.verticalAlign = l
                    } else {
                        let o = t.parse(e[r], 1, eA);
                        if (!o)
                            return null;
                        let i = o.type.kind;
                        if ("string" !== i && "value" !== i && "null" !== i && "resolvedImage" !== i)
                            return t.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                        n = !0,
                        a.push({
                            content: o,
                            scale: null,
                            font: null,
                            textColor: null,
                            verticalAlign: null
                        })
                    }
                }
                return new tZ(a)
            }
            evaluate(e) {
                return new ta(this.sections.map(t => {
                    let r = t.content.evaluate(e);
                    return tf(r) === eI ? new tr("",r,null,null,null,t.verticalAlign ? t.verticalAlign.evaluate(e) : null) : new tr(tm(r),null,t.scale ? t.scale.evaluate(e) : null,t.font ? t.font.evaluate(e).join(",") : null,t.textColor ? t.textColor.evaluate(e) : null,t.verticalAlign ? t.verticalAlign.evaluate(e) : null)
                }
                ))
            }
            eachChild(e) {
                for (let t of this.sections)
                    e(t.content),
                    t.scale && e(t.scale),
                    t.font && e(t.font),
                    t.textColor && e(t.textColor),
                    t.verticalAlign && e(t.verticalAlign)
            }
            outputDefined() {
                return !1
            }
        }
        class tW {
            constructor(e) {
                this.type = eI,
                this.input = e
            }
            static parse(e, t) {
                if (2 !== e.length)
                    return t.error("Expected two arguments.");
                let r = t.parse(e[1], 1, eS);
                return r ? new tW(r) : t.error("No image name provided.")
            }
            evaluate(e) {
                let t = this.input.evaluate(e)
                  , r = tp.fromString(t);
                return r && e.availableImages && (r.available = e.availableImages.indexOf(t) > -1),
                r
            }
            eachChild(e) {
                e(this.input)
            }
            outputDefined() {
                return !1
            }
        }
        class tY {
            constructor(e) {
                this.type = ew,
                this.input = e
            }
            static parse(e, t) {
                if (2 !== e.length)
                    return t.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
                let r = t.parse(e[1], 1);
                return r ? "array" !== r.type.kind && "string" !== r.type.kind && "value" !== r.type.kind ? t.error(`Expected argument of type string or array, but found ${eR(r.type)} instead.`) : new tY(r) : null
            }
            evaluate(e) {
                let t = this.input.evaluate(e);
                if ("string" == typeof t)
                    return [...t].length;
                if (Array.isArray(t))
                    return t.length;
                throw new tl(`Expected value to be of type string or array, but found ${eR(tf(t))} instead.`)
            }
            eachChild(e) {
                e(this.input)
            }
            outputDefined() {
                return !1
            }
        }
        function tJ(e, t) {
            let r = Math.pow(2, t.z);
            return [(e[0] / 8192 + t.x) / r * 360 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - (e[1] / 8192 + t.y) / r * 360) * Math.PI / 180)) - 90]
        }
        function tQ(e, t) {
            e[0] = Math.min(e[0], t[0]),
            e[1] = Math.min(e[1], t[1]),
            e[2] = Math.max(e[2], t[0]),
            e[3] = Math.max(e[3], t[1])
        }
        function t0(e, t) {
            return !(e[0] <= t[0] || e[2] >= t[2] || e[1] <= t[1] || e[3] >= t[3])
        }
        function t1(e, t, r, a) {
            var n;
            let o = [t[0] - e[0], t[1] - e[1]];
            return 0 != (n = [a[0] - r[0], a[1] - r[1]])[0] * o[1] - n[1] * o[0] && !!(t3(e, t, r, a) && t3(r, a, e, t))
        }
        function t2(e, t, r=!1) {
            let a = !1;
            for (let i of t)
                for (let t = 0; t < i.length - 1; t++) {
                    var n, o;
                    if (function(e, t, r) {
                        let a = e[0] - t[0]
                          , n = e[1] - t[1]
                          , o = e[0] - r[0]
                          , i = e[1] - r[1];
                        return a * i - o * n == 0 && a * o <= 0 && n * i <= 0
                    }(e, i[t], i[t + 1]))
                        return r;
                    n = i[t],
                    o = i[t + 1],
                    n[1] > e[1] != o[1] > e[1] && e[0] < (o[0] - n[0]) * (e[1] - n[1]) / (o[1] - n[1]) + n[0] && (a = !a)
                }
            return a
        }
        function t5(e, t) {
            for (let r of e)
                if (!t2(r, t))
                    return !1;
            for (let r = 0; r < e.length - 1; ++r)
                if (function(e, t, r) {
                    for (let a of r)
                        for (let r = 0; r < a.length - 1; ++r)
                            if (t1(e, t, a[r], a[r + 1]))
                                return !0;
                    return !1
                }(e[r], e[r + 1], t))
                    return !1;
            return !0
        }
        function t3(e, t, r, a) {
            let n = e[0] - r[0]
              , o = e[1] - r[1]
              , i = t[0] - r[0]
              , l = t[1] - r[1]
              , s = a[0] - r[0]
              , u = a[1] - r[1]
              , p = n * u - s * o
              , c = i * u - s * l;
            return p > 0 && c < 0 || p < 0 && c > 0
        }
        function t4(e, t, r) {
            let a = [];
            for (let n = 0; n < e.length; n++) {
                let o = [];
                for (let a = 0; a < e[n].length; a++) {
                    let i = function(e, t) {
                        let r = (180 + e[0]) / 360
                          , a = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + e[1] * Math.PI / 360))) / 360
                          , n = Math.pow(2, t.z);
                        return [Math.round(r * n * 8192), Math.round(a * n * 8192)]
                    }(e[n][a], r);
                    tQ(t, i),
                    o.push(i)
                }
                a.push(o)
            }
            return a
        }
        function t8(e, t, r) {
            let a = [];
            for (let n = 0; n < e.length; n++) {
                let o = t4(e[n], t, r);
                a.push(o)
            }
            return a
        }
        function t6(e, t, r, a) {
            if (e[0] < r[0] || e[0] > r[2]) {
                let t = .5 * a
                  , n = e[0] - r[0] > t ? -a : r[0] - e[0] > t ? a : 0;
                0 === n && (n = e[0] - r[2] > t ? -a : r[2] - e[0] > t ? a : 0),
                e[0] += n
            }
            tQ(t, e)
        }
        function t7(e, t, r, a) {
            let n = 8192 * Math.pow(2, a.z)
              , o = [8192 * a.x, 8192 * a.y]
              , i = [];
            for (let a of e)
                for (let e of a) {
                    let a = [e.x + o[0], e.y + o[1]];
                    t6(a, t, r, n),
                    i.push(a)
                }
            return i
        }
        function t9(e, t, r, a) {
            let n = 8192 * Math.pow(2, a.z)
              , o = [8192 * a.x, 8192 * a.y]
              , i = [];
            for (let r of e) {
                let e = [];
                for (let a of r) {
                    let r = [a.x + o[0], a.y + o[1]];
                    tQ(t, r),
                    e.push(r)
                }
                i.push(e)
            }
            if (t[2] - t[0] <= n / 2)
                for (let e of (t[0] = t[1] = 1 / 0,
                t[2] = t[3] = -1 / 0,
                i))
                    for (let a of e)
                        t6(a, t, r, n);
            return i
        }
        class re {
            constructor(e, t) {
                this.type = ek,
                this.geojson = e,
                this.geometries = t
            }
            static parse(e, t) {
                if (2 !== e.length)
                    return t.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
                if (td(e[1])) {
                    let t = e[1];
                    if ("FeatureCollection" === t.type) {
                        let e = [];
                        for (let r of t.features) {
                            let {type: t, coordinates: a} = r.geometry;
                            "Polygon" === t && e.push(a),
                            "MultiPolygon" === t && e.push(...a)
                        }
                        if (e.length)
                            return new re(t,{
                                type: "MultiPolygon",
                                coordinates: e
                            })
                    } else if ("Feature" === t.type) {
                        let e = t.geometry.type;
                        if ("Polygon" === e || "MultiPolygon" === e)
                            return new re(t,t.geometry)
                    } else if ("Polygon" === t.type || "MultiPolygon" === t.type)
                        return new re(t,t)
                }
                return t.error("'within' expression requires valid geojson object that contains polygon geometry type.")
            }
            evaluate(e) {
                if (null != e.geometry() && null != e.canonicalID()) {
                    if ("Point" === e.geometryType())
                        return function(e, t) {
                            let r = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                              , a = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                              , n = e.canonicalID();
                            if ("Polygon" === t.type) {
                                let o = t4(t.coordinates, a, n)
                                  , i = t7(e.geometry(), r, a, n);
                                if (!t0(r, a))
                                    return !1;
                                for (let e of i)
                                    if (!t2(e, o))
                                        return !1
                            }
                            if ("MultiPolygon" === t.type) {
                                let o = t8(t.coordinates, a, n)
                                  , i = t7(e.geometry(), r, a, n);
                                if (!t0(r, a))
                                    return !1;
                                for (let e of i)
                                    if (!function(e, t) {
                                        for (let r of t)
                                            if (t2(e, r))
                                                return !0;
                                        return !1
                                    }(e, o))
                                        return !1
                            }
                            return !0
                        }(e, this.geometries);
                    if ("LineString" === e.geometryType())
                        return function(e, t) {
                            let r = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                              , a = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                              , n = e.canonicalID();
                            if ("Polygon" === t.type) {
                                let o = t4(t.coordinates, a, n)
                                  , i = t9(e.geometry(), r, a, n);
                                if (!t0(r, a))
                                    return !1;
                                for (let e of i)
                                    if (!t5(e, o))
                                        return !1
                            }
                            if ("MultiPolygon" === t.type) {
                                let o = t8(t.coordinates, a, n)
                                  , i = t9(e.geometry(), r, a, n);
                                if (!t0(r, a))
                                    return !1;
                                for (let e of i)
                                    if (!function(e, t) {
                                        for (let r of t)
                                            if (t5(e, r))
                                                return !0;
                                        return !1
                                    }(e, o))
                                        return !1
                            }
                            return !0
                        }(e, this.geometries)
                }
                return !1
            }
            eachChild() {}
            outputDefined() {
                return !0
            }
        }
        class rt {
            constructor(e=[], t= (e, t) => e < t ? -1 : e > t ? 1 : 0) {
                if (this.data = e,
                this.length = this.data.length,
                this.compare = t,
                this.length > 0)
                    for (let e = (this.length >> 1) - 1; e >= 0; e--)
                        this._down(e)
            }
            push(e) {
                this.data.push(e),
                this._up(this.length++)
            }
            pop() {
                if (0 === this.length)
                    return;
                let e = this.data[0]
                  , t = this.data.pop();
                return --this.length > 0 && (this.data[0] = t,
                this._down(0)),
                e
            }
            peek() {
                return this.data[0]
            }
            _up(e) {
                let {data: t, compare: r} = this
                  , a = t[e];
                for (; e > 0; ) {
                    let n = e - 1 >> 1
                      , o = t[n];
                    if (r(a, o) >= 0)
                        break;
                    t[e] = o,
                    e = n
                }
                t[e] = a
            }
            _down(e) {
                let {data: t, compare: r} = this
                  , a = this.length >> 1
                  , n = t[e];
                for (; e < a; ) {
                    let a = (e << 1) + 1
                      , o = a + 1;
                    if (o < this.length && 0 > r(t[o], t[a]) && (a = o),
                    r(t[a], n) >= 0)
                        break;
                    t[e] = t[a],
                    e = a
                }
                t[e] = n
            }
        }
        let rr = 1 / 298.257223563 * (2 - 1 / 298.257223563)
          , ra = Math.PI / 180;
        class rn {
            constructor(e) {
                let t = 6378137 * ra
                  , r = Math.cos(e * ra)
                  , a = 1 / (1 - rr * (1 - r * r))
                  , n = Math.sqrt(a);
                this.kx = t * n * r,
                this.ky = t * n * a * (1 - rr)
            }
            distance(e, t) {
                let r = this.wrap(e[0] - t[0]) * this.kx
                  , a = (e[1] - t[1]) * this.ky;
                return Math.sqrt(r * r + a * a)
            }
            pointOnLine(e, t) {
                let r = 1 / 0, a, n, o, i;
                for (let l = 0; l < e.length - 1; l++) {
                    let s = e[l][0]
                      , u = e[l][1]
                      , p = this.wrap(e[l + 1][0] - s) * this.kx
                      , c = (e[l + 1][1] - u) * this.ky
                      , h = 0;
                    (0 !== p || 0 !== c) && ((h = (this.wrap(t[0] - s) * this.kx * p + (t[1] - u) * this.ky * c) / (p * p + c * c)) > 1 ? (s = e[l + 1][0],
                    u = e[l + 1][1]) : h > 0 && (s += p / this.kx * h,
                    u += c / this.ky * h));
                    let d = (p = this.wrap(t[0] - s) * this.kx) * p + (c = (t[1] - u) * this.ky) * c;
                    d < r && (r = d,
                    a = s,
                    n = u,
                    o = l,
                    i = h)
                }
                return {
                    point: [a, n],
                    index: o,
                    t: Math.max(0, Math.min(1, i))
                }
            }
            wrap(e) {
                for (; e < -180; )
                    e += 360;
                for (; e > 180; )
                    e -= 360;
                return e
            }
        }
        function ro(e, t) {
            return t[0] - e[0]
        }
        function ri(e) {
            return e[1] - e[0] + 1
        }
        function rl(e, t) {
            return e[1] >= e[0] && e[1] < t
        }
        function rs(e, t) {
            if (e[0] > e[1])
                return [null, null];
            let r = ri(e);
            if (t) {
                if (2 === r)
                    return [e, null];
                let t = Math.floor(r / 2);
                return [[e[0], e[0] + t], [e[0] + t, e[1]]]
            }
            if (1 === r)
                return [e, null];
            let a = Math.floor(r / 2) - 1;
            return [[e[0], e[0] + a], [e[0] + a + 1, e[1]]]
        }
        function ru(e, t) {
            if (!rl(t, e.length))
                return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            let r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let a = t[0]; a <= t[1]; ++a)
                tQ(r, e[a]);
            return r
        }
        function rp(e) {
            let t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let r of e)
                for (let e of r)
                    tQ(t, e);
            return t
        }
        function rc(e) {
            return e[0] !== -1 / 0 && e[1] !== -1 / 0 && e[2] !== 1 / 0 && e[3] !== 1 / 0
        }
        function rh(e, t, r) {
            if (!rc(e) || !rc(t))
                return NaN;
            let a = 0
              , n = 0;
            return e[2] < t[0] && (a = t[0] - e[2]),
            e[0] > t[2] && (a = e[0] - t[2]),
            e[1] > t[3] && (n = e[1] - t[3]),
            e[3] < t[1] && (n = t[1] - e[3]),
            r.distance([0, 0], [a, n])
        }
        function rd(e, t, r) {
            let a = r.pointOnLine(t, e);
            return r.distance(e, a.point)
        }
        function rf(e, t, r, a, n) {
            return Math.min(Math.min(rd(e, [r, a], n), rd(t, [r, a], n)), Math.min(rd(r, [e, t], n), rd(a, [e, t], n)))
        }
        function rm(e, t) {
            for (let r of e)
                for (let e of r)
                    if (t2(e, t, !0))
                        return !0;
            return !1
        }
        function ry(e, t, r, a, n, o) {
            if (!o)
                return;
            let i = rh(ru(a, o), n, r);
            i < t && e.push([i, o, [0, 0]])
        }
        function rg(e, t, r, a, n, o, i) {
            if (!o || !i)
                return;
            let l = rh(ru(a, o), ru(n, i), r);
            l < t && e.push([l, o, i])
        }
        function rv(e, t, r, a, n=1 / 0) {
            let o = Math.min(a.distance(e[0], r[0][0]), n);
            if (0 === o)
                return o;
            let i = new rt([[0, [0, e.length - 1], [0, 0]]],ro)
              , l = rp(r);
            for (; i.length > 0; ) {
                let n = i.pop();
                if (n[0] >= o)
                    continue;
                let s = n[1]
                  , u = t ? 50 : 100;
                if (ri(s) <= u) {
                    if (!rl(s, e.length))
                        return NaN;
                    if (t) {
                        let t = function(e, t, r, a) {
                            if (!rl(t, e.length))
                                return NaN;
                            for (let a = t[0]; a <= t[1]; ++a)
                                if (t2(e[a], r, !0))
                                    return 0;
                            let n = 1 / 0;
                            for (let o = t[0]; o < t[1]; ++o) {
                                let t = e[o]
                                  , i = e[o + 1];
                                for (let e of r)
                                    for (let r = 0, o = e.length, l = o - 1; r < o; l = r++) {
                                        let o = e[l]
                                          , s = e[r];
                                        if (t1(t, i, o, s))
                                            return 0;
                                        n = Math.min(n, rf(t, i, o, s, a))
                                    }
                            }
                            return n
                        }(e, s, r, a);
                        if (isNaN(t) || 0 === t)
                            return t;
                        o = Math.min(o, t)
                    } else
                        for (let t = s[0]; t <= s[1]; ++t)
                            if (0 === (o = Math.min(o, function(e, t, r) {
                                if (t2(e, t, !0))
                                    return 0;
                                let a = 1 / 0;
                                for (let n of t) {
                                    let t = n[0]
                                      , o = n[n.length - 1];
                                    if (t !== o && 0 === (a = Math.min(a, rd(e, [o, t], r))))
                                        break;
                                    let i = r.pointOnLine(n, e);
                                    if (0 === (a = Math.min(a, r.distance(e, i.point))))
                                        break
                                }
                                return a
                            }(e[t], r, a))))
                                return 0
                } else {
                    let r = rs(s, t);
                    ry(i, o, a, e, l, r[0]),
                    ry(i, o, a, e, l, r[1])
                }
            }
            return o
        }
        function rb(e, t, r, a, n, o=1 / 0) {
            let i = Math.min(o, n.distance(e[0], r[0]));
            if (0 === i)
                return i;
            let l = new rt([[0, [0, e.length - 1], [0, r.length - 1]]],ro);
            for (; l.length > 0; ) {
                let o = l.pop();
                if (o[0] >= i)
                    continue;
                let s = o[1]
                  , u = o[2]
                  , p = t ? 50 : 100
                  , c = a ? 50 : 100;
                if (ri(s) <= p && ri(u) <= c) {
                    if (!rl(s, e.length) && rl(u, r.length))
                        return NaN;
                    if (t && a)
                        i = Math.min(i, function(e, t, r, a, n) {
                            if (!(rl(t, e.length) && rl(a, r.length)))
                                return 1 / 0;
                            let o = 1 / 0;
                            for (let i = t[0]; i < t[1]; ++i) {
                                let t = e[i]
                                  , l = e[i + 1];
                                for (let e = a[0]; e < a[1]; ++e) {
                                    let a = r[e]
                                      , i = r[e + 1];
                                    if (t1(t, l, a, i))
                                        return 0;
                                    o = Math.min(o, rf(t, l, a, i, n))
                                }
                            }
                            return o
                        }(e, s, r, u, n));
                    else if (t && !a) {
                        let t = e.slice(s[0], s[1] + 1);
                        for (let e = u[0]; e <= u[1]; ++e)
                            if (0 === (i = Math.min(i, rd(r[e], t, n))))
                                return i
                    } else if (!t && a) {
                        let t = r.slice(u[0], u[1] + 1);
                        for (let r = s[0]; r <= s[1]; ++r)
                            if (0 === (i = Math.min(i, rd(e[r], t, n))))
                                return i
                    } else
                        i = Math.min(i, function(e, t, r, a, n) {
                            if (!(rl(t, e.length) && rl(a, r.length)))
                                return NaN;
                            let o = 1 / 0;
                            for (let i = t[0]; i <= t[1]; ++i)
                                for (let t = a[0]; t <= a[1]; ++t)
                                    if (0 === (o = Math.min(o, n.distance(e[i], r[t]))))
                                        return o;
                            return o
                        }(e, s, r, u, n))
                } else {
                    let o = rs(s, t)
                      , p = rs(u, a);
                    rg(l, i, n, e, r, o[0], p[0]),
                    rg(l, i, n, e, r, o[0], p[1]),
                    rg(l, i, n, e, r, o[1], p[0]),
                    rg(l, i, n, e, r, o[1], p[1])
                }
            }
            return i
        }
        function rx(e) {
            return "MultiPolygon" === e.type ? e.coordinates.map(e => ({
                type: "Polygon",
                coordinates: e
            })) : "MultiLineString" === e.type ? e.coordinates.map(e => ({
                type: "LineString",
                coordinates: e
            })) : "MultiPoint" === e.type ? e.coordinates.map(e => ({
                type: "Point",
                coordinates: e
            })) : [e]
        }
        class rw {
            constructor(e, t) {
                this.type = ew,
                this.geojson = e,
                this.geometries = t
            }
            static parse(e, t) {
                if (2 !== e.length)
                    return t.error(`'distance' expression requires exactly one argument, but found ${e.length - 1} instead.`);
                if (td(e[1])) {
                    let t = e[1];
                    if ("FeatureCollection" === t.type)
                        return new rw(t,t.features.map(e => rx(e.geometry)).flat());
                    if ("Feature" === t.type)
                        return new rw(t,rx(t.geometry));
                    if ("type"in t && "coordinates"in t)
                        return new rw(t,rx(t))
                }
                return t.error("'distance' expression requires valid geojson object that contains polygon geometry type.")
            }
            evaluate(e) {
                if (null != e.geometry() && null != e.canonicalID()) {
                    if ("Point" === e.geometryType())
                        return function(e, t) {
                            let r = e.geometry()
                              , a = r.flat().map(t => tJ([t.x, t.y], e.canonical));
                            if (0 === r.length)
                                return NaN;
                            let n = new rn(a[0][1])
                              , o = 1 / 0;
                            for (let e of t) {
                                switch (e.type) {
                                case "Point":
                                    o = Math.min(o, rb(a, !1, [e.coordinates], !1, n, o));
                                    break;
                                case "LineString":
                                    o = Math.min(o, rb(a, !1, e.coordinates, !0, n, o));
                                    break;
                                case "Polygon":
                                    o = Math.min(o, rv(a, !1, e.coordinates, n, o))
                                }
                                if (0 === o)
                                    break
                            }
                            return o
                        }(e, this.geometries);
                    if ("LineString" === e.geometryType())
                        return function(e, t) {
                            let r = e.geometry()
                              , a = r.flat().map(t => tJ([t.x, t.y], e.canonical));
                            if (0 === r.length)
                                return NaN;
                            let n = new rn(a[0][1])
                              , o = 1 / 0;
                            for (let e of t) {
                                switch (e.type) {
                                case "Point":
                                    o = Math.min(o, rb(a, !0, [e.coordinates], !1, n, o));
                                    break;
                                case "LineString":
                                    o = Math.min(o, rb(a, !0, e.coordinates, !0, n, o));
                                    break;
                                case "Polygon":
                                    o = Math.min(o, rv(a, !0, e.coordinates, n, o))
                                }
                                if (0 === o)
                                    break
                            }
                            return o
                        }(e, this.geometries);
                    if ("Polygon" === e.geometryType())
                        return function(e, t) {
                            let r = e.geometry();
                            if (0 === r.length || 0 === r[0].length)
                                return NaN;
                            let a = (function(e, t) {
                                let r, a;
                                if (e.length <= 1)
                                    return [e];
                                let n = [];
                                for (let t of e) {
                                    let e = function(e) {
                                        let t = 0;
                                        for (let r = 0, a = e.length, n = a - 1, o, i; r < a; n = r++)
                                            o = e[r],
                                            t += ((i = e[n]).x - o.x) * (o.y + i.y);
                                        return t
                                    }(t);
                                    0 !== e && (t.area = Math.abs(e),
                                    void 0 === a && (a = e < 0),
                                    a === e < 0 ? (r && n.push(r),
                                    r = [t]) : r.push(t))
                                }
                                return r && n.push(r),
                                n
                            }
                            )(r).map(t => t.map(t => t.map(t => tJ([t.x, t.y], e.canonical))))
                              , n = new rn(a[0][0][0][1])
                              , o = 1 / 0;
                            for (let e of t)
                                for (let t of a) {
                                    switch (e.type) {
                                    case "Point":
                                        o = Math.min(o, rv([e.coordinates], !1, t, n, o));
                                        break;
                                    case "LineString":
                                        o = Math.min(o, rv(e.coordinates, !0, t, n, o));
                                        break;
                                    case "Polygon":
                                        o = Math.min(o, function(e, t, r, a=1 / 0) {
                                            let n = rp(e)
                                              , o = rp(t);
                                            if (a !== 1 / 0 && rh(n, o, r) >= a)
                                                return a;
                                            if (t0(n, o)) {
                                                if (rm(e, t))
                                                    return 0
                                            } else if (rm(t, e))
                                                return 0;
                                            let i = 1 / 0;
                                            for (let a of e)
                                                for (let e = 0, n = a.length, o = n - 1; e < n; o = e++) {
                                                    let n = a[o]
                                                      , l = a[e];
                                                    for (let e of t)
                                                        for (let t = 0, a = e.length, o = a - 1; t < a; o = t++) {
                                                            let a = e[o]
                                                              , s = e[t];
                                                            if (t1(n, l, a, s))
                                                                return 0;
                                                            i = Math.min(i, rf(n, l, a, s, r))
                                                        }
                                                }
                                            return i
                                        }(t, e.coordinates, n, o))
                                    }
                                    if (0 === o)
                                        return o
                                }
                            return o
                        }(e, this.geometries)
                }
                return NaN
            }
            eachChild() {}
            outputDefined() {
                return !0
            }
        }
        class rS {
            constructor(e) {
                this.type = eA,
                this.key = e
            }
            static parse(e, t) {
                if (2 !== e.length)
                    return t.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
                let r = e[1];
                return null == r ? t.error("Global state property must be defined.") : "string" != typeof r ? t.error(`Global state property must be string, but found ${typeof e[1]} instead.`) : new rS(r)
            }
            evaluate(e) {
                var t;
                let r = null === (t = e.globals) || void 0 === t ? void 0 : t.globalState;
                return r && 0 !== Object.keys(r).length ? e2(r, this.key) : null
            }
            eachChild() {}
            outputDefined() {
                return !1
            }
        }
        let rk = {
            "==": tq,
            "!=": tD,
            ">": tG,
            "<": tB,
            ">=": tH,
            "<=": tV,
            array: tv,
            at: tE,
            boolean: tv,
            case: tM,
            coalesce: tO,
            collator: tX,
            format: tZ,
            image: tW,
            in: tA,
            "index-of": tL,
            interpolate: tj,
            "interpolate-hcl": tj,
            "interpolate-lab": tj,
            length: tY,
            let: t_,
            literal: ty,
            match: tT,
            number: tv,
            "number-format": tK,
            object: tv,
            slice: tP,
            step: tI,
            string: tv,
            "to-boolean": tx,
            "to-color": tx,
            "to-number": tx,
            "to-string": tx,
            var: tC,
            within: re,
            distance: rw,
            "global-state": rS
        };
        class r_ {
            constructor(e, t, r, a) {
                this.name = e,
                this.type = t,
                this._evaluate = r,
                this.args = a
            }
            evaluate(e) {
                return this._evaluate(e, this.args)
            }
            eachChild(e) {
                this.args.forEach(e)
            }
            outputDefined() {
                return !1
            }
            static parse(e, t) {
                let r = e[0]
                  , a = r_.definitions[r];
                if (!a)
                    return t.error(`Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`, 0);
                let n = Array.isArray(a) ? a[0] : a.type
                  , o = Array.isArray(a) ? [[a[1], a[2]]] : a.overloads
                  , i = o.filter( ([t]) => !Array.isArray(t) || t.length === e.length - 1)
                  , l = null;
                for (let[a,o] of i) {
                    l = new tk(t.registry,rL,t.path,null,t.scope);
                    let i = []
                      , s = !1;
                    for (let t = 1; t < e.length; t++) {
                        let r = e[t]
                          , n = Array.isArray(a) ? a[t - 1] : a.type
                          , o = l.parse(r, 1 + i.length, n);
                        if (!o) {
                            s = !0;
                            break
                        }
                        i.push(o)
                    }
                    if (!s) {
                        if (Array.isArray(a) && a.length !== i.length) {
                            l.error(`Expected ${a.length} arguments, but found ${i.length} instead.`);
                            continue
                        }
                        for (let e = 0; e < i.length; e++) {
                            let t = Array.isArray(a) ? a[e] : a.type
                              , r = i[e];
                            l.concat(e + 1).checkSubtype(t, r.type)
                        }
                        if (0 === l.errors.length)
                            return new r_(r,n,o,i)
                    }
                }
                if (1 === i.length)
                    t.errors.push(...l.errors);
                else {
                    let r = (i.length ? i : o).map( ([e]) => Array.isArray(e) ? `(${e.map(eR).join(", ")})` : `(${eR(e.type)}...)`).join(" | ")
                      , a = [];
                    for (let r = 1; r < e.length; r++) {
                        let n = t.parse(e[r], 1 + a.length);
                        if (!n)
                            return null;
                        a.push(eR(n.type))
                    }
                    t.error(`Expected arguments of type ${r}, but found (${a.join(", ")}) instead.`)
                }
                return null
            }
            static register(e, t) {
                for (let r in r_.definitions = t,
                t)
                    e[r] = r_
            }
        }
        function rC(e, [t,r,a,n]) {
            t = t.evaluate(e),
            r = r.evaluate(e),
            a = a.evaluate(e);
            let o = n ? n.evaluate(e) : 1
              , i = th(t, r, a, o);
            if (i)
                throw new tl(i);
            return new e9(t / 255,r / 255,a / 255,o,!1)
        }
        function rE(e, t) {
            let r = t[e];
            return typeof r > "u" ? null : r
        }
        function rA(e) {
            return {
                type: e
            }
        }
        function rL(e) {
            if (e instanceof tC)
                return rL(e.boundExpression);
            if (e instanceof r_ && "error" === e.name || e instanceof tX || e instanceof re || e instanceof rw || e instanceof rS)
                return !1;
            let t = e instanceof tx || e instanceof tv
              , r = !0;
            return e.eachChild(e => {
                r = t ? r && rL(e) : r && e instanceof ty
            }
            ),
            !!r && rT(e) && rP(e, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"])
        }
        function rT(e) {
            if (e instanceof r_ && ("get" === e.name && 1 === e.args.length || "feature-state" === e.name || "has" === e.name && 1 === e.args.length || "properties" === e.name || "geometry-type" === e.name || "id" === e.name || /^filter-/.test(e.name)) || e instanceof re || e instanceof rw)
                return !1;
            let t = !0;
            return e.eachChild(e => {
                t && !rT(e) && (t = !1)
            }
            ),
            t
        }
        function rM(e) {
            if (e instanceof r_ && "feature-state" === e.name)
                return !1;
            let t = !0;
            return e.eachChild(e => {
                t && !rM(e) && (t = !1)
            }
            ),
            t
        }
        function rP(e, t) {
            if (e instanceof r_ && t.indexOf(e.name) >= 0)
                return !1;
            let r = !0;
            return e.eachChild(e => {
                r && !rP(e, t) && (r = !1)
            }
            ),
            r
        }
        function r$(e) {
            return {
                result: "success",
                value: e
            }
        }
        function rI(e) {
            return {
                result: "error",
                value: e
            }
        }
        function rz(e) {
            return "data-driven" === e["property-type"] || "cross-faded-data-driven" === e["property-type"]
        }
        function rj(e) {
            return !!e.expression && e.expression.parameters.indexOf("zoom") > -1
        }
        function rR(e) {
            return !!e.expression && e.expression.interpolated
        }
        function rO(e) {
            return e instanceof Number ? "number" : e instanceof String ? "string" : e instanceof Boolean ? "boolean" : Array.isArray(e) ? "array" : null === e ? "null" : typeof e
        }
        function rU(e) {
            return "object" == typeof e && null !== e && !Array.isArray(e) && tf(e) === eE
        }
        r_.register(rk, {
            error: [{
                kind: "error"
            }, [eS], (e, [t]) => {
                throw new tl(t.evaluate(e))
            }
            ],
            typeof: [eS, [eA], (e, [t]) => eR(tf(t.evaluate(e)))],
            "to-rgba": [ej(ew, 4), [e_], (e, [t]) => {
                let[r,a,n,o] = t.evaluate(e).rgb;
                return [255 * r, 255 * a, 255 * n, o]
            }
            ],
            rgb: [e_, [ew, ew, ew], rC],
            rgba: [e_, [ew, ew, ew, ew], rC],
            has: {
                type: ek,
                overloads: [[[eS], (e, [t]) => t.evaluate(e)in e.properties()], [[eS, eE], (e, [t,r]) => t.evaluate(e)in r.evaluate(e)]]
            },
            get: {
                type: eA,
                overloads: [[[eS], (e, [t]) => rE(t.evaluate(e), e.properties())], [[eS, eE], (e, [t,r]) => rE(t.evaluate(e), r.evaluate(e))]]
            },
            "feature-state": [eA, [eS], (e, [t]) => rE(t.evaluate(e), e.featureState || {})],
            properties: [eE, [], e => e.properties()],
            "geometry-type": [eS, [], e => e.geometryType()],
            id: [eA, [], e => e.id()],
            zoom: [ew, [], e => e.globals.zoom],
            "heatmap-density": [ew, [], e => e.globals.heatmapDensity || 0],
            elevation: [ew, [], e => e.globals.elevation || 0],
            "line-progress": [ew, [], e => e.globals.lineProgress || 0],
            accumulated: [eA, [], e => void 0 === e.globals.accumulated ? null : e.globals.accumulated],
            "+": [ew, rA(ew), (e, t) => {
                let r = 0;
                for (let a of t)
                    r += a.evaluate(e);
                return r
            }
            ],
            "*": [ew, rA(ew), (e, t) => {
                let r = 1;
                for (let a of t)
                    r *= a.evaluate(e);
                return r
            }
            ],
            "-": {
                type: ew,
                overloads: [[[ew, ew], (e, [t,r]) => t.evaluate(e) - r.evaluate(e)], [[ew], (e, [t]) => -t.evaluate(e)]]
            },
            "/": [ew, [ew, ew], (e, [t,r]) => t.evaluate(e) / r.evaluate(e)],
            "%": [ew, [ew, ew], (e, [t,r]) => t.evaluate(e) % r.evaluate(e)],
            ln2: [ew, [], () => Math.LN2],
            pi: [ew, [], () => Math.PI],
            e: [ew, [], () => Math.E],
            "^": [ew, [ew, ew], (e, [t,r]) => Math.pow(t.evaluate(e), r.evaluate(e))],
            sqrt: [ew, [ew], (e, [t]) => Math.sqrt(t.evaluate(e))],
            log10: [ew, [ew], (e, [t]) => Math.log(t.evaluate(e)) / Math.LN10],
            ln: [ew, [ew], (e, [t]) => Math.log(t.evaluate(e))],
            log2: [ew, [ew], (e, [t]) => Math.log(t.evaluate(e)) / Math.LN2],
            sin: [ew, [ew], (e, [t]) => Math.sin(t.evaluate(e))],
            cos: [ew, [ew], (e, [t]) => Math.cos(t.evaluate(e))],
            tan: [ew, [ew], (e, [t]) => Math.tan(t.evaluate(e))],
            asin: [ew, [ew], (e, [t]) => Math.asin(t.evaluate(e))],
            acos: [ew, [ew], (e, [t]) => Math.acos(t.evaluate(e))],
            atan: [ew, [ew], (e, [t]) => Math.atan(t.evaluate(e))],
            min: [ew, rA(ew), (e, t) => Math.min(...t.map(t => t.evaluate(e)))],
            max: [ew, rA(ew), (e, t) => Math.max(...t.map(t => t.evaluate(e)))],
            abs: [ew, [ew], (e, [t]) => Math.abs(t.evaluate(e))],
            round: [ew, [ew], (e, [t]) => {
                let r = t.evaluate(e);
                return r < 0 ? -Math.round(-r) : Math.round(r)
            }
            ],
            floor: [ew, [ew], (e, [t]) => Math.floor(t.evaluate(e))],
            ceil: [ew, [ew], (e, [t]) => Math.ceil(t.evaluate(e))],
            "filter-==": [ek, [eS, eA], (e, [t,r]) => e.properties()[t.value] === r.value],
            "filter-id-==": [ek, [eA], (e, [t]) => e.id() === t.value],
            "filter-type-==": [ek, [eS], (e, [t]) => e.geometryType() === t.value],
            "filter-<": [ek, [eS, eA], (e, [t,r]) => {
                let a = e.properties()[t.value]
                  , n = r.value;
                return typeof a == typeof n && a < n
            }
            ],
            "filter-id-<": [ek, [eA], (e, [t]) => {
                let r = e.id()
                  , a = t.value;
                return typeof r == typeof a && r < a
            }
            ],
            "filter->": [ek, [eS, eA], (e, [t,r]) => {
                let a = e.properties()[t.value]
                  , n = r.value;
                return typeof a == typeof n && a > n
            }
            ],
            "filter-id->": [ek, [eA], (e, [t]) => {
                let r = e.id()
                  , a = t.value;
                return typeof r == typeof a && r > a
            }
            ],
            "filter-<=": [ek, [eS, eA], (e, [t,r]) => {
                let a = e.properties()[t.value]
                  , n = r.value;
                return typeof a == typeof n && a <= n
            }
            ],
            "filter-id-<=": [ek, [eA], (e, [t]) => {
                let r = e.id()
                  , a = t.value;
                return typeof r == typeof a && r <= a
            }
            ],
            "filter->=": [ek, [eS, eA], (e, [t,r]) => {
                let a = e.properties()[t.value]
                  , n = r.value;
                return typeof a == typeof n && a >= n
            }
            ],
            "filter-id->=": [ek, [eA], (e, [t]) => {
                let r = e.id()
                  , a = t.value;
                return typeof r == typeof a && r >= a
            }
            ],
            "filter-has": [ek, [eA], (e, [t]) => t.value in e.properties()],
            "filter-has-id": [ek, [], e => null !== e.id() && void 0 !== e.id()],
            "filter-type-in": [ek, [ej(eS)], (e, [t]) => t.value.indexOf(e.geometryType()) >= 0],
            "filter-id-in": [ek, [ej(eA)], (e, [t]) => t.value.indexOf(e.id()) >= 0],
            "filter-in-small": [ek, [eS, ej(eA)], (e, [t,r]) => r.value.indexOf(e.properties()[t.value]) >= 0],
            "filter-in-large": [ek, [eS, ej(eA)], (e, [t,r]) => (function(e, t, r, a) {
                for (; r <= a; ) {
                    let n = r + a >> 1;
                    if (t[n] === e)
                        return !0;
                    t[n] > e ? a = n - 1 : r = n + 1
                }
                return !1
            }
            )(e.properties()[t.value], r.value, 0, r.value.length - 1)],
            all: {
                type: ek,
                overloads: [[[ek, ek], (e, [t,r]) => t.evaluate(e) && r.evaluate(e)], [rA(ek), (e, t) => {
                    for (let r of t)
                        if (!r.evaluate(e))
                            return !1;
                    return !0
                }
                ]]
            },
            any: {
                type: ek,
                overloads: [[[ek, ek], (e, [t,r]) => t.evaluate(e) || r.evaluate(e)], [rA(ek), (e, t) => {
                    for (let r of t)
                        if (r.evaluate(e))
                            return !0;
                    return !1
                }
                ]]
            },
            "!": [ek, [ek], (e, [t]) => !t.evaluate(e)],
            "is-supported-script": [ek, [eS], (e, [t]) => {
                let r = e.globals && e.globals.isSupportedScript;
                return !r || r(t.evaluate(e))
            }
            ],
            upcase: [eS, [eS], (e, [t]) => t.evaluate(e).toUpperCase()],
            downcase: [eS, [eS], (e, [t]) => t.evaluate(e).toLowerCase()],
            concat: [eS, rA(eA), (e, t) => t.map(t => tm(t.evaluate(e))).join("")],
            "resolved-locale": [eS, [eL], (e, [t]) => t.evaluate(e).resolvedLocale()]
        });
        class rN {
            constructor(e, t) {
                this.expression = e,
                this._warningHistory = {},
                this._evaluator = new tS,
                this._defaultValue = t ? function(e) {
                    if ("color" === e.type && rU(e.default))
                        return new e9(0,0,0,0);
                    switch (e.type) {
                    case "color":
                        return e9.parse(e.default) || null;
                    case "padding":
                        return tn.parse(e.default) || null;
                    case "numberArray":
                        return to.parse(e.default) || null;
                    case "colorArray":
                        return ti.parse(e.default) || null;
                    case "variableAnchorOffsetCollection":
                        return tu.parse(e.default) || null;
                    case "projectionDefinition":
                        return tc.parse(e.default) || null;
                    default:
                        return void 0 === e.default ? null : e.default
                    }
                }(t) : null,
                this._enumValues = t && "enum" === t.type ? t.values : null
            }
            evaluateWithoutErrorHandling(e, t, r, a, n, o) {
                return this._evaluator.globals = e,
                this._evaluator.feature = t,
                this._evaluator.featureState = r,
                this._evaluator.canonical = a,
                this._evaluator.availableImages = n || null,
                this._evaluator.formattedSection = o,
                this.expression.evaluate(this._evaluator)
            }
            evaluate(e, t, r, a, n, o) {
                this._evaluator.globals = e,
                this._evaluator.feature = t || null,
                this._evaluator.featureState = r || null,
                this._evaluator.canonical = a,
                this._evaluator.availableImages = n || null,
                this._evaluator.formattedSection = o || null;
                try {
                    let e = this.expression.evaluate(this._evaluator);
                    if (null == e || "number" == typeof e && e != e)
                        return this._defaultValue;
                    if (this._enumValues && !(e in this._enumValues))
                        throw new tl(`Expected value to be one of ${Object.keys(this._enumValues).map(e => JSON.stringify(e)).join(", ")}, but found ${JSON.stringify(e)} instead.`);
                    return e
                } catch (e) {
                    return this._warningHistory[e.message] || (this._warningHistory[e.message] = !0,
                    "u" > typeof console && console.warn(e.message)),
                    this._defaultValue
                }
            }
        }
        function rF(e) {
            return Array.isArray(e) && e.length > 0 && "string" == typeof e[0] && e[0]in rk
        }
        function rq(e, t) {
            let r = new tk(rk,rL,[],t ? function(e) {
                let t = {
                    color: e_,
                    string: eS,
                    number: ew,
                    enum: eS,
                    boolean: ek,
                    formatted: eT,
                    padding: eM,
                    numberArray: e$,
                    colorArray: eP,
                    projectionDefinition: eC,
                    resolvedImage: eI,
                    variableAnchorOffsetCollection: ez
                };
                return "array" === e.type ? ej(t[e.value] || eA, e.length) : t[e.type]
            }(t) : void 0)
              , a = r.parse(e, void 0, void 0, void 0, t && "string" === t.type ? {
                typeAnnotation: "coerce"
            } : void 0);
            return a ? r$(new rN(a,t)) : rI(r.errors)
        }
        class rD {
            constructor(e, t) {
                this.kind = e,
                this._styleExpression = t,
                this.isStateDependent = "constant" !== e && !rM(t.expression),
                this.globalStateRefs = rG(t.expression)
            }
            evaluateWithoutErrorHandling(e, t, r, a, n, o) {
                return this._styleExpression.evaluateWithoutErrorHandling(e, t, r, a, n, o)
            }
            evaluate(e, t, r, a, n, o) {
                return this._styleExpression.evaluate(e, t, r, a, n, o)
            }
        }
        class rB {
            constructor(e, t, r, a) {
                this.kind = e,
                this.zoomStops = r,
                this._styleExpression = t,
                this.isStateDependent = "camera" !== e && !rM(t.expression),
                this.globalStateRefs = rG(t.expression),
                this.interpolationType = a
            }
            evaluateWithoutErrorHandling(e, t, r, a, n, o) {
                return this._styleExpression.evaluateWithoutErrorHandling(e, t, r, a, n, o)
            }
            evaluate(e, t, r, a, n, o) {
                return this._styleExpression.evaluate(e, t, r, a, n, o)
            }
            interpolationFactor(e, t, r) {
                return this.interpolationType ? tj.interpolationFactor(this.interpolationType, e, t, r) : 0
            }
        }
        function rG(e, t=new Set) {
            return e instanceof rS && t.add(e.key),
            e.eachChild(e => {
                rG(e, t)
            }
            ),
            t
        }
        function rV(e) {
            let t = e.key
              , r = e.value;
            return r ? [new ey(t,r,"constants have been deprecated as of v8")] : []
        }
        function rH(e) {
            return e instanceof Number || e instanceof String || e instanceof Boolean ? e.valueOf() : e
        }
        function rX(e) {
            if (Array.isArray(e))
                return e.map(rX);
            if (e instanceof Object && !(e instanceof Number || e instanceof String || e instanceof Boolean)) {
                let t = {};
                for (let r in e)
                    t[r] = rX(e[r]);
                return t
            }
            return rH(e)
        }
        function rK(e) {
            let t = e.key
              , r = e.value
              , a = e.valueSpec || {}
              , n = e.objectElementValidators || {}
              , o = e.style
              , i = e.styleSpec
              , l = e.validateSpec
              , s = []
              , u = rO(r);
            if ("object" !== u)
                return [new ey(t,r,`object expected, ${u} found`)];
            for (let e in r) {
                let u;
                let p = e.split(".")[0]
                  , c = e2(a, p) || a["*"];
                if (e2(n, p))
                    u = n[p];
                else if (e2(a, p))
                    u = l;
                else if (n["*"])
                    u = n["*"];
                else if (a["*"])
                    u = l;
                else {
                    s.push(new ey(t,r[e],`unknown property "${e}"`));
                    continue
                }
                s = s.concat(u({
                    key: (t && `${t}.`) + e,
                    value: r[e],
                    valueSpec: c,
                    style: o,
                    styleSpec: i,
                    object: r,
                    objectKey: e,
                    validateSpec: l
                }, r))
            }
            for (let e in a)
                n[e] || a[e].required && void 0 === a[e].default && void 0 === r[e] && s.push(new ey(t,r,`missing required property "${e}"`));
            return s
        }
        function rZ(e) {
            let t = e.value
              , r = e.valueSpec
              , a = e.validateSpec
              , n = e.style
              , o = e.styleSpec
              , i = e.key
              , l = e.arrayElementValidator || a;
            if ("array" !== rO(t))
                return [new ey(i,t,`array expected, ${rO(t)} found`)];
            if (r.length && t.length !== r.length)
                return [new ey(i,t,`array length ${r.length} expected, length ${t.length} found`)];
            if (r["min-length"] && t.length < r["min-length"])
                return [new ey(i,t,`array length at least ${r["min-length"]} expected, length ${t.length} found`)];
            let s = {
                type: r.value,
                values: r.values
            };
            o.$version < 7 && (s.function = r.function),
            "object" === rO(r.value) && (s = r.value);
            let u = [];
            for (let r = 0; r < t.length; r++)
                u = u.concat(l({
                    array: t,
                    arrayIndex: r,
                    value: t[r],
                    valueSpec: s,
                    validateSpec: e.validateSpec,
                    style: n,
                    styleSpec: o,
                    key: `${i}[${r}]`
                }));
            return u
        }
        function rW(e) {
            let t = e.key
              , r = e.value
              , a = e.valueSpec
              , n = rO(r);
            return "number" === n && r != r && (n = "NaN"),
            "number" !== n ? [new ey(t,r,`number expected, ${n} found`)] : "minimum"in a && r < a.minimum ? [new ey(t,r,`${r} is less than the minimum value ${a.minimum}`)] : "maximum"in a && r > a.maximum ? [new ey(t,r,`${r} is greater than the maximum value ${a.maximum}`)] : []
        }
        function rY(e) {
            let t = e.valueSpec, r = rH(e.value.type), a, n = {}, o, i, l = "categorical" !== r && void 0 === e.value.property, s = "array" === rO(e.value.stops) && "array" === rO(e.value.stops[0]) && "object" === rO(e.value.stops[0][0]), u = rK({
                key: e.key,
                value: e.value,
                valueSpec: e.styleSpec.function,
                validateSpec: e.validateSpec,
                style: e.style,
                styleSpec: e.styleSpec,
                objectElementValidators: {
                    stops: function(e) {
                        if ("identity" === r)
                            return [new ey(e.key,e.value,'identity function may not have a "stops" property')];
                        let t = []
                          , a = e.value;
                        return t = t.concat(rZ({
                            key: e.key,
                            value: a,
                            valueSpec: e.valueSpec,
                            validateSpec: e.validateSpec,
                            style: e.style,
                            styleSpec: e.styleSpec,
                            arrayElementValidator: p
                        })),
                        "array" === rO(a) && 0 === a.length && t.push(new ey(e.key,a,"array must have at least one stop")),
                        t
                    },
                    default: function(e) {
                        return e.validateSpec({
                            key: e.key,
                            value: e.value,
                            valueSpec: t,
                            validateSpec: e.validateSpec,
                            style: e.style,
                            styleSpec: e.styleSpec
                        })
                    }
                }
            });
            return "identity" === r && l && u.push(new ey(e.key,e.value,'missing required property "property"')),
            "identity" === r || e.value.stops || u.push(new ey(e.key,e.value,'missing required property "stops"')),
            "exponential" === r && e.valueSpec.expression && !rR(e.valueSpec) && u.push(new ey(e.key,e.value,"exponential functions not supported")),
            e.styleSpec.$version >= 8 && (l || rz(e.valueSpec) ? l && !rj(e.valueSpec) && u.push(new ey(e.key,e.value,"zoom functions not supported")) : u.push(new ey(e.key,e.value,"property functions not supported"))),
            ("categorical" === r || s) && void 0 === e.value.property && u.push(new ey(e.key,e.value,'"property" property is required')),
            u;
            function p(e) {
                let r = []
                  , a = e.value
                  , l = e.key;
                if ("array" !== rO(a))
                    return [new ey(l,a,`array expected, ${rO(a)} found`)];
                if (2 !== a.length)
                    return [new ey(l,a,`array length 2 expected, length ${a.length} found`)];
                if (s) {
                    if ("object" !== rO(a[0]))
                        return [new ey(l,a,`object expected, ${rO(a[0])} found`)];
                    if (void 0 === a[0].zoom)
                        return [new ey(l,a,"object stop key must have zoom")];
                    if (void 0 === a[0].value)
                        return [new ey(l,a,"object stop key must have value")];
                    if (i && i > rH(a[0].zoom))
                        return [new ey(l,a[0].zoom,"stop zoom values must appear in ascending order")];
                    rH(a[0].zoom) !== i && (i = rH(a[0].zoom),
                    o = void 0,
                    n = {}),
                    r = r.concat(rK({
                        key: `${l}[0]`,
                        value: a[0],
                        valueSpec: {
                            zoom: {}
                        },
                        validateSpec: e.validateSpec,
                        style: e.style,
                        styleSpec: e.styleSpec,
                        objectElementValidators: {
                            zoom: rW,
                            value: c
                        }
                    }))
                } else
                    r = r.concat(c({
                        key: `${l}[0]`,
                        value: a[0],
                        validateSpec: e.validateSpec,
                        style: e.style,
                        styleSpec: e.styleSpec
                    }, a));
                return rF(rX(a[1])) ? r.concat([new ey(`${l}[1]`,a[1],"expressions are not allowed in function stops.")]) : r.concat(e.validateSpec({
                    key: `${l}[1]`,
                    value: a[1],
                    valueSpec: t,
                    validateSpec: e.validateSpec,
                    style: e.style,
                    styleSpec: e.styleSpec
                }))
            }
            function c(e, i) {
                let l = rO(e.value)
                  , s = rH(e.value)
                  , u = null !== e.value ? e.value : i;
                if (a) {
                    if (l !== a)
                        return [new ey(e.key,u,`${l} stop domain type must match previous stop domain type ${a}`)]
                } else
                    a = l;
                if ("number" !== l && "string" !== l && "boolean" !== l)
                    return [new ey(e.key,u,"stop domain value must be a number, string, or boolean")];
                if ("number" !== l && "categorical" !== r) {
                    let a = `number expected, ${l} found`;
                    return rz(t) && void 0 === r && (a += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),
                    [new ey(e.key,u,a)]
                }
                return "categorical" !== r || "number" !== l || isFinite(s) && Math.floor(s) === s ? "categorical" !== r && "number" === l && void 0 !== o && s < o ? [new ey(e.key,u,"stop domain values must appear in ascending order")] : (o = s,
                "categorical" === r && s in n ? [new ey(e.key,u,"stop domain values must be unique")] : (n[s] = !0,
                [])) : [new ey(e.key,u,`integer expected, found ${s}`)]
            }
        }
        function rJ(e) {
            let t = ("property" === e.expressionContext ? function(e, t) {
                let r = rq(e, t);
                if ("error" === r.result)
                    return r;
                let a = r.value.expression
                  , n = rT(a);
                if (!n && !rz(t))
                    return rI([new ev("","data expressions not supported")]);
                let o = rP(a, ["zoom"]);
                if (!o && !rj(t))
                    return rI([new ev("","zoom expressions not supported")]);
                let i = function e(t) {
                    let r = null;
                    if (t instanceof t_)
                        r = e(t.result);
                    else if (t instanceof tO) {
                        for (let a of t.args)
                            if (r = e(a))
                                break
                    } else
                        (t instanceof tI || t instanceof tj) && t.input instanceof r_ && "zoom" === t.input.name && (r = t);
                    return r instanceof ev || t.eachChild(t => {
                        let a = e(t);
                        a instanceof ev ? r = a : !r && a ? r = new ev("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : r && a && r !== a && (r = new ev("",'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))
                    }
                    ),
                    r
                }(a);
                if (!i && !o)
                    return rI([new ev("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
                if (i instanceof ev)
                    return rI([i]);
                if (i instanceof tj && !rR(t))
                    return rI([new ev("",'"interpolate" expressions cannot be used with this property')]);
                if (!i)
                    return r$(n ? new rD("constant",r.value) : new rD("source",r.value));
                let l = i instanceof tj ? i.interpolation : void 0;
                return r$(n ? new rB("camera",r.value,i.labels,l) : new rB("composite",r.value,i.labels,l))
            }
            : rq)(rX(e.value), e.valueSpec);
            if ("error" === t.result)
                return t.value.map(t => new ey(`${e.key}${t.key}`,e.value,t.message));
            let r = t.value.expression || t.value._styleExpression.expression;
            if ("property" === e.expressionContext && "text-font" === e.propertyKey && !r.outputDefined())
                return [new ey(e.key,e.value,`Invalid data expression for "${e.propertyKey}". Output values must be contained as literals within the expression.`)];
            if ("property" === e.expressionContext && "layout" === e.propertyType && !rM(r))
                return [new ey(e.key,e.value,'"feature-state" data expressions are not supported with layout properties.')];
            if ("filter" === e.expressionContext && !rM(r))
                return [new ey(e.key,e.value,'"feature-state" data expressions are not supported with filters.')];
            if (e.expressionContext && 0 === e.expressionContext.indexOf("cluster")) {
                if (!rP(r, ["zoom", "feature-state"]))
                    return [new ey(e.key,e.value,'"zoom" and "feature-state" expressions are not supported with cluster properties.')];
                if ("cluster-initial" === e.expressionContext && !rT(r))
                    return [new ey(e.key,e.value,"Feature data expressions are not supported with initial expression part of cluster properties.")]
            }
            return []
        }
        function rQ(e) {
            let t = e.key
              , r = e.value
              , a = rO(r);
            return "string" !== a ? [new ey(t,r,`color expected, ${a} found`)] : e9.parse(String(r)) ? [] : [new ey(t,r,`color expected, "${r}" found`)]
        }
        function r0(e) {
            let t = e.key
              , r = e.value
              , a = e.valueSpec
              , n = [];
            return Array.isArray(a.values) ? -1 === a.values.indexOf(rH(r)) && n.push(new ey(t,r,`expected one of [${a.values.join(", ")}], ${JSON.stringify(r)} found`)) : -1 === Object.keys(a.values).indexOf(rH(r)) && n.push(new ey(t,r,`expected one of [${Object.keys(a.values).join(", ")}], ${JSON.stringify(r)} found`)),
            n
        }
        function r1(e) {
            return !function e(t) {
                if (!0 === t || !1 === t)
                    return !0;
                if (!Array.isArray(t) || 0 === t.length)
                    return !1;
                switch (t[0]) {
                case "has":
                    return t.length >= 2 && "$id" !== t[1] && "$type" !== t[1];
                case "in":
                    return t.length >= 3 && ("string" != typeof t[1] || Array.isArray(t[2]));
                case "!in":
                case "!has":
                case "none":
                    return !1;
                case "==":
                case "!=":
                case ">":
                case ">=":
                case "<":
                case "<=":
                    return 3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2]);
                case "any":
                case "all":
                    for (let r of t.slice(1))
                        if (!e(r) && "boolean" != typeof r)
                            return !1;
                    return !0;
                default:
                    return !0
                }
            }(rX(e.value)) ? function e(t) {
                let r = t.value
                  , a = t.key;
                if ("array" !== rO(r))
                    return [new ey(a,r,`array expected, ${rO(r)} found`)];
                let n = t.styleSpec, o, i = [];
                if (r.length < 1)
                    return [new ey(a,r,"filter array must have at least 1 element")];
                switch (i = i.concat(r0({
                    key: `${a}[0]`,
                    value: r[0],
                    valueSpec: n.filter_operator,
                    style: t.style,
                    styleSpec: t.styleSpec
                })),
                rH(r[0])) {
                case "<":
                case "<=":
                case ">":
                case ">=":
                    r.length >= 2 && "$type" === rH(r[1]) && i.push(new ey(a,r,`"$type" cannot be use with operator "${r[0]}"`));
                case "==":
                case "!=":
                    3 !== r.length && i.push(new ey(a,r,`filter array for operator "${r[0]}" must have 3 elements`));
                case "in":
                case "!in":
                    r.length >= 2 && "string" !== (o = rO(r[1])) && i.push(new ey(`${a}[1]`,r[1],`string expected, ${o} found`));
                    for (let e = 2; e < r.length; e++)
                        o = rO(r[e]),
                        "$type" === rH(r[1]) ? i = i.concat(r0({
                            key: `${a}[${e}]`,
                            value: r[e],
                            valueSpec: n.geometry_type,
                            style: t.style,
                            styleSpec: t.styleSpec
                        })) : "string" !== o && "number" !== o && "boolean" !== o && i.push(new ey(`${a}[${e}]`,r[e],`string, number, or boolean expected, ${o} found`));
                    break;
                case "any":
                case "all":
                case "none":
                    for (let n = 1; n < r.length; n++)
                        i = i.concat(e({
                            key: `${a}[${n}]`,
                            value: r[n],
                            style: t.style,
                            styleSpec: t.styleSpec
                        }));
                    break;
                case "has":
                case "!has":
                    o = rO(r[1]),
                    2 !== r.length ? i.push(new ey(a,r,`filter array for "${r[0]}" operator must have 2 elements`)) : "string" !== o && i.push(new ey(`${a}[1]`,r[1],`string expected, ${o} found`))
                }
                return i
            }(e) : rJ(eg({}, e, {
                expressionContext: "filter",
                valueSpec: {
                    value: "boolean"
                }
            }))
        }
        function r2(e, t) {
            let r;
            let a = e.key
              , n = e.validateSpec
              , o = e.style
              , i = e.styleSpec
              , l = e.value
              , s = e.objectKey
              , u = i[`${t}_${e.layerType}`];
            if (!u)
                return [];
            let p = s.match(/^(.*)-transition$/);
            if ("paint" === t && p && u[p[1]] && u[p[1]].transition)
                return n({
                    key: a,
                    value: l,
                    valueSpec: i.transition,
                    style: o,
                    styleSpec: i
                });
            let c = e.valueSpec || u[s];
            if (!c)
                return [new ey(a,l,`unknown property "${s}"`)];
            if ("string" === rO(l) && rz(c) && !c.tokens && (r = /^{([^}]+)}$/.exec(l)))
                return [new ey(a,l,`"${s}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(r[1])} }\`.`)];
            let h = [];
            return "symbol" === e.layerType && ("text-field" === s && o && !o.glyphs && h.push(new ey(a,l,'use of "text-field" requires a style "glyphs" property')),
            "text-font" === s && rU(rX(l)) && "identity" === rH(l.type) && h.push(new ey(a,l,'"text-font" does not support identity functions'))),
            h.concat(n({
                key: e.key,
                value: l,
                valueSpec: c,
                style: o,
                styleSpec: i,
                expressionContext: "property",
                propertyType: t,
                propertyKey: s
            }))
        }
        function r5(e) {
            return r2(e, "paint")
        }
        function r3(e) {
            return r2(e, "layout")
        }
        function r4(e) {
            let t = []
              , r = e.value
              , a = e.key
              , n = e.style
              , o = e.styleSpec;
            if ("object" !== rO(r))
                return [new ey(a,r,`object expected, ${rO(r)} found`)];
            r.type || r.ref || t.push(new ey(a,r,'either "type" or "ref" is required'));
            let i = rH(r.type)
              , l = rH(r.ref);
            if (r.id) {
                let o = rH(r.id);
                for (let i = 0; i < e.arrayIndex; i++) {
                    let e = n.layers[i];
                    rH(e.id) === o && t.push(new ey(a,r.id,`duplicate layer id "${r.id}", previously used at line ${e.id.__line__}`))
                }
            }
            if ("ref"in r) {
                let e;
                ["type", "source", "source-layer", "filter", "layout"].forEach(e => {
                    e in r && t.push(new ey(a,r[e],`"${e}" is prohibited for ref layers`))
                }
                ),
                n.layers.forEach(t => {
                    rH(t.id) === l && (e = t)
                }
                ),
                e ? e.ref ? t.push(new ey(a,r.ref,"ref cannot reference another ref layer")) : i = rH(e.type) : t.push(new ey(a,r.ref,`ref layer "${l}" not found`))
            } else if ("background" !== i) {
                if (r.source) {
                    let e = n.sources && n.sources[r.source]
                      , o = e && rH(e.type);
                    e ? "vector" === o && "raster" === i ? t.push(new ey(a,r.source,`layer "${r.id}" requires a raster source`)) : "raster-dem" !== o && "hillshade" === i ? t.push(new ey(a,r.source,`layer "${r.id}" requires a raster-dem source`)) : "raster-dem" !== o && "color-relief" === i ? t.push(new ey(a,r.source,`layer "${r.id}" requires a raster-dem source`)) : "raster" === o && "raster" !== i ? t.push(new ey(a,r.source,`layer "${r.id}" requires a vector source`)) : "vector" !== o || r["source-layer"] ? "raster-dem" === o && "hillshade" !== i && "color-relief" !== i ? t.push(new ey(a,r.source,"raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : "line" === i && r.paint && r.paint["line-gradient"] && ("geojson" !== o || !e.lineMetrics) && t.push(new ey(a,r,`layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new ey(a,r,`layer "${r.id}" must specify a "source-layer"`)) : t.push(new ey(a,r.source,`source "${r.source}" not found`))
                } else
                    t.push(new ey(a,r,'missing required property "source"'))
            }
            return t = t.concat(rK({
                key: a,
                value: r,
                valueSpec: o.layer,
                style: e.style,
                styleSpec: e.styleSpec,
                validateSpec: e.validateSpec,
                objectElementValidators: {
                    "*": () => [],
                    type: () => e.validateSpec({
                        key: `${a}.type`,
                        value: r.type,
                        valueSpec: o.layer.type,
                        style: e.style,
                        styleSpec: e.styleSpec,
                        validateSpec: e.validateSpec,
                        object: r,
                        objectKey: "type"
                    }),
                    filter: r1,
                    layout: e => rK({
                        layer: r,
                        key: e.key,
                        value: e.value,
                        style: e.style,
                        styleSpec: e.styleSpec,
                        validateSpec: e.validateSpec,
                        objectElementValidators: {
                            "*": e => r3(eg({
                                layerType: i
                            }, e))
                        }
                    }),
                    paint: e => rK({
                        layer: r,
                        key: e.key,
                        value: e.value,
                        style: e.style,
                        styleSpec: e.styleSpec,
                        validateSpec: e.validateSpec,
                        objectElementValidators: {
                            "*": e => r5(eg({
                                layerType: i
                            }, e))
                        }
                    })
                }
            }))
        }
        function r8(e) {
            let t = e.value
              , r = e.key
              , a = rO(t);
            return "string" !== a ? [new ey(r,t,`string expected, ${a} found`)] : []
        }
        let r6 = {
            promoteId: function({key: e, value: t}) {
                if ("string" === rO(t))
                    return r8({
                        key: e,
                        value: t
                    });
                {
                    let r = [];
                    for (let a in t)
                        r.push(...r8({
                            key: `${e}.${a}`,
                            value: t[a]
                        }));
                    return r
                }
            }
        };
        function r7(e) {
            let t;
            let r = e.value
              , a = e.key
              , n = e.styleSpec
              , o = e.style
              , i = e.validateSpec;
            if (!r.type)
                return [new ey(a,r,'"type" is required')];
            let l = rH(r.type);
            switch (l) {
            case "vector":
            case "raster":
                return rK({
                    key: a,
                    value: r,
                    valueSpec: n[`source_${l.replace("-", "_")}`],
                    style: e.style,
                    styleSpec: n,
                    objectElementValidators: r6,
                    validateSpec: i
                });
            case "raster-dem":
                return function(e) {
                    var t;
                    let r = null !== (t = e.sourceName) && void 0 !== t ? t : ""
                      , a = e.value
                      , n = e.styleSpec
                      , o = n.source_raster_dem
                      , i = e.style
                      , l = []
                      , s = rO(a);
                    if (void 0 === a)
                        return l;
                    if ("object" !== s)
                        return l.push(new ey("source_raster_dem",a,`object expected, ${s} found`)),
                        l;
                    let u = "custom" === rH(a.encoding)
                      , p = ["redFactor", "greenFactor", "blueFactor", "baseShift"]
                      , c = e.value.encoding ? `"${e.value.encoding}"` : "Default";
                    for (let t in a)
                        !u && p.includes(t) ? l.push(new ey(t,a[t],`In "${r}": "${t}" is only valid when "encoding" is set to "custom". ${c} encoding found`)) : o[t] ? l = l.concat(e.validateSpec({
                            key: t,
                            value: a[t],
                            valueSpec: o[t],
                            validateSpec: e.validateSpec,
                            style: i,
                            styleSpec: n
                        })) : l.push(new ey(t,a[t],`unknown property "${t}"`));
                    return l
                }({
                    sourceName: a,
                    value: r,
                    style: e.style,
                    styleSpec: n,
                    validateSpec: i
                });
            case "geojson":
                if (t = rK({
                    key: a,
                    value: r,
                    valueSpec: n.source_geojson,
                    style: o,
                    styleSpec: n,
                    validateSpec: i,
                    objectElementValidators: r6
                }),
                r.cluster)
                    for (let e in r.clusterProperties) {
                        let[n,o] = r.clusterProperties[e]
                          , i = "string" == typeof n ? [n, ["accumulated"], ["get", e]] : n;
                        t.push(...rJ({
                            key: `${a}.${e}.map`,
                            value: o,
                            expressionContext: "cluster-map"
                        })),
                        t.push(...rJ({
                            key: `${a}.${e}.reduce`,
                            value: i,
                            expressionContext: "cluster-reduce"
                        }))
                    }
                return t;
            case "video":
                return rK({
                    key: a,
                    value: r,
                    valueSpec: n.source_video,
                    style: o,
                    validateSpec: i,
                    styleSpec: n
                });
            case "image":
                return rK({
                    key: a,
                    value: r,
                    valueSpec: n.source_image,
                    style: o,
                    validateSpec: i,
                    styleSpec: n
                });
            case "canvas":
                return [new ey(a,null,"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.","source.canvas")];
            default:
                return r0({
                    key: `${a}.type`,
                    value: r.type,
                    valueSpec: {
                        values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]
                    }
                })
            }
        }
        function r9(e) {
            let t = e.value
              , r = e.styleSpec
              , a = r.light
              , n = e.style
              , o = []
              , i = rO(t);
            if (void 0 === t)
                return o;
            if ("object" !== i)
                return o.concat([new ey("light",t,`object expected, ${i} found`)]);
            for (let i in t) {
                let l = i.match(/^(.*)-transition$/);
                o = l && a[l[1]] && a[l[1]].transition ? o.concat(e.validateSpec({
                    key: i,
                    value: t[i],
                    valueSpec: r.transition,
                    validateSpec: e.validateSpec,
                    style: n,
                    styleSpec: r
                })) : a[i] ? o.concat(e.validateSpec({
                    key: i,
                    value: t[i],
                    valueSpec: a[i],
                    validateSpec: e.validateSpec,
                    style: n,
                    styleSpec: r
                })) : o.concat([new ey(i,t[i],`unknown property "${i}"`)])
            }
            return o
        }
        function ae(e) {
            let t = e.value
              , r = e.styleSpec
              , a = r.sky
              , n = e.style
              , o = rO(t);
            if (void 0 === t)
                return [];
            if ("object" !== o)
                return [new ey("sky",t,`object expected, ${o} found`)];
            let i = [];
            for (let o in t)
                i = a[o] ? i.concat(e.validateSpec({
                    key: o,
                    value: t[o],
                    valueSpec: a[o],
                    style: n,
                    styleSpec: r
                })) : i.concat([new ey(o,t[o],`unknown property "${o}"`)]);
            return i
        }
        function at(e) {
            let t = e.value
              , r = e.styleSpec
              , a = r.terrain
              , n = e.style
              , o = []
              , i = rO(t);
            if (void 0 === t)
                return o;
            if ("object" !== i)
                return o.concat([new ey("terrain",t,`object expected, ${i} found`)]);
            for (let i in t)
                o = a[i] ? o.concat(e.validateSpec({
                    key: i,
                    value: t[i],
                    valueSpec: a[i],
                    validateSpec: e.validateSpec,
                    style: n,
                    styleSpec: r
                })) : o.concat([new ey(i,t[i],`unknown property "${i}"`)]);
            return o
        }
        function ar(e) {
            let t = []
              , r = e.value
              , a = e.key;
            if (!Array.isArray(r))
                return r8({
                    key: a,
                    value: r
                });
            {
                let n = []
                  , o = [];
                for (let i in r) {
                    r[i].id && n.includes(r[i].id) && t.push(new ey(a,r,`all the sprites' ids must be unique, but ${r[i].id} is duplicated`)),
                    n.push(r[i].id),
                    r[i].url && o.includes(r[i].url) && t.push(new ey(a,r,`all the sprites' URLs must be unique, but ${r[i].url} is duplicated`)),
                    o.push(r[i].url);
                    let l = {
                        id: {
                            type: "string",
                            required: !0
                        },
                        url: {
                            type: "string",
                            required: !0
                        }
                    };
                    t = t.concat(rK({
                        key: `${a}[${i}]`,
                        value: r[i],
                        valueSpec: l,
                        validateSpec: e.validateSpec
                    }))
                }
                return t
            }
        }
        function aa(e) {
            var t;
            return (t = e.value) && t.constructor === Object ? [] : [new ey(e.key,e.value,`object expected, ${rO(e.value)} found`)]
        }
        let an = {
            "*": () => [],
            array: rZ,
            boolean: function(e) {
                let t = e.value
                  , r = e.key
                  , a = rO(t);
                return "boolean" !== a ? [new ey(r,t,`boolean expected, ${a} found`)] : []
            },
            number: rW,
            color: rQ,
            constants: rV,
            enum: r0,
            filter: r1,
            function: rY,
            layer: r4,
            object: rK,
            source: r7,
            light: r9,
            sky: ae,
            terrain: at,
            projection: function(e) {
                let t = e.value
                  , r = e.styleSpec
                  , a = r.projection
                  , n = e.style
                  , o = rO(t);
                if (void 0 === t)
                    return [];
                if ("object" !== o)
                    return [new ey("projection",t,`object expected, ${o} found`)];
                let i = [];
                for (let o in t)
                    i = a[o] ? i.concat(e.validateSpec({
                        key: o,
                        value: t[o],
                        valueSpec: a[o],
                        style: n,
                        styleSpec: r
                    })) : i.concat([new ey(o,t[o],`unknown property "${o}"`)]);
                return i
            },
            projectionDefinition: function(e) {
                var t;
                let r = e.key
                  , a = e.value
                  , n = rO(a = a instanceof String ? a.valueOf() : a);
                return "array" !== n || Array.isArray(t = a) && 3 === t.length && "string" == typeof t[0] && "string" == typeof t[1] && "number" == typeof t[2] || ["interpolate", "step", "literal"].includes(a[0]) ? ["array", "string"].includes(n) ? [] : [new ey(r,a,`projection expected, invalid type "${n}" found`)] : [new ey(r,a,`projection expected, invalid array ${JSON.stringify(a)} found`)]
            },
            string: r8,
            formatted: function(e) {
                return 0 === r8(e).length ? [] : rJ(e)
            },
            resolvedImage: function(e) {
                return 0 === r8(e).length ? [] : rJ(e)
            },
            padding: function(e) {
                let t = e.key
                  , r = e.value;
                if ("array" !== rO(r))
                    return rW({
                        key: t,
                        value: r,
                        valueSpec: {}
                    });
                {
                    if (r.length < 1 || r.length > 4)
                        return [new ey(t,r,`padding requires 1 to 4 values; ${r.length} values found`)];
                    let a = {
                        type: "number"
                    }
                      , n = [];
                    for (let o = 0; o < r.length; o++)
                        n = n.concat(e.validateSpec({
                            key: `${t}[${o}]`,
                            value: r[o],
                            validateSpec: e.validateSpec,
                            valueSpec: a
                        }));
                    return n
                }
            },
            numberArray: function(e) {
                let t = e.key
                  , r = e.value;
                if ("array" !== rO(r))
                    return rW({
                        key: t,
                        value: r,
                        valueSpec: {}
                    });
                {
                    let a = {
                        type: "number"
                    };
                    if (r.length < 1)
                        return [new ey(t,r,"array length at least 1 expected, length 0 found")];
                    let n = [];
                    for (let o = 0; o < r.length; o++)
                        n = n.concat(e.validateSpec({
                            key: `${t}[${o}]`,
                            value: r[o],
                            validateSpec: e.validateSpec,
                            valueSpec: a
                        }));
                    return n
                }
            },
            colorArray: function(e) {
                let t = e.key
                  , r = e.value;
                if ("array" !== rO(r))
                    return rQ({
                        key: t,
                        value: r
                    });
                {
                    if (r.length < 1)
                        return [new ey(t,r,"array length at least 1 expected, length 0 found")];
                    let e = [];
                    for (let a = 0; a < r.length; a++)
                        e = e.concat(rQ({
                            key: `${t}[${a}]`,
                            value: r[a]
                        }));
                    return e
                }
            },
            variableAnchorOffsetCollection: function(e) {
                let t = e.key
                  , r = e.value
                  , a = rO(r)
                  , n = e.styleSpec;
                if ("array" !== a || r.length < 1 || r.length % 2 != 0)
                    return [new ey(t,r,"variableAnchorOffsetCollection requires a non-empty array of even length")];
                let o = [];
                for (let a = 0; a < r.length; a += 2)
                    o = (o = o.concat(r0({
                        key: `${t}[${a}]`,
                        value: r[a],
                        valueSpec: n.layout_symbol["text-anchor"]
                    }))).concat(rZ({
                        key: `${t}[${a + 1}]`,
                        value: r[a + 1],
                        valueSpec: {
                            length: 2,
                            value: "number"
                        },
                        validateSpec: e.validateSpec,
                        style: e.style,
                        styleSpec: n
                    }));
                return o
            },
            sprite: ar,
            state: aa
        };
        function ao(e) {
            let t = e.value
              , r = e.valueSpec
              , a = e.styleSpec;
            return e.validateSpec = ao,
            r.expression && rU(rH(t)) ? rY(e) : r.expression && rF(rX(t)) ? rJ(e) : r.type && an[r.type] ? an[r.type](e) : rK(eg({}, e, {
                valueSpec: r.type ? a[r.type] : r
            }))
        }
        function ai(e) {
            let t = e.value
              , r = e.key
              , a = r8(e);
            return a.length || (-1 === t.indexOf("{fontstack}") && a.push(new ey(r,t,'"glyphs" url must include a "{fontstack}" token')),
            -1 === t.indexOf("{range}") && a.push(new ey(r,t,'"glyphs" url must include a "{range}" token'))),
            a
        }
        function al(e, t=em) {
            let r = [];
            return r = r.concat(ao({
                key: "",
                value: e,
                valueSpec: t.$root,
                styleSpec: t,
                style: e,
                validateSpec: ao,
                objectElementValidators: {
                    glyphs: ai,
                    "*": () => []
                }
            })),
            e.constants && (r = r.concat(rV({
                key: "constants",
                value: e.constants
            }))),
            au(r)
        }
        function as(e) {
            return function(t) {
                return e({
                    ...t,
                    validateSpec: ao
                })
            }
        }
        function au(e) {
            return [].concat(e).sort( (e, t) => e.line - t.line)
        }
        function ap(e) {
            return function(...t) {
                return au(e.apply(this, t))
            }
        }
        function ac(e) {
            if (!e)
                return {
                    style: I.UH[I.yR[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),
                    requiresUrlMonitoring: !1,
                    isFallback: !0
                };
            if ("string" == typeof e) {
                let t = function(e) {
                    try {
                        let t = JSON.parse(e)
                          , r = al(t);
                        return {
                            isValidJSON: !0,
                            isValidStyle: 0 === r.length,
                            styleObject: 0 === r.length ? t : null
                        }
                    } catch {
                        return {
                            isValidJSON: !1,
                            isValidStyle: !1,
                            styleObject: null
                        }
                    }
                }(e);
                return t.isValidStyle ? {
                    style: t.styleObject,
                    requiresUrlMonitoring: !1,
                    isFallback: !1
                } : t.isValidJSON ? {
                    style: I.UH[I.yR[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),
                    requiresUrlMonitoring: !1,
                    isFallback: !0
                } : e.startsWith("http") ? {
                    style: e,
                    requiresUrlMonitoring: !0,
                    isFallback: !1
                } : e.toLowerCase().includes(".json") ? {
                    style: function(e) {
                        try {
                            return new URL(e).href
                        } catch {}
                        return new URL(e,location.origin).href
                    }(e),
                    requiresUrlMonitoring: !0,
                    isFallback: !1
                } : {
                    style: (0,
                    I.HI)(e),
                    requiresUrlMonitoring: !0,
                    isFallback: !1
                }
            }
            return e instanceof I.YW ? {
                style: e.getExpandedStyleURL(),
                requiresUrlMonitoring: !1,
                isFallback: !1
            } : e instanceof I.jD ? {
                style: e.getDefaultVariant().getExpandedStyleURL(),
                requiresUrlMonitoring: !1,
                isFallback: !1
            } : 0 === al(e).length ? {
                style: e,
                requiresUrlMonitoring: !1,
                isFallback: !1
            } : {
                style: I.UH[I.yR[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),
                requiresUrlMonitoring: !1,
                isFallback: !0
            }
        }
        function ah(e, t, r) {
            let a = window.document.createElement(e);
            return void 0 !== t && (a.className = t),
            r && r.appendChild(a),
            a
        }
        function ad(e) {
            e.parentNode && e.parentNode.removeChild(e)
        }
        al.source = ap(as(r7)),
        al.sprite = ap(as(ar)),
        al.glyphs = ap(as(ai)),
        al.light = ap(as(r9)),
        al.sky = ap(as(ae)),
        al.terrain = ap(as(at)),
        al.state = ap(as(aa)),
        al.layer = ap(as(r4)),
        al.filter = ap(as(r1)),
        al.paintProperty = ap(as(r5)),
        al.layoutProperty = ap(as(r3));
        class af {
            constructor() {
                F(this, "_map"),
                F(this, "_container"),
                F(this, "_terrainButton"),
                function(e, t) {
                    for (let r of e)
                        "function" == typeof t[r] && (t[r] = t[r].bind(t))
                }(["_toggleTerrain", "_updateTerrainIcon"], this)
            }
            onAdd(e) {
                return this._map = e,
                this._container = ah("div", "maplibregl-ctrl maplibregl-ctrl-group"),
                this._terrainButton = ah("button", "maplibregl-ctrl-terrain", this._container),
                ah("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"),
                this._terrainButton.type = "button",
                this._terrainButton.addEventListener("click", this._toggleTerrain),
                this._updateTerrainIcon(),
                this._map.on("terrain", this._updateTerrainIcon),
                this._container
            }
            onRemove() {
                ad(this._container),
                this._map.off("terrain", this._updateTerrainIcon),
                this._map = void 0
            }
            _toggleTerrain() {
                this._map.hasTerrain() ? this._map.disableTerrain() : this._map.enableTerrain(),
                this._updateTerrainIcon()
            }
            _updateTerrainIcon() {
                this._terrainButton.classList.remove("maplibregl-ctrl-terrain"),
                this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"),
                this._map.hasTerrain() ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"),
                this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"),
                this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"))
            }
        }
        class am extends eu {
            constructor(e={}) {
                super({
                    showCompass: e.showCompass ?? !0,
                    showZoom: e.showZoom ?? !0,
                    visualizePitch: e.visualizePitch ?? !0
                }),
                F(this, "_rotateCompassArrow", () => {
                    let e = this._map.getBearing()
                      , t = this._map.getPitch()
                      , r = this.options.visualizePitch ? `scale(${Math.min(1.5, 1 / Math.cos(Math.PI / 180 * t) ** .5)}) rotateX(${Math.min(70, t)}deg) rotateZ(${-e}deg)` : `rotate(${-e}deg)`;
                    this._compassIcon.style.transform = r
                }
                ),
                this._compass && (this._compass.removeEventListener("click", this._compass.clickFunction),
                this._compass.addEventListener("click", e => {
                    0 === this._map.getPitch() ? this._map.easeTo({
                        pitch: Math.min(this._map.getMaxPitch(), 80)
                    }) : this.options.visualizePitch ? this._map.resetNorthPitch({}, {
                        originalEvent: e
                    }) : this._map.resetNorth({}, {
                        originalEvent: e
                    })
                }
                ))
            }
            _createButton(e, t) {
                let r = super._createButton(e, t);
                return r.clickFunction = t,
                r
            }
        }
        let ay = $.Marker
          , ag = $.LngLat
          , av = $.LngLatBounds;
        class ab extends ep {
            constructor() {
                super(...arguments),
                F(this, "lastUpdatedCenter", new ag(0,0)),
                F(this, "_updateCamera", e => {
                    var t;
                    let r = new ag(e.coords.longitude,e.coords.latitude)
                      , a = e.coords.accuracy
                      , n = {
                        bearing: this._map.getBearing(),
                        ...this.options.fitBoundsOptions,
                        linear: !0
                    }
                      , o = this._map.getZoom();
                    o > ((null == (t = this.options.fitBoundsOptions) ? void 0 : t.maxZoom) ?? 30) && (n.zoom = o),
                    this._map.fitBounds(av.fromLngLat(r, a), n, {
                        geolocateSource: !0
                    });
                    let i = !1
                      , l = () => {
                        i = !0
                    }
                    ;
                    this._map.once("click", l),
                    this._map.once("dblclick", l),
                    this._map.once("dragstart", l),
                    this._map.once("mousedown", l),
                    this._map.once("touchstart", l),
                    this._map.once("wheel", l),
                    this._map.once("moveend", () => {
                        this._map.off("click", l),
                        this._map.off("dblclick", l),
                        this._map.off("dragstart", l),
                        this._map.off("mousedown", l),
                        this._map.off("touchstart", l),
                        this._map.off("wheel", l),
                        i || (this.lastUpdatedCenter = this._map.getCenter())
                    }
                    )
                }
                ),
                F(this, "_finishSetupUI", e => {
                    if (this._map) {
                        if (!1 === e) {
                            let e = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                            this._geolocateButton.disabled = !0,
                            this._geolocateButton.title = e,
                            this._geolocateButton.setAttribute("aria-label", e)
                        } else {
                            let e = this._map._getUIString("GeolocateControl.FindMyLocation");
                            this._geolocateButton.disabled = !1,
                            this._geolocateButton.title = e,
                            this._geolocateButton.setAttribute("aria-label", e)
                        }
                        this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"),
                        this._watchState = "OFF"),
                        this.options.showUserLocation && (this._dotElement = ah("div", "maplibregl-user-location-dot"),
                        this._userLocationDotMarker = new ay({
                            element: this._dotElement
                        }),
                        this._circleElement = ah("div", "maplibregl-user-location-accuracy-circle"),
                        this._accuracyCircleMarker = new ay({
                            element: this._circleElement,
                            pitchAlignment: "map"
                        }),
                        this.options.trackUserLocation && (this._watchState = "OFF"),
                        this._map.on("move", this._onZoom)),
                        this._geolocateButton.addEventListener("click", this.trigger.bind(this)),
                        this._setup = !0,
                        this.options.trackUserLocation && this._map.on("moveend", e => {
                            let t = e.originalEvent && "resize" === e.originalEvent.type
                              , r = this.lastUpdatedCenter.distanceTo(this._map.getCenter());
                            e.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t || !(r > 1) || (this._watchState = "BACKGROUND",
                            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"),
                            this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"),
                            this.fire(new Event("trackuserlocationend")))
                        }
                        )
                    }
                }
                ),
                F(this, "_onZoom", () => {
                    this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
                }
                )
            }
            _updateCircleRadius() {
                if ("BACKGROUND" !== this._watchState && "ACTIVE_LOCK" !== this._watchState)
                    return;
                let e = [this._lastKnownPosition.coords.longitude, this._lastKnownPosition.coords.latitude]
                  , t = this._map.project(e)
                  , r = this._map.unproject([t.x, t.y])
                  , a = this._map.unproject([t.x + 20, t.y])
                  , n = r.distanceTo(a) / 20
                  , o = Math.ceil(2 * this._accuracy / n);
                this._circleElement.style.width = `${o}px`,
                this._circleElement.style.height = `${o}px`
            }
            _setErrorState() {
                switch (this._watchState) {
                case "WAITING_ACTIVE":
                    this._watchState = "ACTIVE_ERROR",
                    this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"),
                    this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                    break;
                case "ACTIVE_LOCK":
                    this._watchState = "ACTIVE_ERROR",
                    this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"),
                    this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"),
                    this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                    break;
                case "BACKGROUND":
                    this._watchState = "BACKGROUND_ERROR",
                    this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"),
                    this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"),
                    this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                    break;
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                    break;
                default:
                    throw Error(`Unexpected watchState ${this._watchState}`)
                }
            }
        }
        class ax {
            constructor(e, t) {
                B(this, x),
                B(this, f),
                F(this, "map"),
                B(this, m),
                B(this, y),
                B(this, g),
                B(this, v, !1),
                B(this, b),
                void 0 !== e.style && G(this, v, !0),
                G(this, f, {
                    zoomAdjust: -4,
                    position: "top-right",
                    ...t,
                    forceNoAttributionControl: !0,
                    attributionControl: !1,
                    navigationControl: !1,
                    geolocateControl: !1,
                    maptilerLogo: !1,
                    minimap: !1,
                    hash: !1,
                    pitchAdjust: !1,
                    ...e,
                    containerStyle: {
                        border: "1px solid #000",
                        width: "400px",
                        height: "300px",
                        ...e.containerStyle ?? {}
                    }
                }),
                void 0 !== e.lockZoom && (D(this, f).minZoom = e.lockZoom,
                D(this, f).maxZoom = e.lockZoom)
            }
            setStyle(e, t) {
                D(this, v) || this.map.setStyle(e, t),
                V(this, x, S).call(this)
            }
            addLayer(e, t) {
                return D(this, v) || this.map.addLayer(e, t),
                V(this, x, S).call(this),
                this.map
            }
            moveLayer(e, t) {
                return D(this, v) || this.map.moveLayer(e, t),
                V(this, x, S).call(this),
                this.map
            }
            removeLayer(e) {
                return D(this, v) || this.map.removeLayer(e),
                V(this, x, S).call(this),
                this
            }
            setLayerZoomRange(e, t, r) {
                return D(this, v) || this.map.setLayerZoomRange(e, t, r),
                V(this, x, S).call(this),
                this
            }
            setFilter(e, t, r) {
                return D(this, v) || this.map.setFilter(e, t, r),
                V(this, x, S).call(this),
                this
            }
            setPaintProperty(e, t, r, a) {
                return D(this, v) || this.map.setPaintProperty(e, t, r, a),
                V(this, x, S).call(this),
                this
            }
            setLayoutProperty(e, t, r, a) {
                return D(this, v) || this.map.setLayoutProperty(e, t, r, a),
                V(this, x, S).call(this),
                this
            }
            setGlyphs(e, t) {
                return D(this, v) || this.map.setGlyphs(e, t),
                V(this, x, S).call(this),
                this
            }
            onAdd(e) {
                for (let[t,r] of (G(this, m, e),
                G(this, y, ah("div", "maplibregl-ctrl maplibregl-ctrl-group")),
                Object.entries(D(this, f).containerStyle)))
                    D(this, y).style.setProperty(t, r);
                return D(this, f).container = D(this, y),
                D(this, f).zoom = e.getZoom() + D(this, f).zoomAdjust,
                this.map = new a4(D(this, f)),
                this.map.once("style.load", () => {
                    this.map.resize()
                }
                ),
                this.map.once("load", () => {
                    V(this, x, w).call(this, D(this, f).parentRect),
                    G(this, b, V(this, x, k).call(this))
                }
                ),
                D(this, y)
            }
            onRemove() {
                var e;
                null == (e = D(this, b)) || e.call(this),
                ad(D(this, y))
            }
        }
        f = new WeakMap,
        m = new WeakMap,
        y = new WeakMap,
        g = new WeakMap,
        v = new WeakMap,
        b = new WeakMap,
        x = new WeakSet,
        w = function(e) {
            void 0 === e || void 0 === e.linePaint && void 0 === e.fillPaint || (G(this, g, {
                type: "Feature",
                properties: {
                    name: "parentRect"
                },
                geometry: {
                    type: "Polygon",
                    coordinates: [[[], [], [], [], []]]
                }
            }),
            this.map.addSource("parentRect", {
                type: "geojson",
                data: D(this, g)
            }),
            (void 0 !== e.lineLayout || void 0 !== e.linePaint) && this.map.addLayer({
                id: "parentRectOutline",
                type: "line",
                source: "parentRect",
                layout: {
                    ...e.lineLayout
                },
                paint: {
                    "line-color": "#FFF",
                    "line-width": 1,
                    "line-opacity": .85,
                    ...e.linePaint
                }
            }),
            void 0 !== e.fillPaint && this.map.addLayer({
                id: "parentRectFill",
                type: "fill",
                source: "parentRect",
                layout: {},
                paint: {
                    "fill-color": "#08F",
                    "fill-opacity": .135,
                    ...e.fillPaint
                }
            }),
            V(this, x, S).call(this))
        }
        ,
        S = function() {
            if (void 0 === D(this, g))
                return;
            let {devicePixelRatio: e} = window
              , t = D(this, m).getCanvas()
              , r = t.width / e
              , a = t.height / e
              , n = D(this, m).unproject.bind(D(this, m))
              , o = n([0, 0])
              , i = n([r, 0])
              , l = n([0, a])
              , s = n([r, a]);
            D(this, g).geometry.coordinates = [[l.toArray(), s.toArray(), i.toArray(), o.toArray(), l.toArray()]];
            let u = this.map.getSource("parentRect");
            void 0 !== u && u.setData(D(this, g))
        }
        ,
        k = function() {
            let {pitchAdjust: e} = D(this, f)
              , t = () => {
                o("parent")
            }
              , r = () => {
                o("minimap")
            }
              , a = () => {
                D(this, m).on("move", t),
                this.map.on("move", r)
            }
              , n = () => {
                D(this, m).off("move", t),
                this.map.off("move", r)
            }
              , o = t => {
                n();
                let r = "parent" === t ? D(this, m) : this.map
                  , o = "parent" === t ? this.map : D(this, m)
                  , i = r.getCenter()
                  , l = r.getZoom() + D(this, f).zoomAdjust * ("parent" === t ? 1 : -1)
                  , s = r.getBearing()
                  , u = r.getPitch();
                o.jumpTo({
                    center: i,
                    zoom: l,
                    bearing: s,
                    pitch: e ? u : 0
                }),
                V(this, x, S).call(this),
                a()
            }
            ;
            return a(),
            () => {
                n()
            }
        }
        ;
        class aw {
            constructor() {
                F(this, "map"),
                F(this, "container"),
                F(this, "projectionButton")
            }
            onAdd(e) {
                return this.map = e,
                this.container = ah("div", "maplibregl-ctrl maplibregl-ctrl-group"),
                this.projectionButton = ah("button", "maplibregl-ctrl-projection", this.container),
                ah("span", "maplibregl-ctrl-icon", this.projectionButton).setAttribute("aria-hidden", "true"),
                this.projectionButton.type = "button",
                this.projectionButton.addEventListener("click", this.toggleProjection.bind(this)),
                e.on("projectiontransition", this.updateProjectionIcon.bind(this)),
                this.updateProjectionIcon(),
                this.container
            }
            onRemove() {
                ad(this.container),
                this.map.off("projectiontransition", this.updateProjectionIcon),
                this.map = void 0
            }
            toggleProjection() {
                void 0 === this.map.getProjection() && this.map.setProjection({
                    type: "mercator"
                }),
                this.map.isGlobeProjection() ? this.map.enableMercatorProjection() : this.map.enableGlobeProjection(),
                this.updateProjectionIcon()
            }
            updateProjectionIcon() {
                this.projectionButton.classList.remove("maplibregl-ctrl-projection-globe"),
                this.projectionButton.classList.remove("maplibregl-ctrl-projection-mercator"),
                this.map.isGlobeProjection() ? (this.projectionButton.classList.add("maplibregl-ctrl-projection-mercator"),
                this.projectionButton.title = "Enable Mercator projection") : (this.projectionButton.classList.add("maplibregl-ctrl-projection-globe"),
                this.projectionButton.title = "Enable Globe projection")
            }
        }
        class aS {
            constructor(e, t=2e3) {
                F(this, "map"),
                F(this, "registeredModules", new Set),
                this.map = e,
                setTimeout(async () => {
                    if (!Y.telemetry)
                        return;
                    let e = this.preparePayload();
                    try {
                        (await fetch(e, {
                            method: "POST"
                        })).ok || console.warn("The metrics could not be sent to MapTiler Cloud")
                    } catch (e) {
                        console.warn("The metrics could not be sent to MapTiler Cloud", e)
                    }
                }
                , Math.max(1e3, t))
            }
            registerModule(e, t) {
                this.registeredModules.add(`${e}:${t}`)
            }
            preparePayload() {
                let e = new URL(K.telemetryURL);
                return e.searchParams.append("sdk", "3.7.0"),
                e.searchParams.append("key", Y.apiKey),
                e.searchParams.append("mtsid", Z),
                e.searchParams.append("session", Y.session ? "1" : "0"),
                e.searchParams.append("caching", Y.caching ? "1" : "0"),
                e.searchParams.append("lang-updated", this.map.isLanguageUpdated() ? "1" : "0"),
                e.searchParams.append("terrain", this.map.getTerrain() ? "1" : "0"),
                e.searchParams.append("globe", this.map.isGlobeProjection() ? "1" : "0"),
                this.registeredModules.size > 0 && e.searchParams.append("modules", Array.from(this.registeredModules).join("|")),
                e.href
            }
        }
        var ak = "u" > typeof Float32Array ? Float32Array : Array;
        function a_() {
            var e = new ak(16);
            return ak != Float32Array && (e[1] = 0,
            e[2] = 0,
            e[3] = 0,
            e[4] = 0,
            e[6] = 0,
            e[7] = 0,
            e[8] = 0,
            e[9] = 0,
            e[11] = 0,
            e[12] = 0,
            e[13] = 0,
            e[14] = 0),
            e[0] = 1,
            e[5] = 1,
            e[10] = 1,
            e[15] = 1,
            e
        }
        function aC(e, t, r) {
            var a = Math.sin(r)
              , n = Math.cos(r)
              , o = t[4]
              , i = t[5]
              , l = t[6]
              , s = t[7]
              , u = t[8]
              , p = t[9]
              , c = t[10]
              , h = t[11];
            return t !== e && (e[0] = t[0],
            e[1] = t[1],
            e[2] = t[2],
            e[3] = t[3],
            e[12] = t[12],
            e[13] = t[13],
            e[14] = t[14],
            e[15] = t[15]),
            e[4] = o * n + u * a,
            e[5] = i * n + p * a,
            e[6] = l * n + c * a,
            e[7] = s * n + h * a,
            e[8] = u * n - o * a,
            e[9] = p * n - i * a,
            e[10] = c * n - l * a,
            e[11] = h * n - s * a,
            e
        }
        function aE(e, t, r) {
            var a = Math.sin(r)
              , n = Math.cos(r)
              , o = t[0]
              , i = t[1]
              , l = t[2]
              , s = t[3]
              , u = t[4]
              , p = t[5]
              , c = t[6]
              , h = t[7];
            return t !== e && (e[8] = t[8],
            e[9] = t[9],
            e[10] = t[10],
            e[11] = t[11],
            e[12] = t[12],
            e[13] = t[13],
            e[14] = t[14],
            e[15] = t[15]),
            e[0] = o * n + u * a,
            e[1] = i * n + p * a,
            e[2] = l * n + c * a,
            e[3] = s * n + h * a,
            e[4] = u * n - o * a,
            e[5] = p * n - i * a,
            e[6] = c * n - l * a,
            e[7] = h * n - s * a,
            e
        }
        Math.hypot || (Math.hypot = function() {
            for (var e = 0, t = arguments.length; t--; )
                e += arguments[t] * arguments[t];
            return Math.sqrt(e)
        }
        );
        var aA = function(e, t, r, a, n) {
            var o, i = 1 / Math.tan(t / 2);
            return e[0] = i / r,
            e[1] = 0,
            e[2] = 0,
            e[3] = 0,
            e[4] = 0,
            e[5] = i,
            e[6] = 0,
            e[7] = 0,
            e[8] = 0,
            e[9] = 0,
            e[11] = -1,
            e[12] = 0,
            e[13] = 0,
            e[15] = 0,
            null != n && n !== 1 / 0 ? (o = 1 / (a - n),
            e[10] = (n + a) * o,
            e[14] = 2 * n * a * o) : (e[10] = -1,
            e[14] = -2 * a),
            e
        };
        function aL() {
            var e = new ak(3);
            return ak != Float32Array && (e[0] = 0,
            e[1] = 0,
            e[2] = 0),
            e
        }
        function aT(e, t) {
            var r = t[0]
              , a = t[1]
              , n = t[2]
              , o = r * r + a * a + n * n;
            return o > 0 && (o = 1 / Math.sqrt(o)),
            e[0] = t[0] * o,
            e[1] = t[1] * o,
            e[2] = t[2] * o,
            e
        }
        function aM(e, t, r) {
            var a = t[0]
              , n = t[1]
              , o = t[2]
              , i = r[0]
              , l = r[1]
              , s = r[2];
            return e[0] = n * s - o * l,
            e[1] = o * i - a * s,
            e[2] = a * l - n * i,
            e
        }
        function aP() {
            if (A)
                return E;
            A = 1;
            let e = (C || (C = 1,
            _ = {
                aliceblue: [240, 248, 255],
                antiquewhite: [250, 235, 215],
                aqua: [0, 255, 255],
                aquamarine: [127, 255, 212],
                azure: [240, 255, 255],
                beige: [245, 245, 220],
                bisque: [255, 228, 196],
                black: [0, 0, 0],
                blanchedalmond: [255, 235, 205],
                blue: [0, 0, 255],
                blueviolet: [138, 43, 226],
                brown: [165, 42, 42],
                burlywood: [222, 184, 135],
                cadetblue: [95, 158, 160],
                chartreuse: [127, 255, 0],
                chocolate: [210, 105, 30],
                coral: [255, 127, 80],
                cornflowerblue: [100, 149, 237],
                cornsilk: [255, 248, 220],
                crimson: [220, 20, 60],
                cyan: [0, 255, 255],
                darkblue: [0, 0, 139],
                darkcyan: [0, 139, 139],
                darkgoldenrod: [184, 134, 11],
                darkgray: [169, 169, 169],
                darkgreen: [0, 100, 0],
                darkgrey: [169, 169, 169],
                darkkhaki: [189, 183, 107],
                darkmagenta: [139, 0, 139],
                darkolivegreen: [85, 107, 47],
                darkorange: [255, 140, 0],
                darkorchid: [153, 50, 204],
                darkred: [139, 0, 0],
                darksalmon: [233, 150, 122],
                darkseagreen: [143, 188, 143],
                darkslateblue: [72, 61, 139],
                darkslategray: [47, 79, 79],
                darkslategrey: [47, 79, 79],
                darkturquoise: [0, 206, 209],
                darkviolet: [148, 0, 211],
                deeppink: [255, 20, 147],
                deepskyblue: [0, 191, 255],
                dimgray: [105, 105, 105],
                dimgrey: [105, 105, 105],
                dodgerblue: [30, 144, 255],
                firebrick: [178, 34, 34],
                floralwhite: [255, 250, 240],
                forestgreen: [34, 139, 34],
                fuchsia: [255, 0, 255],
                gainsboro: [220, 220, 220],
                ghostwhite: [248, 248, 255],
                gold: [255, 215, 0],
                goldenrod: [218, 165, 32],
                gray: [128, 128, 128],
                green: [0, 128, 0],
                greenyellow: [173, 255, 47],
                grey: [128, 128, 128],
                honeydew: [240, 255, 240],
                hotpink: [255, 105, 180],
                indianred: [205, 92, 92],
                indigo: [75, 0, 130],
                ivory: [255, 255, 240],
                khaki: [240, 230, 140],
                lavender: [230, 230, 250],
                lavenderblush: [255, 240, 245],
                lawngreen: [124, 252, 0],
                lemonchiffon: [255, 250, 205],
                lightblue: [173, 216, 230],
                lightcoral: [240, 128, 128],
                lightcyan: [224, 255, 255],
                lightgoldenrodyellow: [250, 250, 210],
                lightgray: [211, 211, 211],
                lightgreen: [144, 238, 144],
                lightgrey: [211, 211, 211],
                lightpink: [255, 182, 193],
                lightsalmon: [255, 160, 122],
                lightseagreen: [32, 178, 170],
                lightskyblue: [135, 206, 250],
                lightslategray: [119, 136, 153],
                lightslategrey: [119, 136, 153],
                lightsteelblue: [176, 196, 222],
                lightyellow: [255, 255, 224],
                lime: [0, 255, 0],
                limegreen: [50, 205, 50],
                linen: [250, 240, 230],
                magenta: [255, 0, 255],
                maroon: [128, 0, 0],
                mediumaquamarine: [102, 205, 170],
                mediumblue: [0, 0, 205],
                mediumorchid: [186, 85, 211],
                mediumpurple: [147, 112, 219],
                mediumseagreen: [60, 179, 113],
                mediumslateblue: [123, 104, 238],
                mediumspringgreen: [0, 250, 154],
                mediumturquoise: [72, 209, 204],
                mediumvioletred: [199, 21, 133],
                midnightblue: [25, 25, 112],
                mintcream: [245, 255, 250],
                mistyrose: [255, 228, 225],
                moccasin: [255, 228, 181],
                navajowhite: [255, 222, 173],
                navy: [0, 0, 128],
                oldlace: [253, 245, 230],
                olive: [128, 128, 0],
                olivedrab: [107, 142, 35],
                orange: [255, 165, 0],
                orangered: [255, 69, 0],
                orchid: [218, 112, 214],
                palegoldenrod: [238, 232, 170],
                palegreen: [152, 251, 152],
                paleturquoise: [175, 238, 238],
                palevioletred: [219, 112, 147],
                papayawhip: [255, 239, 213],
                peachpuff: [255, 218, 185],
                peru: [205, 133, 63],
                pink: [255, 192, 203],
                plum: [221, 160, 221],
                powderblue: [176, 224, 230],
                purple: [128, 0, 128],
                rebeccapurple: [102, 51, 153],
                red: [255, 0, 0],
                rosybrown: [188, 143, 143],
                royalblue: [65, 105, 225],
                saddlebrown: [139, 69, 19],
                salmon: [250, 128, 114],
                sandybrown: [244, 164, 96],
                seagreen: [46, 139, 87],
                seashell: [255, 245, 238],
                sienna: [160, 82, 45],
                silver: [192, 192, 192],
                skyblue: [135, 206, 235],
                slateblue: [106, 90, 205],
                slategray: [112, 128, 144],
                slategrey: [112, 128, 144],
                snow: [255, 250, 250],
                springgreen: [0, 255, 127],
                steelblue: [70, 130, 180],
                tan: [210, 180, 140],
                teal: [0, 128, 128],
                thistle: [216, 191, 216],
                tomato: [255, 99, 71],
                turquoise: [64, 224, 208],
                violet: [238, 130, 238],
                wheat: [245, 222, 179],
                white: [255, 255, 255],
                whitesmoke: [245, 245, 245],
                yellow: [255, 255, 0],
                yellowgreen: [154, 205, 50]
            }),
            _)
              , t = {};
            for (let r of Object.keys(e))
                t[e[r]] = r;
            let r = {
                rgb: {
                    channels: 3,
                    labels: "rgb"
                },
                hsl: {
                    channels: 3,
                    labels: "hsl"
                },
                hsv: {
                    channels: 3,
                    labels: "hsv"
                },
                hwb: {
                    channels: 3,
                    labels: "hwb"
                },
                cmyk: {
                    channels: 4,
                    labels: "cmyk"
                },
                xyz: {
                    channels: 3,
                    labels: "xyz"
                },
                lab: {
                    channels: 3,
                    labels: "lab"
                },
                lch: {
                    channels: 3,
                    labels: "lch"
                },
                hex: {
                    channels: 1,
                    labels: ["hex"]
                },
                keyword: {
                    channels: 1,
                    labels: ["keyword"]
                },
                ansi16: {
                    channels: 1,
                    labels: ["ansi16"]
                },
                ansi256: {
                    channels: 1,
                    labels: ["ansi256"]
                },
                hcg: {
                    channels: 3,
                    labels: ["h", "c", "g"]
                },
                apple: {
                    channels: 3,
                    labels: ["r16", "g16", "b16"]
                },
                gray: {
                    channels: 1,
                    labels: ["gray"]
                }
            };
            for (let e of (E = r,
            Object.keys(r))) {
                if (!("channels"in r[e]))
                    throw Error("missing channels property: " + e);
                if (!("labels"in r[e]))
                    throw Error("missing channel labels property: " + e);
                if (r[e].labels.length !== r[e].channels)
                    throw Error("channel and label counts mismatch: " + e);
                let {channels: t, labels: a} = r[e];
                delete r[e].channels,
                delete r[e].labels,
                Object.defineProperty(r[e], "channels", {
                    value: t
                }),
                Object.defineProperty(r[e], "labels", {
                    value: a
                })
            }
            return r.rgb.hsl = function(e) {
                let t;
                let r = e[0] / 255
                  , a = e[1] / 255
                  , n = e[2] / 255
                  , o = Math.min(r, a, n)
                  , i = Math.max(r, a, n)
                  , l = i - o;
                i === o ? t = 0 : r === i ? t = (a - n) / l : a === i ? t = 2 + (n - r) / l : n === i && (t = 4 + (r - a) / l),
                (t = Math.min(60 * t, 360)) < 0 && (t += 360);
                let s = (o + i) / 2;
                return [t, 100 * (i === o ? 0 : s <= .5 ? l / (i + o) : l / (2 - i - o)), 100 * s]
            }
            ,
            r.rgb.hsv = function(e) {
                let t, r, a, n, o;
                let i = e[0] / 255
                  , l = e[1] / 255
                  , s = e[2] / 255
                  , u = Math.max(i, l, s)
                  , p = u - Math.min(i, l, s)
                  , c = function(e) {
                    return (u - e) / 6 / p + .5
                };
                return 0 === p ? (n = 0,
                o = 0) : (o = p / u,
                t = c(i),
                r = c(l),
                a = c(s),
                i === u ? n = a - r : l === u ? n = 1 / 3 + t - a : s === u && (n = 2 / 3 + r - t),
                n < 0 ? n += 1 : n > 1 && (n -= 1)),
                [360 * n, 100 * o, 100 * u]
            }
            ,
            r.rgb.hwb = function(e) {
                let t = e[0]
                  , a = e[1]
                  , n = e[2];
                return [r.rgb.hsl(e)[0], 1 / 255 * Math.min(t, Math.min(a, n)) * 100, 100 * (n = 1 - 1 / 255 * Math.max(t, Math.max(a, n)))]
            }
            ,
            r.rgb.cmyk = function(e) {
                let t = e[0] / 255
                  , r = e[1] / 255
                  , a = e[2] / 255
                  , n = Math.min(1 - t, 1 - r, 1 - a);
                return [100 * ((1 - t - n) / (1 - n) || 0), 100 * ((1 - r - n) / (1 - n) || 0), 100 * ((1 - a - n) / (1 - n) || 0), 100 * n]
            }
            ,
            r.rgb.keyword = function(r) {
                let a = t[r];
                if (a)
                    return a;
                let n = 1 / 0, o;
                for (let t of Object.keys(e)) {
                    let a = e[t]
                      , i = (r[0] - a[0]) ** 2 + (r[1] - a[1]) ** 2 + (r[2] - a[2]) ** 2;
                    i < n && (n = i,
                    o = t)
                }
                return o
            }
            ,
            r.keyword.rgb = function(t) {
                return e[t]
            }
            ,
            r.rgb.xyz = function(e) {
                let t = e[0] / 255
                  , r = e[1] / 255
                  , a = e[2] / 255;
                return [100 * (.4124 * (t = t > .04045 ? ((t + .055) / 1.055) ** 2.4 : t / 12.92) + .3576 * (r = r > .04045 ? ((r + .055) / 1.055) ** 2.4 : r / 12.92) + .1805 * (a = a > .04045 ? ((a + .055) / 1.055) ** 2.4 : a / 12.92)), 100 * (.2126 * t + .7152 * r + .0722 * a), 100 * (.0193 * t + .1192 * r + .9505 * a)]
            }
            ,
            r.rgb.lab = function(e) {
                let t = r.rgb.xyz(e)
                  , a = t[0]
                  , n = t[1]
                  , o = t[2];
                return a /= 95.047,
                n /= 100,
                o /= 108.883,
                [116 * (n = n > .008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116) - 16, 500 * ((a = a > .008856 ? a ** (1 / 3) : 7.787 * a + 16 / 116) - n), 200 * (n - (o = o > .008856 ? o ** (1 / 3) : 7.787 * o + 16 / 116))]
            }
            ,
            r.hsl.rgb = function(e) {
                let t, r, a;
                let n = e[0] / 360
                  , o = e[1] / 100
                  , i = e[2] / 100;
                if (0 === o)
                    return [a = 255 * i, a, a];
                t = i < .5 ? i * (1 + o) : i + o - i * o;
                let l = 2 * i - t
                  , s = [0, 0, 0];
                for (let e = 0; e < 3; e++)
                    (r = n + -(1 / 3 * (e - 1))) < 0 && r++,
                    r > 1 && r--,
                    a = 6 * r < 1 ? l + (t - l) * 6 * r : 2 * r < 1 ? t : 3 * r < 2 ? l + (t - l) * (2 / 3 - r) * 6 : l,
                    s[e] = 255 * a;
                return s
            }
            ,
            r.hsl.hsv = function(e) {
                let t = e[0]
                  , r = e[1] / 100
                  , a = e[2] / 100
                  , n = r
                  , o = Math.max(a, .01);
                a *= 2,
                r *= a <= 1 ? a : 2 - a,
                n *= o <= 1 ? o : 2 - o;
                let i = (a + r) / 2;
                return [t, 100 * (0 === a ? 2 * n / (o + n) : 2 * r / (a + r)), 100 * i]
            }
            ,
            r.hsv.rgb = function(e) {
                let t = e[0] / 60
                  , r = e[1] / 100
                  , a = e[2] / 100
                  , n = Math.floor(t) % 6
                  , o = t - Math.floor(t)
                  , i = 255 * a * (1 - r)
                  , l = 255 * a * (1 - r * o)
                  , s = 255 * a * (1 - r * (1 - o));
                switch (a *= 255,
                n) {
                case 0:
                    return [a, s, i];
                case 1:
                    return [l, a, i];
                case 2:
                    return [i, a, s];
                case 3:
                    return [i, l, a];
                case 4:
                    return [s, i, a];
                case 5:
                    return [a, i, l]
                }
            }
            ,
            r.hsv.hsl = function(e) {
                let t, r;
                let a = e[0]
                  , n = e[1] / 100
                  , o = e[2] / 100
                  , i = Math.max(o, .01);
                r = (2 - n) * o;
                let l = (2 - n) * i;
                return [a, 100 * (n * i / (l <= 1 ? l : 2 - l) || 0), 100 * (r /= 2)]
            }
            ,
            r.hwb.rgb = function(e) {
                let t, r, a, n;
                let o = e[0] / 360
                  , i = e[1] / 100
                  , l = e[2] / 100
                  , s = i + l;
                s > 1 && (i /= s,
                l /= s);
                let u = Math.floor(6 * o)
                  , p = 1 - l;
                t = 6 * o - u,
                1 & u && (t = 1 - t);
                let c = i + t * (p - i);
                switch (u) {
                default:
                case 6:
                case 0:
                    r = p,
                    a = c,
                    n = i;
                    break;
                case 1:
                    r = c,
                    a = p,
                    n = i;
                    break;
                case 2:
                    r = i,
                    a = p,
                    n = c;
                    break;
                case 3:
                    r = i,
                    a = c,
                    n = p;
                    break;
                case 4:
                    r = c,
                    a = i,
                    n = p;
                    break;
                case 5:
                    r = p,
                    a = i,
                    n = c
                }
                return [255 * r, 255 * a, 255 * n]
            }
            ,
            r.cmyk.rgb = function(e) {
                let t = e[0] / 100
                  , r = e[1] / 100
                  , a = e[2] / 100
                  , n = e[3] / 100;
                return [255 * (1 - Math.min(1, t * (1 - n) + n)), 255 * (1 - Math.min(1, r * (1 - n) + n)), 255 * (1 - Math.min(1, a * (1 - n) + n))]
            }
            ,
            r.xyz.rgb = function(e) {
                let t, r, a;
                let n = e[0] / 100
                  , o = e[1] / 100
                  , i = e[2] / 100;
                return t = (t = 3.2406 * n + -1.5372 * o + -.4986 * i) > .0031308 ? 1.055 * t ** (1 / 2.4) - .055 : 12.92 * t,
                r = (r = -.9689 * n + 1.8758 * o + .0415 * i) > .0031308 ? 1.055 * r ** (1 / 2.4) - .055 : 12.92 * r,
                a = (a = .0557 * n + -.204 * o + 1.057 * i) > .0031308 ? 1.055 * a ** (1 / 2.4) - .055 : 12.92 * a,
                [255 * (t = Math.min(Math.max(0, t), 1)), 255 * (r = Math.min(Math.max(0, r), 1)), 255 * (a = Math.min(Math.max(0, a), 1))]
            }
            ,
            r.xyz.lab = function(e) {
                let t = e[0]
                  , r = e[1]
                  , a = e[2];
                return t /= 95.047,
                r /= 100,
                a /= 108.883,
                [116 * (r = r > .008856 ? r ** (1 / 3) : 7.787 * r + 16 / 116) - 16, 500 * ((t = t > .008856 ? t ** (1 / 3) : 7.787 * t + 16 / 116) - r), 200 * (r - (a = a > .008856 ? a ** (1 / 3) : 7.787 * a + 16 / 116))]
            }
            ,
            r.lab.xyz = function(e) {
                let t, r, a;
                let n = e[0]
                  , o = e[1]
                  , i = e[2];
                t = o / 500 + (r = (n + 16) / 116),
                a = r - i / 200;
                let l = r ** 3
                  , s = t ** 3
                  , u = a ** 3;
                return r = (l > .008856 ? l : (r - 16 / 116) / 7.787) * 100,
                [t = (s > .008856 ? s : (t - 16 / 116) / 7.787) * 95.047, r, a = (u > .008856 ? u : (a - 16 / 116) / 7.787) * 108.883]
            }
            ,
            r.lab.lch = function(e) {
                let t;
                let r = e[0]
                  , a = e[1]
                  , n = e[2];
                return (t = 360 * Math.atan2(n, a) / 2 / Math.PI) < 0 && (t += 360),
                [r, Math.sqrt(a * a + n * n), t]
            }
            ,
            r.lch.lab = function(e) {
                let t = e[0]
                  , r = e[1]
                  , a = e[2] / 360 * 2 * Math.PI;
                return [t, r * Math.cos(a), r * Math.sin(a)]
            }
            ,
            r.rgb.ansi16 = function(e, t=null) {
                let[a,n,o] = e
                  , i = null === t ? r.rgb.hsv(e)[2] : t;
                if (0 === (i = Math.round(i / 50)))
                    return 30;
                let l = 30 + (Math.round(o / 255) << 2 | Math.round(n / 255) << 1 | Math.round(a / 255));
                return 2 === i && (l += 60),
                l
            }
            ,
            r.hsv.ansi16 = function(e) {
                return r.rgb.ansi16(r.hsv.rgb(e), e[2])
            }
            ,
            r.rgb.ansi256 = function(e) {
                let t = e[0]
                  , r = e[1]
                  , a = e[2];
                return t === r && r === a ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(r / 255 * 5) + Math.round(a / 255 * 5)
            }
            ,
            r.ansi16.rgb = function(e) {
                let t = e % 10;
                if (0 === t || 7 === t)
                    return e > 50 && (t += 3.5),
                    [t = t / 10.5 * 255, t, t];
                let r = (~~(e > 50) + 1) * .5;
                return [(1 & t) * r * 255, (t >> 1 & 1) * r * 255, (t >> 2 & 1) * r * 255]
            }
            ,
            r.ansi256.rgb = function(e) {
                let t;
                if (e >= 232) {
                    let t = (e - 232) * 10 + 8;
                    return [t, t, t]
                }
                return [Math.floor((e -= 16) / 36) / 5 * 255, Math.floor((t = e % 36) / 6) / 5 * 255, t % 6 / 5 * 255]
            }
            ,
            r.rgb.hex = function(e) {
                let t = (((255 & Math.round(e[0])) << 16) + ((255 & Math.round(e[1])) << 8) + (255 & Math.round(e[2]))).toString(16).toUpperCase();
                return "000000".substring(t.length) + t
            }
            ,
            r.hex.rgb = function(e) {
                let t = e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
                if (!t)
                    return [0, 0, 0];
                let r = t[0];
                3 === t[0].length && (r = r.split("").map(e => e + e).join(""));
                let a = parseInt(r, 16);
                return [a >> 16 & 255, a >> 8 & 255, 255 & a]
            }
            ,
            r.rgb.hcg = function(e) {
                let t;
                let r = e[0] / 255
                  , a = e[1] / 255
                  , n = e[2] / 255
                  , o = Math.max(Math.max(r, a), n)
                  , i = Math.min(Math.min(r, a), n)
                  , l = o - i;
                return t = l < 1 ? i / (1 - l) : 0,
                [(l <= 0 ? 0 : o === r ? (a - n) / l % 6 : o === a ? 2 + (n - r) / l : 4 + (r - a) / l) / 6 % 1 * 360, 100 * l, 100 * t]
            }
            ,
            r.hsl.hcg = function(e) {
                let t = e[1] / 100
                  , r = e[2] / 100
                  , a = r < .5 ? 2 * t * r : 2 * t * (1 - r)
                  , n = 0;
                return a < 1 && (n = (r - .5 * a) / (1 - a)),
                [e[0], 100 * a, 100 * n]
            }
            ,
            r.hsv.hcg = function(e) {
                let t = e[1] / 100
                  , r = e[2] / 100
                  , a = t * r
                  , n = 0;
                return a < 1 && (n = (r - a) / (1 - a)),
                [e[0], 100 * a, 100 * n]
            }
            ,
            r.hcg.rgb = function(e) {
                let t = e[0] / 360
                  , r = e[1] / 100
                  , a = e[2] / 100;
                if (0 === r)
                    return [255 * a, 255 * a, 255 * a];
                let n = [0, 0, 0]
                  , o = t % 1 * 6
                  , i = o % 1
                  , l = 1 - i
                  , s = 0;
                switch (Math.floor(o)) {
                case 0:
                    n[0] = 1,
                    n[1] = i,
                    n[2] = 0;
                    break;
                case 1:
                    n[0] = l,
                    n[1] = 1,
                    n[2] = 0;
                    break;
                case 2:
                    n[0] = 0,
                    n[1] = 1,
                    n[2] = i;
                    break;
                case 3:
                    n[0] = 0,
                    n[1] = l,
                    n[2] = 1;
                    break;
                case 4:
                    n[0] = i,
                    n[1] = 0,
                    n[2] = 1;
                    break;
                default:
                    n[0] = 1,
                    n[1] = 0,
                    n[2] = l
                }
                return s = (1 - r) * a,
                [(r * n[0] + s) * 255, (r * n[1] + s) * 255, (r * n[2] + s) * 255]
            }
            ,
            r.hcg.hsv = function(e) {
                let t = e[1] / 100
                  , r = t + e[2] / 100 * (1 - t)
                  , a = 0;
                return r > 0 && (a = t / r),
                [e[0], 100 * a, 100 * r]
            }
            ,
            r.hcg.hsl = function(e) {
                let t = e[1] / 100
                  , r = e[2] / 100 * (1 - t) + .5 * t
                  , a = 0;
                return r > 0 && r < .5 ? a = t / (2 * r) : r >= .5 && r < 1 && (a = t / (2 * (1 - r))),
                [e[0], 100 * a, 100 * r]
            }
            ,
            r.hcg.hwb = function(e) {
                let t = e[1] / 100
                  , r = t + e[2] / 100 * (1 - t);
                return [e[0], (r - t) * 100, (1 - r) * 100]
            }
            ,
            r.hwb.hcg = function(e) {
                let t = e[1] / 100
                  , r = 1 - e[2] / 100
                  , a = r - t
                  , n = 0;
                return a < 1 && (n = (r - a) / (1 - a)),
                [e[0], 100 * a, 100 * n]
            }
            ,
            r.apple.rgb = function(e) {
                return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255]
            }
            ,
            r.rgb.apple = function(e) {
                return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535]
            }
            ,
            r.gray.rgb = function(e) {
                return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255]
            }
            ,
            r.gray.hsl = function(e) {
                return [0, 0, e[0]]
            }
            ,
            r.gray.hsv = r.gray.hsl,
            r.gray.hwb = function(e) {
                return [0, 100, e[0]]
            }
            ,
            r.gray.cmyk = function(e) {
                return [0, 0, 0, e[0]]
            }
            ,
            r.gray.lab = function(e) {
                return [e[0], 0, 0]
            }
            ,
            r.gray.hex = function(e) {
                let t = 255 & Math.round(e[0] / 100 * 255)
                  , r = ((t << 16) + (t << 8) + t).toString(16).toUpperCase();
                return "000000".substring(r.length) + r
            }
            ,
            r.rgb.gray = function(e) {
                return [(e[0] + e[1] + e[2]) / 3 / 255 * 100]
            }
            ,
            E
        }
        aL();
        let a$ = (c = function() {
            if (P)
                return M;
            P = 1;
            let e = aP()
              , t = function() {
                if (T)
                    return L;
                T = 1;
                let e = aP();
                return L = function(t) {
                    let r = function(t) {
                        let r = function() {
                            let t = {}
                              , r = Object.keys(e);
                            for (let e = r.length, a = 0; a < e; a++)
                                t[r[a]] = {
                                    distance: -1,
                                    parent: null
                                };
                            return t
                        }()
                          , a = [t];
                        for (r[t].distance = 0; a.length; ) {
                            let t = a.pop()
                              , n = Object.keys(e[t]);
                            for (let e = n.length, o = 0; o < e; o++) {
                                let e = n[o]
                                  , i = r[e];
                                -1 === i.distance && (i.distance = r[t].distance + 1,
                                i.parent = t,
                                a.unshift(e))
                            }
                        }
                        return r
                    }(t)
                      , a = {}
                      , n = Object.keys(r);
                    for (let t = n.length, o = 0; o < t; o++) {
                        let t = n[o];
                        null !== r[t].parent && (a[t] = function(t, r) {
                            let a = [r[t].parent, t]
                              , n = e[r[t].parent][t]
                              , o = r[t].parent;
                            for (; r[o].parent; )
                                a.unshift(r[o].parent),
                                n = function(e, t) {
                                    return function(r) {
                                        return t(e(r))
                                    }
                                }(e[r[o].parent][o], n),
                                o = r[o].parent;
                            return n.conversion = a,
                            n
                        }(t, r))
                    }
                    return a
                }
            }()
              , r = {};
            return Object.keys(e).forEach(a => {
                r[a] = {},
                Object.defineProperty(r[a], "channels", {
                    value: e[a].channels
                }),
                Object.defineProperty(r[a], "labels", {
                    value: e[a].labels
                });
                let n = t(a);
                Object.keys(n).forEach(e => {
                    let t = n[e];
                    r[a][e] = function(e) {
                        let t = function(...t) {
                            let r = t[0];
                            if (null == r)
                                return r;
                            r.length > 1 && (t = r);
                            let a = e(t);
                            if ("object" == typeof a)
                                for (let e = a.length, t = 0; t < e; t++)
                                    a[t] = Math.round(a[t]);
                            return a
                        };
                        return "conversion"in e && (t.conversion = e.conversion),
                        t
                    }(t),
                    r[a][e].raw = function(e) {
                        let t = function(...t) {
                            let r = t[0];
                            return null == r ? r : (r.length > 1 && (t = r),
                            e(t))
                        };
                        return "conversion"in e && (t.conversion = e.conversion),
                        t
                    }(t)
                }
                )
            }
            ),
            M = r
        }()) && c.__esModule && Object.prototype.hasOwnProperty.call(c, "default") ? c.default : c;
        function aI({gl: e, type: t, source: r}) {
            let a = e.createShader(t);
            if (null === a)
                throw Error("Cannot create shader");
            if (e.shaderSource(a, r),
            e.compileShader(a),
            !e.getShaderParameter(a, e.COMPILE_STATUS))
                throw console.error("Shader compilation error:", e.getShaderInfoLog(a)),
                e.deleteShader(a),
                Error("Cannot compile shader");
            return a
        }
        function az({gl: e, vertexShaderSource: t, fragmentShaderSource: r, attributesKeys: a, uniformsKeys: n, vertices: o, indices: i}) {
            let l, s;
            let u = function({gl: e, vertexShaderSource: t, fragmentShaderSource: r}) {
                let a = aI({
                    gl: e,
                    type: e.VERTEX_SHADER,
                    source: t
                })
                  , n = aI({
                    gl: e,
                    type: e.FRAGMENT_SHADER,
                    source: r
                })
                  , o = e.createProgram();
                if (e.attachShader(o, a),
                e.attachShader(o, n),
                e.linkProgram(o),
                !e.getProgramParameter(o, e.LINK_STATUS))
                    throw console.error("Error: ", e.getProgramInfoLog(o)),
                    Error("Cannot link shader program");
                return o
            }({
                gl: e,
                vertexShaderSource: t,
                fragmentShaderSource: r
            })
              , p = a.reduce( (t, r) => (t[r] = e.getAttribLocation(u, `a_${r}`),
            t), {})
              , c = n.reduce( (t, r) => (t[r] = function(e, t, r) {
                let a = e.getUniformLocation(t, r);
                if (null === a)
                    throw Error(`Cannot get uniform location for ${r}`);
                return a
            }(e, u, `u_${r}`),
            t), {})
              , h = e.createBuffer();
            return e.bindBuffer(e.ARRAY_BUFFER, h),
            e.bufferData(e.ARRAY_BUFFER, new Float32Array(o), e.STATIC_DRAW),
            void 0 !== i && (l = e.createBuffer(),
            s = i.length,
            e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, l),
            e.bufferData(e.ELEMENT_ARRAY_BUFFER, new Uint16Array(i), e.STATIC_DRAW)),
            {
                shaderProgram: u,
                programInfo: {
                    attributesLocations: p,
                    uniformsLocations: c
                },
                positionBuffer: h,
                indexBuffer: l,
                indexBufferLength: s
            }
        }
        function aj(e) {
            if (!e || "transparent" === e)
                return [1, 1, 1, 0];
            try {
                let t = (n = n ?? document.createElement("canvas").getContext("2d")) ? (n.fillStyle = e,
                n.fillStyle) : "#000000"
                  , r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(t);
                if (null != r && r.length) {
                    let e = !!r[4];
                    return [...a$.hex.rgb(t).map(e => e / 255), e ? parseInt(r[4], 16) / 255 : 1]
                }
                let a = t.match(/(\d\.\d(\d+)?|\d{3}|\d{2}|\d{1})/gi) ?? ["0", "0", "0"];
                if (t.includes("rgb")) {
                    let e = t.includes("rgba")
                      , r = [...a.map(e => parseFloat(e)).map( (e, t) => t < 3 ? e / 255 : e)];
                    return e || r.push(1),
                    r
                }
            } catch {}
            return console.warn([`[parseColorStringToVec4]: Color ${e} is either not a valid color or its type is not supported, defaulting to black`]),
            [0, 0, 0, 1]
        }
        let aR = [-.5, -.5, .5, .5, -.5, .5, .5, .5, .5, -.5, .5, .5, -.5, -.5, -.5, -.5, .5, -.5, .5, .5, -.5, .5, -.5, -.5, -.5, .5, -.5, -.5, .5, .5, .5, .5, .5, .5, .5, -.5, -.5, -.5, -.5, .5, -.5, -.5, .5, -.5, .5, -.5, -.5, .5, .5, -.5, -.5, .5, .5, -.5, .5, .5, .5, .5, -.5, .5, -.5, -.5, -.5, -.5, -.5, .5, -.5, .5, .5, -.5, .5, -.5]
          , aO = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]
          , aU = `attribute vec3 a_vertexPosition;
varying vec3 vTextureCoord;

uniform mat4 u_projectionMatrix;
uniform mat4 u_modelViewMatrix;
  
void main(void) {
  vTextureCoord = vec3(-a_vertexPosition.x, a_vertexPosition.y, a_vertexPosition.z);
  gl_Position = u_projectionMatrix * u_modelViewMatrix * vec4(a_vertexPosition, 1.0);
}
`
          , aN = `precision mediump float;

varying vec3 vTextureCoord;

%USE_TEXTURE_MACRO_MARKER%

# ifdef USE_TEXTURE
uniform samplerCube u_cubeSampler;
uniform float u_fadeOpacity;
# endif

uniform vec4 u_bgColor;

void main(void) {
  #ifdef USE_TEXTURE
  vec4 texColor = textureCube(u_cubeSampler, vTextureCoord);

    gl_FragColor = mix(
      u_bgColor,
      texColor,
      min(texColor.a, u_fadeOpacity)
    );

    gl_FragColor.a = max(gl_FragColor.a, u_fadeOpacity);

  #else
  gl_FragColor = u_bgColor;
  #endif
}
`;
        var aF = ((s = aF || {}).UNIVERSE_DARK = "universe-dark",
        s);
        let aq = {
            stars: {
                color: "hsl(233,100%,92%)",
                preset: "stars"
            },
            space: {
                color: "hsl(210, 100%, 4%)",
                preset: "space"
            },
            milkyway: {
                color: "hsl(233,100%,92%)",
                preset: "milkyway"
            },
            "milkyway-subtle": {
                color: "hsl(233,100%,92%)",
                preset: "milkyway-subtle"
            },
            "milkyway-bright": {
                color: "hsl(233,100%,92%)",
                preset: "milkyway-bright"
            },
            "milkyway-colored": {
                color: "black",
                preset: "milkyway-colored"
            }
        };
        var aD = ((u = aD || {}).POSITIVE_X = "pX",
        u.NEGATIVE_X = "nX",
        u.POSITIVE_Y = "pY",
        u.NEGATIVE_Y = "nY",
        u.POSITIVE_Z = "pZ",
        u.NEGATIVE_Z = "nZ",
        u);
        let aB = "https://api.maptiler.com/resources/space"
          , aG = ["vertexPosition"]
          , aV = ["projectionMatrix", "modelViewMatrix", "cubeSampler", "bgColor", "fadeOpacity"]
          , aH = "%USE_TEXTURE_MACRO_MARKER%"
          , aX = aq.stars;
        class aK {
            constructor(e) {
                F(this, "id", "Cubemap Layer"),
                F(this, "type", "custom"),
                F(this, "renderingMode", "3d"),
                F(this, "map"),
                F(this, "faces"),
                F(this, "useCubemapTexture", !0),
                F(this, "currentFadeOpacity", 0),
                F(this, "cubeMapNeedsUpdate", !1),
                F(this, "bgColor"),
                F(this, "previousBgColor", [0, 0, 0, 0]),
                F(this, "targetBgColor", [0, 0, 0, 0]),
                F(this, "transitionDelta", 0),
                F(this, "gl"),
                F(this, "cubemap"),
                F(this, "texture"),
                F(this, "currentFacesDefinitionKey", ""),
                F(this, "options"),
                F(this, "imageIsAnimating", !1),
                F(this, "imageFadeInDelta", 0);
                let t = function(e, t) {
                    if (!aZ(e))
                        return {
                            color: "transparent"
                        };
                    if (!0 === e)
                        return t;
                    let r = {
                        ...e
                    };
                    if (e.faces || e.path)
                        return delete r.preset,
                        r;
                    let a = e.preset;
                    if (void 0 !== a && !(a in aq))
                        throw Error(`[CubemapLayer]: Invalid preset "${a}". Available presets: ${Object.keys(aq).join(", ")}`);
                    return {
                        ...r,
                        color: r.color ?? aq[a].color ?? "hsl(233,100%,92%)"
                    }
                }(e, aX);
                this.options = t,
                this.currentFacesDefinitionKey = JSON.stringify(t.faces ?? t.preset ?? t.path),
                this.bgColor = [0, 0, 0, 0],
                this.targetBgColor = aj(t.color),
                this.faces = aW(t),
                this.useCubemapTexture = null !== this.faces
            }
            updateCubemap({facesNeedUpdate: e}={
                facesNeedUpdate: !0
            }) {
                this.useCubemapTexture = null !== this.faces;
                let t = aV.filter(e => "cubeSampler" !== e && "fadeOpacity" !== e || this.useCubemapTexture);
                this.cubemap = az({
                    gl: this.gl,
                    vertexShaderSource: aU,
                    fragmentShaderSource: this.useCubemapTexture ? aN.replace(aH, "#define USE_TEXTURE") : aN.replace(aH, ""),
                    attributesKeys: aG,
                    uniformsKeys: t,
                    vertices: aR,
                    indices: aO
                }),
                this.cubeMapNeedsUpdate = e,
                this.useCubemapTexture && this.updateTexture(this.gl, this.faces),
                this.animateColorChange()
            }
            onAdd(e, t) {
                this.map = e,
                this.gl = t,
                this.updateCubemap()
            }
            onRemove(e, t) {
                this.cubemap && (t.deleteProgram(this.cubemap.shaderProgram),
                t.deleteBuffer(this.cubemap.positionBuffer))
            }
            updateTexture(e, t) {
                !0 === this.cubeMapNeedsUpdate && !this.imageIsAnimating && (this.cubeMapNeedsUpdate = !1,
                this.useCubemapTexture && function({gl: e, faces: t, onReady: r, forceRefresh: a}) {
                    o && !a && l === JSON.stringify(t) && r(o, i),
                    l = JSON.stringify(t);
                    let n = o ?? e.createTexture();
                    if (e.bindTexture(e.TEXTURE_CUBE_MAP, n),
                    !t) {
                        console.warn("[CubemapLayer][loadCubemapTexture]: Faces are null");
                        return
                    }
                    let s = Object.keys(t).length;
                    if (6 !== s) {
                        console.warn(`[CubemapLayer][loadCubemapTexture]: Faces should contain exactly 6 images, but found ${s}`);
                        return
                    }
                    Promise.all(Object.entries(t).map( ([e,t]) => new Promise( (r, a) => {
                        if (void 0 === t) {
                            a(Error(`[CubemapLayer][loadCubemapTexture]: Face ${e} is undefined`));
                            return
                        }
                        let n = new Image;
                        n.crossOrigin = "anonymous";
                        let o = () => {
                            r({
                                image: n,
                                key: e
                            })
                        }
                        ;
                        n.src = t,
                        n.complete && n.naturalWidth > 0 ? o() : n.onload = o,
                        n.onerror = () => {
                            a(Error(`[CubemapLayer][loadCubemapTexture]: Error loading image ${t}`))
                        }
                    }
                    ))).then(t => {
                        for (let r = 0; r < t.length; r++) {
                            let a = e.RGBA
                              , o = e.RGBA
                              , i = e.UNSIGNED_BYTE
                              , {image: l, key: s} = t[r] ?? {};
                            if (!l || !s) {
                                console.warn("[CubemapLayer][loadCubemapTexture]: Image or key is null");
                                continue
                            }
                            let u = function(e, t) {
                                if (t === aD.POSITIVE_X)
                                    return e.TEXTURE_CUBE_MAP_POSITIVE_X;
                                if (t === aD.NEGATIVE_X)
                                    return e.TEXTURE_CUBE_MAP_NEGATIVE_X;
                                if (t === aD.POSITIVE_Y)
                                    return e.TEXTURE_CUBE_MAP_POSITIVE_Y;
                                if (t === aD.NEGATIVE_Y)
                                    return e.TEXTURE_CUBE_MAP_NEGATIVE_Y;
                                if (t === aD.POSITIVE_Z)
                                    return e.TEXTURE_CUBE_MAP_POSITIVE_Z;
                                if (t === aD.NEGATIVE_Z)
                                    return e.TEXTURE_CUBE_MAP_NEGATIVE_Z;
                                throw Error(`[CubemapLayer][loadCubemapTexture]: Invalid key ${t}`)
                            }(e, s);
                            e.bindTexture(e.TEXTURE_CUBE_MAP, n),
                            e.texParameteri(e.TEXTURE_CUBE_MAP, e.TEXTURE_MAG_FILTER, e.LINEAR),
                            e.texParameteri(e.TEXTURE_CUBE_MAP, e.TEXTURE_MIN_FILTER, e.LINEAR),
                            e.texParameteri(e.TEXTURE_CUBE_MAP, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
                            e.texParameteri(e.TEXTURE_CUBE_MAP, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
                            e.texImage2D(u, 0, a, o, i, l)
                        }
                        e.bindTexture(e.TEXTURE_CUBE_MAP, n),
                        e.generateMipmap(e.TEXTURE_CUBE_MAP),
                        e.texParameteri(e.TEXTURE_CUBE_MAP, e.TEXTURE_MIN_FILTER, e.LINEAR_MIPMAP_LINEAR),
                        e.texParameteri(e.TEXTURE_CUBE_MAP, e.TEXTURE_MAG_FILTER, e.LINEAR);
                        let a = t.map(e => e.image);
                        r(n, a),
                        i = a,
                        o = n
                    }
                    ).catch(e => {
                        console.error("[CubemapLayer][loadCubemapTexture]: Error loading cubemap texture", e)
                    }
                    )
                }({
                    gl: e,
                    faces: t,
                    onReady: e => {
                        this.texture = e,
                        this.animateIn()
                    }
                }))
            }
            prerender(e, t) {
                this.faces && this.updateTexture(this.gl, this.faces)
            }
            animateColorChange() {
                let e = () => {
                    var t, r, a, n, o, i, l;
                    this.transitionDelta < 1 && (requestAnimationFrame(e),
                    this.bgColor = (t = this.previousBgColor,
                    r = this.targetBgColor,
                    a = this.transitionDelta,
                    [(n = t[0],
                    n + (r[0] - n) * a), (o = t[1],
                    o + (r[1] - o) * a), (i = t[2],
                    i + (r[2] - i) * a), (l = t[3],
                    l + (r[3] - l) * a)]),
                    this.transitionDelta += .075,
                    this.map.triggerRepaint())
                }
                ;
                requestAnimationFrame(e)
            }
            animateIn() {
                if (this.imageIsAnimating)
                    return;
                this.imageIsAnimating = !0;
                let e = () => {
                    if (this.imageFadeInDelta = Math.min(this.imageFadeInDelta + .05, 1),
                    this.currentFadeOpacity = 0 + 1 * this.imageFadeInDelta,
                    this.map.triggerRepaint(),
                    this.imageFadeInDelta < 1) {
                        requestAnimationFrame(e);
                        return
                    }
                    this.imageIsAnimating = !1,
                    this.imageFadeInDelta = 0
                }
                ;
                requestAnimationFrame(e)
            }
            animateOut() {
                return this.imageIsAnimating ? Promise.resolve() : new Promise(e => {
                    let t = () => {
                        if (this.imageFadeInDelta = Math.min(this.imageFadeInDelta + .05, 1),
                        this.currentFadeOpacity = 1 + -1 * this.imageFadeInDelta,
                        this.map.triggerRepaint(),
                        this.imageFadeInDelta >= 1) {
                            this.imageIsAnimating = !1,
                            this.imageFadeInDelta = 0,
                            e();
                            return
                        }
                        requestAnimationFrame(t)
                    }
                    ;
                    requestAnimationFrame(t)
                }
                )
            }
            render(e, t) {
                var r, a, n, o, i, l, s, u, p, c, h;
                if (!this.map.isGlobeProjection())
                    return;
                if (void 0 === this.map)
                    throw Error("[CubemapLayer]: Map is undefined");
                if (void 0 === this.cubemap)
                    throw Error("[CubemapLayer]: Cubemap is undefined");
                this.texture,
                e.disable(e.DEPTH_TEST),
                e.enable(e.BLEND),
                e.blendFunc(e.SRC_ALPHA, e.DST_ALPHA),
                e.useProgram(this.cubemap.shaderProgram),
                e.bindBuffer(e.ARRAY_BUFFER, this.cubemap.positionBuffer),
                e.vertexAttribPointer(this.cubemap.programInfo.attributesLocations.vertexPosition, 3, e.FLOAT, !1, 0, 0),
                e.enableVertexAttribArray(this.cubemap.programInfo.attributesLocations.vertexPosition);
                let d = e.canvas
                  , f = d.clientWidth / d.clientHeight
                  , m = this.map.transform
                  , y = m.fov * (Math.PI / 180)
                  , g = a_();
                aA(g, y, f, .1, 1e4),
                aE(g, g, m.rollInRadians),
                aC(g, g, -m.pitchInRadians),
                aE(g, g, m.bearingInRadians);
                let v = m.center.lat * Math.PI / 180
                  , b = m.center.lng * Math.PI / 180;
                aC(g, g, v),
                a = Math.sin(r = -b),
                n = Math.cos(r),
                o = g[0],
                i = g[1],
                l = g[2],
                s = g[3],
                u = g[8],
                p = g[9],
                c = g[10],
                h = g[11],
                g != g && (g[4] = g[4],
                g[5] = g[5],
                g[6] = g[6],
                g[7] = g[7],
                g[12] = g[12],
                g[13] = g[13],
                g[14] = g[14],
                g[15] = g[15]),
                g[0] = o * n - u * a,
                g[1] = i * n - p * a,
                g[2] = l * n - c * a,
                g[3] = s * n - h * a,
                g[8] = o * a + u * n,
                g[9] = i * a + p * n,
                g[10] = l * a + c * n,
                g[11] = s * a + h * n,
                e.uniformMatrix4fv(this.cubemap.programInfo.uniformsLocations.projectionMatrix, !1, g);
                let x = a_();
                if (e.uniformMatrix4fv(this.cubemap.programInfo.uniformsLocations.modelViewMatrix, !1, x),
                e.uniform4fv(this.cubemap.programInfo.uniformsLocations.bgColor, new Float32Array(this.bgColor)),
                e.uniform1f(this.cubemap.programInfo.uniformsLocations.fadeOpacity, this.currentFadeOpacity),
                this.useCubemapTexture && this.texture && (e.activeTexture(e.TEXTURE0),
                e.bindTexture(e.TEXTURE_CUBE_MAP, this.texture),
                e.uniform1i(this.cubemap.programInfo.uniformsLocations.cubeSampler, 0)),
                void 0 === this.cubemap.indexBuffer)
                    throw Error("Index buffer is undefined");
                if (void 0 === this.cubemap.indexBufferLength)
                    throw Error("Index buffer length is undefined");
                e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.cubemap.indexBuffer),
                e.drawElements(e.TRIANGLES, this.cubemap.indexBufferLength, e.UNSIGNED_SHORT, 0)
            }
            setBgColor(e) {
                this.targetBgColor = e,
                this.previousBgColor = this.bgColor,
                this.transitionDelta = 0
            }
            getConfig() {
                return this.options
            }
            async setCubemapFaces(e) {
                if (await this.animateOut(),
                !e.faces && !e.preset && !e.path) {
                    this.faces = null,
                    this.useCubemapTexture = !1,
                    this.currentFacesDefinitionKey = "empty",
                    this.animateIn();
                    return
                }
                this.faces = aW(e),
                this.currentFacesDefinitionKey = JSON.stringify(e.faces ?? e.preset ?? e.path)
            }
            async setCubemap(e) {
                this.options = e;
                let t = JSON.stringify(e.faces ?? e.preset ?? e.path)
                  , r = this.currentFacesDefinitionKey !== t;
                r && (await this.setCubemapFaces(e),
                this.cubeMapNeedsUpdate = !0);
                let a = aj(e.color);
                if (e.color && this.targetBgColor.toString() !== a.toString())
                    this.setBgColor(a);
                else if (!e.color && e.preset && e.preset in aq) {
                    let t = aq[e.preset];
                    this.setBgColor(aj(t.color))
                }
                this.updateCubemap({
                    facesNeedUpdate: r
                })
            }
            show() {
                this.map.setLayoutProperty(this.id, "visibility", "visible")
            }
            hide() {
                this.map.setLayoutProperty(this.id, "visibility", "none")
            }
        }
        function aZ(e) {
            return "boolean" == typeof e || !(!e.path && !e.preset && !e.faces && !e.color || e.preset && !(e.preset in aq) || e.faces && (!e.faces.pX || !e.faces.nX || !e.faces.pY || !e.faces.nY || !e.faces.pZ || !e.faces.nZ))
        }
        function aW(e) {
            if (e.faces)
                return e.faces;
            if (e.preset)
                return {
                    pX: `${aB}/${e.preset}/px.webp`,
                    nX: `${aB}/${e.preset}/nx.webp`,
                    pY: `${aB}/${e.preset}/py.webp`,
                    nY: `${aB}/${e.preset}/ny.webp`,
                    pZ: `${aB}/${e.preset}/pz.webp`,
                    nZ: `${aB}/${e.preset}/nz.webp`
                };
            if (e.path) {
                let t = e.path.baseUrl
                  , r = e.path.format ?? "png";
                return {
                    pX: `${t}/px.${r}`,
                    nX: `${t}/nx.${r}`,
                    pY: `${t}/py.${r}`,
                    nY: `${t}/ny.${r}`,
                    pZ: `${t}/pz.${r}`,
                    nZ: `${t}/nz.${r}`
                }
            }
            return null
        }
        let aY = `attribute vec3 a_position;

uniform mat4 u_matrix;
uniform mat4 u_rotationMatrix;

uniform float u_scale;

varying vec2 v_pos;
varying float v_scale;

void main() {
  v_scale = u_scale;
  v_pos = a_position.xy * u_scale;
  gl_Position = u_matrix * u_rotationMatrix * vec4(a_position, 1.0);
}
`
          , aJ = `precision mediump float;
varying vec2 v_pos;
      
uniform int u_stopsNumber;
uniform float u_stops[100];
uniform vec4 u_colors[100];
uniform float u_maxDistance;

varying float v_scale;

vec2 center = vec2(0.0, 0.0);
// TODO: We could look at implementing a color ramp instead.
// Render the color ramp to a canvas and then to a texture
// then select the color based on the distance from the center.
void main() {

  // QUASI SUCCESS
  // float distanceFromGlobeEdge = (distance(center, v_pos) - 2.0) / (sqrt(v_scale) * 1.05) + 1.0;
  // ORIGINAL
  // float distanceFromGlobeEdge = distance(center, v_pos) - 1.0; 
  float rawDistance = distance(center, v_pos);
  float distanceFromGlobeEdge = rawDistance - 1.0;

    vec4 color = u_colors[0];

  // if we're further than the max distance, we should not render anything.
  // This is to always render a circle, otherwise we end up rendering
  // to the corners of the plane.
  if (distance(center, v_pos) > u_maxDistance * v_scale) {
    discard;
  }

  for (int i = 1; i < 100; i++) {
    // if we're past the last stop
    // we should fill to the end with the last stop color
    if (i >= u_stopsNumber) {
      color = u_colors[i - 1];
      break;
    }

    float scaledStopPosition = u_stops[i] * pow(v_scale, 1.6);
    float lastScaledStopPosition = u_stops[i - 1] * pow(v_scale, 1.6);

    if (distanceFromGlobeEdge <= scaledStopPosition) {
      float stopBlendFactor = (distanceFromGlobeEdge - lastScaledStopPosition) / (scaledStopPosition - lastScaledStopPosition);
      color = mix(u_colors[i - 1], u_colors[i], stopBlendFactor);
      break;
    }
  }
  
  // gl_FragColor = color;
  gl_FragColor = vec4(color.rgb * color.a, color.a);
}
`
          , aQ = ["position"]
          , a0 = ["matrix", "rotationMatrix", "stopsNumber", "stops", "colors", "maxDistance", "scale"]
          , a1 = [-2, -2, 0, 2, -2, 0, -2, 2, 0, 2, 2, 0]
          , a2 = {
            scale: .9,
            stops: [[0, "rgba(176, 208, 240, 1)"], [.1, "rgba(98, 168, 229, 0.3)"], [.2, "rgba(98, 168, 229, 0.0)"]]
        };
        class a5 {
            constructor(e) {
                if (F(this, "id", "Halo Layer"),
                F(this, "type", "custom"),
                F(this, "renderingMode", "3d"),
                F(this, "gradient"),
                F(this, "scale", 0),
                F(this, "animationDelta", 0),
                F(this, "map"),
                F(this, "plane"),
                "boolean" == typeof e) {
                    this.gradient = a2;
                    return
                }
                this.gradient = {
                    ...a2,
                    ...e
                }
            }
            onAdd(e, t) {
                this.map = e,
                this.plane = az({
                    gl: t,
                    vertexShaderSource: aY,
                    fragmentShaderSource: aJ,
                    attributesKeys: aQ,
                    uniformsKeys: a0,
                    vertices: a1
                }),
                this.animateIn()
            }
            getConfig() {
                return this.gradient
            }
            async animateIn() {
                return new Promise(e => {
                    this.animationDelta = 0;
                    let t = () => {
                        if (this.animationDelta < 1) {
                            this.scale = 0 + (this.gradient.scale - 0) * this.animationDelta,
                            this.animationDelta += .06,
                            this.map.triggerRepaint(),
                            requestAnimationFrame(t);
                            return
                        }
                        e()
                    }
                    ;
                    t()
                }
                )
            }
            async animateOut() {
                return this.animationDelta = 0,
                new Promise(e => {
                    let t = () => {
                        if (this.animationDelta < 1) {
                            var r;
                            this.scale = (r = this.gradient.scale) + (0 - r) * this.animationDelta,
                            this.animationDelta += .06,
                            this.map.triggerRepaint(),
                            requestAnimationFrame(t);
                            return
                        }
                        e()
                    }
                    ;
                    t()
                }
                )
            }
            onRemove(e, t) {
                void 0 !== this.plane && (t.deleteProgram(this.plane.shaderProgram),
                t.deleteBuffer(this.plane.positionBuffer))
            }
            prerender(e, t) {}
            render(e, t) {
                var r, a, n, o, i, l, s, u, p, c, h, d, f, m, y, g, v, b, x, w, S, k, _, C, E, A, L, T, M, P, $, I, z, j, R;
                if (void 0 === this.map)
                    throw Error("[RadialGradientLayer]: Map is undefined");
                if (!this.map.isGlobeProjection())
                    return;
                if (void 0 === this.plane)
                    throw Error("[RadialGradientLayer]: Plane is undefined");
                e.disable(e.DEPTH_TEST),
                e.enable(e.BLEND),
                e.useProgram(this.plane.shaderProgram),
                e.bindBuffer(e.ARRAY_BUFFER, this.plane.positionBuffer);
                let O = this.plane.programInfo.attributesLocations.position;
                e.enableVertexAttribArray(O),
                e.vertexAttribPointer(O, 3, e.FLOAT, !1, 0, 0);
                let U = a_()
                  , N = this.scale;
                a = (r = [N, N, N])[0],
                n = r[1],
                o = r[2],
                U[0] = U[0] * a,
                U[1] = U[1] * a,
                U[2] = U[2] * a,
                U[3] = U[3] * a,
                U[4] = U[4] * n,
                U[5] = U[5] * n,
                U[6] = U[6] * n,
                U[7] = U[7] * n,
                U[8] = U[8] * o,
                U[9] = U[9] * o,
                U[10] = U[10] * o,
                U[11] = U[11] * o,
                U[12] = U[12],
                U[13] = U[13],
                U[14] = U[14],
                U[15] = U[15];
                let F = a_();
                l = (i = t.defaultProjectionData.mainMatrix)[0],
                s = i[1],
                u = i[2],
                p = i[3],
                c = i[4],
                h = i[5],
                d = i[6],
                f = i[7],
                m = i[8],
                y = i[9],
                g = i[10],
                v = i[11],
                b = i[12],
                x = i[13],
                w = i[14],
                S = i[15],
                k = U[0],
                _ = U[1],
                C = U[2],
                E = U[3],
                F[0] = k * l + _ * c + C * m + E * b,
                F[1] = k * s + _ * h + C * y + E * x,
                F[2] = k * u + _ * d + C * g + E * w,
                F[3] = k * p + _ * f + C * v + E * S,
                k = U[4],
                _ = U[5],
                C = U[6],
                E = U[7],
                F[4] = k * l + _ * c + C * m + E * b,
                F[5] = k * s + _ * h + C * y + E * x,
                F[6] = k * u + _ * d + C * g + E * w,
                F[7] = k * p + _ * f + C * v + E * S,
                k = U[8],
                _ = U[9],
                C = U[10],
                E = U[11],
                F[8] = k * l + _ * c + C * m + E * b,
                F[9] = k * s + _ * h + C * y + E * x,
                F[10] = k * u + _ * d + C * g + E * w,
                F[11] = k * p + _ * f + C * v + E * S,
                k = U[12],
                _ = U[13],
                C = U[14],
                E = U[15],
                F[12] = k * l + _ * c + C * m + E * b,
                F[13] = k * s + _ * h + C * y + E * x,
                F[14] = k * u + _ * d + C * g + E * w,
                F[15] = k * p + _ * f + C * v + E * S;
                let q = this.plane.programInfo.uniformsLocations.matrix;
                e.uniformMatrix4fv(q, !1, F);
                let D = a_()
                  , B = this.map.transform.cameraPosition
                  , G = aT(aL(), B)
                  , V = ((A = new ak(3))[0] = 0,
                A[1] = 1,
                A[2] = 0,
                A)
                  , H = aL();
                aM(H, V, G),
                aT(H, H);
                let X = aL();
                aM(X, G, H),
                aT(X, X),
                L = H[0],
                T = H[1],
                M = H[2],
                P = X[0],
                $ = X[1],
                I = X[2],
                z = G[0],
                j = G[1],
                R = G[2],
                D[0] = L,
                D[1] = T,
                D[2] = M,
                D[3] = 0,
                D[4] = P,
                D[5] = $,
                D[6] = I,
                D[7] = 0,
                D[8] = z,
                D[9] = j,
                D[10] = R,
                D[11] = 0,
                D[12] = 0,
                D[13] = 0,
                D[14] = 0,
                D[15] = 1;
                let K = this.plane.programInfo.uniformsLocations.rotationMatrix;
                e.uniformMatrix4fv(K, !1, D);
                let Z = this.gradient.stops.length
                  , W = []
                  , Y = [];
                for (let e = 0; e <= Z; e++)
                    if (e < Z) {
                        W[e] = this.gradient.stops[e][0];
                        let t = aj(this.gradient.stops[e][1]);
                        Y.push(...t)
                    }
                e.uniform1i(this.plane.programInfo.uniformsLocations.stopsNumber, Z),
                e.uniform1fv(this.plane.programInfo.uniformsLocations.stops, new Float32Array(W)),
                e.uniform4fv(this.plane.programInfo.uniformsLocations.colors, new Float32Array(Y)),
                e.uniform1f(this.plane.programInfo.uniformsLocations.maxDistance, 2),
                e.uniform1f(this.plane.programInfo.uniformsLocations.scale, N),
                e.drawArrays(e.TRIANGLE_STRIP, 0, 4)
            }
            async setGradient(e) {
                if (await this.animateOut(),
                !("boolean" == typeof e || !("number" != typeof e.scale || !e.stops || 0 === e.stops.length || e.stops.some(e => "number" != typeof e[0] || "string" != typeof e[1])))) {
                    this.gradient.scale = a2.scale,
                    this.gradient.stops = [[0, "transparent"], [1, "transparent"]];
                    return
                }
                this.gradient.scale = e.scale ?? a2.scale,
                this.gradient.stops = e.stops ?? a2.stops,
                await this.animateIn()
            }
            show() {
                this.map.setLayoutProperty(this.id, "visibility", "visible")
            }
            hide() {
                this.map.setLayoutProperty(this.id, "visibility", "none")
            }
        }
        let a3 = {
            COUNTRY: "COUNTRY"
        }
          , a4 = class e extends $.Map {
            constructor(e) {
                (function(e) {
                    let t = document.createElement("canvas").getContext("webgl2") ? null : "u" > typeof WebGL2RenderingContext ? "Graphic rendering with WebGL2 has been disabled or is not supported by your graphic card. The map cannot be displayed." : "Your browser does not support graphic rendering with WebGL2. The map cannot be displayed.";
                    if (!t)
                        return;
                    let r = null;
                    if ("string" == typeof e ? r = document.getElementById(e) : e instanceof HTMLElement && (r = e),
                    !r)
                        throw Error("The Map container must be provided.");
                    let a = document.createElement("div");
                    throw a.innerHTML = t,
                    a.classList.add("webgl-warning-div"),
                    r.appendChild(a),
                    Error(t)
                }
                )(e.container),
                e.apiKey && (Y.apiKey = e.apiKey);
                let {style: t, requiresUrlMonitoring: r, isFallback: a} = ac(e.style);
                a && console.warn("Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Fallback to default MapTiler style."),
                Y.apiKey || console.warn("MapTiler Cloud API key is not set. Visit https://maptiler.com and try Cloud for free!");
                let n = location.hash
                  , o = {
                    compact: !1
                };
                e.customAttribution ? o.customAttribution = e.customAttribution : e.attributionControl && "object" == typeof e.attributionControl && (o = {
                    ...o,
                    ...e.attributionControl
                });
                let i = {
                    ...e,
                    style: t,
                    maplibreLogo: !1,
                    transformRequest: ei(e.transformRequest),
                    attributionControl: !0 !== e.forceNoAttributionControl && o
                };
                delete i.style,
                super(i),
                F(this, "telemetry"),
                F(this, "space"),
                F(this, "halo"),
                F(this, "options"),
                F(this, "isTerrainEnabled", !1),
                F(this, "terrainExaggeration", 1),
                F(this, "primaryLanguage"),
                F(this, "terrainGrowing", !1),
                F(this, "terrainFlattening", !1),
                F(this, "minimap"),
                F(this, "forceLanguageUpdate"),
                F(this, "languageAlwaysBeenStyle"),
                F(this, "isReady", !1),
                F(this, "terrainAnimationDuration", 1e3),
                F(this, "monitoredStyleUrls"),
                F(this, "styleInProcess", !1),
                F(this, "curentProjection"),
                F(this, "originalLabelStyle", new window.Map),
                F(this, "isStyleLocalized", !1),
                F(this, "languageIsUpdated", !1),
                F(this, "spaceboxLoadingState", {
                    styleLoadCallbackSet: !1
                }),
                this.options = e,
                this.setStyle(t),
                r && this.monitorStyleUrl(t);
                let l = () => {
                    let e = "The distant style could not be loaded.";
                    this.getStyle() ? e += "Leaving the style as is." : (this.setStyle(I.UH.STREETS),
                    e += `Loading default MapTiler Cloud style "${I.UH.STREETS.getDefaultVariant().getId()}" as a fallback.`),
                    console.warn(e)
                }
                ;
                if (this.on("style.load", () => {
                    this.styleInProcess = !1
                }
                ),
                this.on("error", e => {
                    if (e.error instanceof $.AJAXError) {
                        let t = new URL(e.error.url);
                        t.search = "";
                        let r = t.href;
                        this.monitoredStyleUrls && this.monitoredStyleUrls.has(r) && (this.monitoredStyleUrls.delete(r),
                        l());
                        return
                    }
                    if (this.styleInProcess) {
                        l();
                        return
                    }
                }
                ),
                Y.caching && !ee && console.warn("The cache API is only available in secure contexts. More info at https://developer.mozilla.org/en-US/docs/Web/API/Cache"),
                Y.caching && ee && (et(J, async (e, t) => {
                    if (!e.url)
                        throw Error("");
                    e.url = e.url.replace(`${J}://`, "https://"),
                    e.signal = t.signal;
                    let r = await fetch(e.url, e)
                      , a = await r.json();
                    return a.tiles && a.tiles.length > 0 && (a.tiles[0] += `&last-modified=${r.headers.get("Last-Modified")}`),
                    {
                        data: a,
                        cacheControl: r.headers.get("Cache-Control"),
                        expires: r.headers.get("Expires")
                    }
                }
                ),
                et(Q, async (e, t) => {
                    if (!e.url)
                        throw Error("");
                    e.url = e.url.replace(`${Q}://`, "https://");
                    let r = new URL(e.url)
                      , a = new URL(r);
                    a.searchParams.delete("mtsid"),
                    a.searchParams.delete("key");
                    let n = a.toString()
                      , o = new URL(r);
                    o.searchParams.delete("last-modified");
                    let i = o.toString()
                      , l = async e => ({
                        data: await e.arrayBuffer(),
                        cacheControl: e.headers.get("Cache-Control"),
                        expires: e.headers.get("Expires")
                    })
                      , s = await er()
                      , u = await s.match(n);
                    if (u)
                        return l(u);
                    e.signal = t.signal;
                    let p = await fetch(i, e);
                    return p.status >= 200 && p.status < 300 && (s.put(n, p.clone()).catch( () => {}
                    ),
                    ++ea > 100 && (en(),
                    ea = 0)),
                    l(p)
                }
                )),
                typeof e.language > "u")
                    this.primaryLanguage = Y.primaryLanguage;
                else {
                    let t = (0,
                    I.eS)(e.language, H);
                    this.primaryLanguage = t ?? Y.primaryLanguage
                }
                this.forceLanguageUpdate = !(this.primaryLanguage === H.STYLE || this.primaryLanguage === H.STYLE_LOCK),
                this.languageAlwaysBeenStyle = this.primaryLanguage === H.STYLE,
                this.terrainExaggeration = e.terrainExaggeration ?? this.terrainExaggeration,
                this.curentProjection = e.projection,
                this.on("styledata", () => {
                    "mercator" === this.curentProjection ? this.setProjection({
                        type: "mercator"
                    }) : "globe" === this.curentProjection && this.setProjection({
                        type: "globe"
                    })
                }
                ),
                this.once("styledata", async () => {
                    let t;
                    if (e.geolocate && !e.center && (!e.hash || !n)) {
                        try {
                            if (e.geolocate === a3.COUNTRY) {
                                await this.fitToIpBounds();
                                return
                            }
                        } catch (e) {
                            console.warn(e.message)
                        }
                        try {
                            await this.centerOnIpPoint(e.zoom),
                            t = this.getCameraHash()
                        } catch (e) {
                            console.warn(e.message)
                        }
                        "granted" === (await navigator.permissions.query({
                            name: "geolocation"
                        })).state && navigator.geolocation.getCurrentPosition(r => {
                            t === this.getCameraHash() && (this.terrain ? this.easeTo({
                                center: [r.coords.longitude, r.coords.latitude],
                                zoom: e.zoom || 12,
                                duration: 2e3
                            }) : this.once("terrain", () => {
                                this.easeTo({
                                    center: [r.coords.longitude, r.coords.latitude],
                                    zoom: e.zoom || 12,
                                    duration: 2e3
                                })
                            }
                            ))
                        }
                        , null, {
                            maximumAge: 864e5,
                            timeout: 5e3,
                            enableHighAccuracy: !1
                        })
                    }
                }
                ),
                this.on("styledata", () => {
                    this.setPrimaryLanguage(this.primaryLanguage)
                }
                ),
                this.on("styledata", () => {
                    null === this.getTerrain() && this.isTerrainEnabled && this.enableTerrain(this.terrainExaggeration)
                }
                ),
                this.once("load", async () => {
                    let t = {
                        logo: null
                    };
                    try {
                        let e = Object.keys(this.style.sourceCaches).map(e => this.getSource(e)).filter(e => e && "url"in e && "string" == typeof e.url && e.url.includes("tiles.json"))
                          , r = new URL(e[0].url);
                        r.searchParams.has("key") || r.searchParams.append("key", Y.apiKey),
                        t = await (await fetch(r.href)).json()
                    } catch {}
                    if (!0 !== e.forceNoAttributionControl) {
                        if ("logo"in t && t.logo) {
                            let r = t.logo;
                            this.addControl(new ef({
                                logoURL: r
                            }), e.logoPosition)
                        } else
                            e.maptilerLogo && this.addControl(new ef, e.logoPosition)
                    }
                    if (e.scaleControl) {
                        let t = !0 === e.scaleControl || void 0 === e.scaleControl ? "bottom-right" : e.scaleControl
                          , r = new eh({
                            unit: Y.unit
                        });
                        this.addControl(r, t),
                        Y.on("unit", e => {
                            r.setUnit(e)
                        }
                        )
                    }
                    if (!1 !== e.navigationControl) {
                        let t = !0 === e.navigationControl || void 0 === e.navigationControl ? "top-right" : e.navigationControl;
                        this.addControl(new am, t)
                    }
                    if (!1 !== e.geolocateControl) {
                        let t = !0 === e.geolocateControl || void 0 === e.geolocateControl ? "top-right" : e.geolocateControl;
                        this.addControl(new ab({
                            positionOptions: {
                                enableHighAccuracy: !0,
                                maximumAge: 0,
                                timeout: 6e3
                            },
                            fitBoundsOptions: {
                                maxZoom: 15
                            },
                            trackUserLocation: !0,
                            showAccuracyCircle: !0,
                            showUserLocation: !0
                        }), t)
                    }
                    if (e.terrainControl) {
                        let t = !0 === e.terrainControl || void 0 === e.terrainControl ? "top-right" : e.terrainControl;
                        this.addControl(new af, t)
                    }
                    if (e.projectionControl) {
                        let t = !0 === e.projectionControl || void 0 === e.projectionControl ? "top-right" : e.projectionControl;
                        this.addControl(new aw, t)
                    }
                    if (e.fullscreenControl) {
                        let t = !0 === e.fullscreenControl || void 0 === e.fullscreenControl ? "top-right" : e.fullscreenControl;
                        this.addControl(new ed({}), t)
                    }
                    this.isReady = !0,
                    this.fire("ready", {
                        target: this
                    })
                }
                );
                let s = !1, u = !1, p;
                this.once("ready", () => {
                    s = !0,
                    u && this.fire("loadWithTerrain", p)
                }
                ),
                this.once("style.load", () => {
                    let {minimap: t} = e;
                    if ("object" == typeof t) {
                        let {zoom: r, center: a, style: n, language: o, apiKey: i, maptilerLogo: l, canvasContextAttributes: s, refreshExpiredTiles: u, maxBounds: p, scrollZoom: c, minZoom: h, maxZoom: d, boxZoom: f, locale: m, fadeDuration: y, crossSourceCollisions: g, clickTolerance: v, bounds: b, fitBoundsOptions: x, pixelRatio: w, validateStyle: S} = e;
                        this.minimap = new ax(t,{
                            zoom: r,
                            center: a,
                            style: n,
                            language: o,
                            apiKey: i,
                            container: "null",
                            maptilerLogo: l,
                            canvasContextAttributes: s,
                            refreshExpiredTiles: u,
                            maxBounds: p,
                            scrollZoom: c,
                            minZoom: h,
                            maxZoom: d,
                            boxZoom: f,
                            locale: m,
                            fadeDuration: y,
                            crossSourceCollisions: g,
                            clickTolerance: v,
                            bounds: b,
                            fitBoundsOptions: x,
                            pixelRatio: w,
                            validateStyle: S
                        }),
                        this.addControl(this.minimap, t.position ?? "bottom-left")
                    } else
                        !0 === t ? (this.minimap = new ax({},e),
                        this.addControl(this.minimap, "bottom-left")) : void 0 !== t && !1 !== t && (this.minimap = new ax({},e),
                        this.addControl(this.minimap, t))
                }
                );
                let c = e => {
                    e.terrain && (u = !0,
                    p = {
                        type: "loadWithTerrain",
                        target: this,
                        terrain: e.terrain
                    },
                    this.off("terrain", c),
                    s && this.fire("loadWithTerrain", p))
                }
                ;
                this.on("terrain", c),
                e.terrain && this.enableTerrain(e.terrainExaggeration ?? this.terrainExaggeration),
                this.once("load", () => {
                    this.getCanvas().addEventListener("webglcontextlost", e => {
                        if (!0 === this._removed) {
                            console.warn("[webglcontextlost]", "WebGL context lost after map removal. This is harmless.");
                            return
                        }
                        console.warn("[webglcontextlost]", "Unexpected loss of WebGL context!"),
                        this.fire("webglContextLost", e)
                    }
                    );
                    let t = this.getLayersOrder()[0];
                    e.space && this.initSpace({
                        options: e,
                        before: t
                    }),
                    e.halo && this.initHalo({
                        options: e,
                        before: t
                    })
                }
                ),
                this.telemetry = new aS(this)
            }
            getSpace() {
                return this.space
            }
            setSpace(e) {
                if (this.isGlobeProjection()) {
                    if (this.space) {
                        this.space.setCubemap(e);
                        return
                    }
                    this.space = new aK(e),
                    this.once("load", () => {
                        let e = this.getLayersOrder()[0];
                        this.space && this.addLayer(this.space, e)
                    }
                    )
                }
            }
            setSpaceFromStyle({style: e}) {
                var t, r, a;
                let n = null == (r = null == (t = e.metadata) ? void 0 : t.maptiler) ? void 0 : r.space;
                if (!n || !aZ(n)) {
                    this.setSpace({
                        color: "transparent"
                    });
                    return
                }
                if (JSON.stringify(null == (a = this.space) ? void 0 : a.getConfig()) === JSON.stringify(n)) {
                    if (this.space && !this.getLayer(this.space.id)) {
                        let e = this.getLayersOrder()[0];
                        this.addLayer(this.space, e)
                    }
                    return
                }
                ( () => {
                    if (this.space && this.isGlobeProjection()) {
                        if (!this.getLayer(this.space.id)) {
                            let e = this.getLayersOrder()[0];
                            this.addLayer(this.space, e)
                        }
                        this.space.setCubemap(n)
                    }
                }
                )()
            }
            setHaloFromStyle({style: e}) {
                var t, r, a;
                let n = null == (t = e.metadata) ? void 0 : t.maptiler;
                if (JSON.stringify(null == (r = this.halo) ? void 0 : r.getConfig()) === JSON.stringify(null == n ? void 0 : n.halo)) {
                    if (this.halo && !this.getLayer(this.halo.id)) {
                        let e = this.getLayersOrder().indexOf((null == (a = this.space) ? void 0 : a.id) ?? "") + 1
                          , t = this.getLayersOrder()[e];
                        this.addLayer(this.halo, t)
                    }
                    return
                }
                if (!(null != n && n.halo)) {
                    this.setHalo({
                        stops: [[0, "transparent"], [1, "transparent"]],
                        scale: 1
                    });
                    return
                }
                ( () => {
                    var e;
                    if (this.halo) {
                        if (!this.getLayer(this.halo.id)) {
                            let t = this.getLayersOrder().indexOf((null == (e = this.space) ? void 0 : e.id) ?? "") + 1
                              , r = this.getLayersOrder()[t];
                            this.addLayer(this.halo, r)
                        }
                        this.halo.setGradient(n.halo)
                    }
                }
                )()
            }
            initSpace({options: e=this.options, before: t, spec: r}) {
                if (this.space) {
                    this.getLayer(this.space.id) || this.addLayer(this.space, t);
                    return
                }
                if (!1 !== e.space) {
                    if (e.space) {
                        this.space = new aK(e.space),
                        this.addLayer(this.space, t);
                        return
                    }
                    r && (this.space = new aK(r),
                    this.addLayer(this.space, t))
                }
            }
            initHalo({options: e=this.options, before: t, spec: r}) {
                if (!(this.halo && this.getLayer(this.halo.id)) && !1 !== e.halo) {
                    if (e.halo) {
                        this.halo = new a5(e.halo),
                        this.addLayer(this.halo, t);
                        return
                    }
                    r && (this.halo = new a5(r),
                    this.addLayer(this.halo, t))
                }
            }
            getHalo() {
                return this.halo
            }
            setHalo(e) {
                if (this.isGlobeProjection()) {
                    if (this.halo) {
                        this.halo.setGradient(e);
                        return
                    }
                    this.halo = new a5(e),
                    this.once("load", () => {
                        var e;
                        let t = this.getLayersOrder()
                          , r = t[0]
                          , a = t.indexOf((null == (e = this.space) ? void 0 : e.id) ?? "") + 2
                          , n = t[a];
                        this.halo && this.addLayer(this.halo, this.space ? n : r)
                    }
                    )
                }
            }
            recreate() {
                let t = {
                    center: this.getCenter(),
                    zoom: this.getZoom(),
                    bearing: this.getBearing(),
                    pitch: this.getPitch()
                };
                this.remove(),
                Object.assign(this, new e({
                    ...this.options
                })),
                this.once("load", () => {
                    this.jumpTo(t)
                }
                )
            }
            setTerrainAnimationDuration(e) {
                this.terrainAnimationDuration = Math.max(e, 0)
            }
            async onLoadAsync() {
                return new Promise(e => {
                    if (this.loaded()) {
                        e(this);
                        return
                    }
                    this.once("load", () => {
                        e(this)
                    }
                    )
                }
                )
            }
            async onReadyAsync() {
                return new Promise(e => {
                    if (this.isReady) {
                        e(this);
                        return
                    }
                    this.once("ready", () => {
                        e(this)
                    }
                    )
                }
                )
            }
            async onLoadWithTerrainAsync() {
                return new Promise(e => {
                    if (this.isReady && this.terrain) {
                        e(this);
                        return
                    }
                    this.once("loadWithTerrain", () => {
                        e(this)
                    }
                    )
                }
                )
            }
            monitorStyleUrl(e) {
                typeof this.monitoredStyleUrls > "u" && (this.monitoredStyleUrls = new Set);
                let t = new URL(e);
                t.search = "",
                this.monitoredStyleUrls.add(t.href)
            }
            setStyle(e, t) {
                var r, a, n, o, i;
                this.originalLabelStyle.clear(),
                null == (r = this.minimap) || r.setStyle(e),
                this.forceLanguageUpdate = !0,
                this.once("idle", () => {
                    this.forceLanguageUpdate = !1
                }
                );
                let l = ac(e);
                if (l.requiresUrlMonitoring && this.monitorStyleUrl(l.style),
                l.isFallback) {
                    if (this.getStyle())
                        return console.warn("[Map.setStyle]: Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Keeping the curent style instead."),
                        this;
                    console.warn("[Map.setStyle]: Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Fallback to default MapTiler style.")
                }
                let s = this.getStyle()
                  , u = l.style;
                try {
                    super.setStyle(l.style, t),
                    this.styleInProcess = !0
                } catch (e) {
                    this.styleInProcess = !1,
                    console.error("[Map.setStyle]: Error while setting style:", e)
                }
                if ("string" == typeof l.style || l.requiresUrlMonitoring)
                    return this;
                let p = e => {
                    var t, r, a, n;
                    let o = (null == e ? void 0 : e.target.getStyle()) ?? l.style
                      , i = this.getLayersOrder()[0];
                    this.space ? this.setSpaceFromStyle({
                        style: o
                    }) : this.initSpace({
                        before: i,
                        spec: null == (r = null == (t = o.metadata) ? void 0 : t.maptiler) ? void 0 : r.space
                    }),
                    this.halo ? this.setHaloFromStyle({
                        style: o
                    }) : this.initHalo({
                        before: i,
                        spec: null == (n = null == (a = o.metadata) ? void 0 : a.maptiler) ? void 0 : n.halo
                    })
                }
                ;
                if (this.styleInProcess && !this.spaceboxLoadingState.styleLoadCallbackSet)
                    return this.once("style.load", p),
                    this.once("styledata", p),
                    this.spaceboxLoadingState.styleLoadCallbackSet = !0,
                    this;
                if ((null == (a = null == s ? void 0 : s.terrain) ? void 0 : a.source) !== (null == (n = null == u ? void 0 : u.terrain) ? void 0 : n.source) || (null == (o = null == s ? void 0 : s.terrain) ? void 0 : o.exaggeration) !== (null == (i = null == u ? void 0 : u.terrain) ? void 0 : i.exaggeration))
                    return this.once("terrain", () => {
                        let e = l.style;
                        if (!e.projection || "mercator" === e.projection.type) {
                            console.warn("[Map.setStyle]: Neither space nor halo is supported for mercator projection. Ignoring...");
                            return
                        }
                        this.setSpaceFromStyle({
                            style: l.style
                        }),
                        this.setHaloFromStyle({
                            style: l.style
                        })
                    }
                    ),
                    this;
                try {
                    p()
                } catch {}
                return this
            }
            addLayer(e, t) {
                var r;
                return null == (r = this.minimap) || r.addLayer(e, t),
                super.addLayer(e, t)
            }
            moveLayer(e, t) {
                var r;
                return null == (r = this.minimap) || r.moveLayer(e, t),
                super.moveLayer(e, t)
            }
            removeLayer(e) {
                var t;
                return null == (t = this.minimap) || t.removeLayer(e),
                super.removeLayer(e)
            }
            setLayerZoomRange(e, t, r) {
                var a;
                return null == (a = this.minimap) || a.setLayerZoomRange(e, t, r),
                super.setLayerZoomRange(e, t, r)
            }
            setFilter(e, t, r) {
                var a;
                return null == (a = this.minimap) || a.setFilter(e, t, r),
                super.setFilter(e, t, r)
            }
            setPaintProperty(e, t, r, a) {
                var n;
                return null == (n = this.minimap) || n.setPaintProperty(e, t, r, a),
                super.setPaintProperty(e, t, r, a)
            }
            setLayoutProperty(e, t, r, a) {
                var n;
                return null == (n = this.minimap) || n.setLayoutProperty(e, t, r, a),
                super.setLayoutProperty(e, t, r, a)
            }
            setGlyphs(e, t) {
                var r;
                return null == (r = this.minimap) || r.setGlyphs(e, t),
                super.setGlyphs(e, t)
            }
            getStyleLanguage() {
                return this.style && this.style.stylesheet && this.style.stylesheet.metadata && "object" == typeof this.style.stylesheet.metadata && "maptiler:language"in this.style.stylesheet.metadata && "string" == typeof this.style.stylesheet.metadata["maptiler:language"] ? (0,
                I.S3)(this.style.stylesheet.metadata["maptiler:language"]) : null
            }
            setLanguage(e) {
                var t;
                null == (t = this.minimap) || t.map.setLanguage(e),
                this.onStyleReady( () => {
                    this.setPrimaryLanguage(e)
                }
                )
            }
            setPrimaryLanguage(e) {
                let t = this.getStyleLanguage()
                  , r = (0,
                I.eS)(e, H);
                if (!r) {
                    console.warn(`The language "${r}" is not supported.`);
                    return
                }
                if (!(r.flag === H.STYLE.flag && t && (t.flag === H.AUTO.flag || t.flag === H.VISITOR.flag)) && (r.flag !== H.STYLE.flag && (this.languageAlwaysBeenStyle = !1),
                this.languageAlwaysBeenStyle || this.primaryLanguage === r && !this.forceLanguageUpdate))
                    return;
                if (this.primaryLanguage.flag === H.STYLE_LOCK.flag) {
                    console.warn("The language cannot be changed because this map has been instantiated with the STYLE_LOCK language flag.");
                    return
                }
                this.primaryLanguage = r;
                let a = r;
                if (r.flag === H.STYLE.flag) {
                    if (!t) {
                        console.warn("The style has no default languages or has an invalid one.");
                        return
                    }
                    a = t
                }
                let n = H.LOCAL.flag
                  , o = ["get", n];
                o = a.flag === H.VISITOR.flag ? ["case", ["all", ["has", n = X().flag], ["has", H.LOCAL.flag]], ["case", ["==", ["get", n], ["get", H.LOCAL.flag]], ["get", H.LOCAL.flag], ["format", ["get", n], {
                    "font-scale": .8
                }, `
`, ["get", H.LOCAL.flag], {
                    "font-scale": 1.1
                }]], ["get", H.LOCAL.flag]] : a.flag === H.VISITOR_ENGLISH.flag ? ["case", ["all", ["has", n = H.ENGLISH.flag], ["has", H.LOCAL.flag]], ["case", ["==", ["get", n], ["get", H.LOCAL.flag]], ["get", H.LOCAL.flag], ["format", ["get", n], {
                    "font-scale": .8
                }, `
`, ["get", H.LOCAL.flag], {
                    "font-scale": 1.1
                }]], ["get", H.LOCAL.flag]] : a.flag === H.AUTO.flag ? ["coalesce", ["get", n = X().flag], ["get", H.LOCAL.flag]] : a === H.LOCAL ? ["get", n = H.LOCAL.flag] : ["coalesce", ["get", n = a.flag], ["get", H.LOCAL.flag]];
                let {layers: i} = this.getStyle()
                  , l = 0 === this.originalLabelStyle.size;
                if (l) {
                    let e = function(e, t) {
                        let r = [];
                        for (let a of e) {
                            if ("symbol" !== a.type)
                                continue;
                            let {id: e, layout: n} = a;
                            if (!n || !("text-field"in n))
                                continue;
                            let o = t.getLayoutProperty(e, "text-field");
                            if (o) {
                                if ("string" == typeof o) {
                                    let e = function(e) {
                                        var t;
                                        let r = /\{name(?::(?<language>\S+))?\}/g
                                          , a = [];
                                        for (; ; ) {
                                            let n = r.exec(e);
                                            if (!n)
                                                break;
                                            let o = (null == (t = n.groups) ? void 0 : t.language) ?? null;
                                            a.push(o)
                                        }
                                        return a
                                    }(o);
                                    r.push(e)
                                } else {
                                    let e = function(e) {
                                        let t = []
                                          , r = structuredClone(e)
                                          , a = e => {
                                            if ("string" != typeof e)
                                                for (let n = 0; n < e.length; n += 1) {
                                                    var r;
                                                    let o = Array.isArray(r = e[n]) && 2 === r.length && "get" === r[0] && "string" == typeof r[1] ? "name" === r[1].trim() ? {
                                                        isLanguage: !0,
                                                        localization: null
                                                    } : r[1].trim().startsWith("name:") ? {
                                                        isLanguage: !0,
                                                        localization: r[1].trim().split(":").pop()
                                                    } : null : null;
                                                    o ? t.push(o.localization) : a(e[n])
                                                }
                                        }
                                        ;
                                        return a([r]),
                                        t
                                    }(o);
                                    r.push(e)
                                }
                            }
                        }
                        let a = r.flat()
                          , n = {
                            unlocalized: 0,
                            localized: {}
                        };
                        for (let e of a)
                            null === e ? n.unlocalized += 1 : (e in n.localized || (n.localized[e] = 0),
                            n.localized[e] += 1);
                        return n
                    }(i, this);
                    this.isStyleLocalized = Object.keys(e.localized).length > 0
                }
                for (let e of i) {
                    let t;
                    if ("symbol" !== e.type)
                        continue;
                    let r = this.getSource(e.source);
                    if (!r || !("url"in r && "string" == typeof r.url) || new URL(r.url).host !== K.maptilerApiHost)
                        continue;
                    let {id: a, layout: n} = e;
                    if (n && "text-field"in n) {
                        if (l ? (t = this.getLayoutProperty(a, "text-field"),
                        this.originalLabelStyle.set(a, t)) : t = this.originalLabelStyle.get(a),
                        "string" == typeof t) {
                            let {contains: e, exactMatch: r} = function(e, t) {
                                let r = t ? /\{name:\S+\}/ : /\{name\}/;
                                return {
                                    contains: r.test(e),
                                    exactMatch: RegExp(`^${r.source}$`).test(e)
                                }
                            }(t, this.isStyleLocalized);
                            if (!e)
                                continue;
                            if (r)
                                this.setLayoutProperty(a, "text-field", o);
                            else {
                                let e = function(e, t, r) {
                                    let a = e.split(r ? /\{name:\S+\}/ : /\{name\}/);
                                    return ["concat", ...a.flatMap( (e, r) => r === a.length - 1 ? [e] : [e, t])]
                                }(t, o, this.isStyleLocalized);
                                this.setLayoutProperty(a, "text-field", e)
                            }
                        } else {
                            let e = function(e, t, r) {
                                let a = structuredClone(e)
                                  , n = e => {
                                    if ("string" != typeof e)
                                        for (let a = 0; a < e.length; a += 1)
                                            el(e[a], r) ? e[a] = structuredClone(t) : n(e[a])
                                }
                                ;
                                return el(a, r) ? t : (n(a),
                                a)
                            }(t, o, this.isStyleLocalized);
                            this.setLayoutProperty(a, "text-field", e)
                        }
                    }
                }
                this.languageIsUpdated = !0
            }
            getPrimaryLanguage() {
                return this.primaryLanguage
            }
            getTerrainExaggeration() {
                return this.terrainExaggeration
            }
            hasTerrain() {
                return this.isTerrainEnabled
            }
            growTerrain(e) {
                if (!this.terrain)
                    return;
                let t = performance.now()
                  , r = this.terrain.exaggeration
                  , a = e - r
                  , n = () => {
                    if (!this.terrain || this.terrainFlattening)
                        return;
                    let o = (performance.now() - t) / this.terrainAnimationDuration;
                    o < .99 ? (this.terrain.exaggeration = r + (1 - (1 - o) ** 4) * a,
                    requestAnimationFrame(n)) : (this.terrainGrowing = !1,
                    this.terrainFlattening = !1,
                    this.terrain.exaggeration = e,
                    this.fire("terrainAnimationStop", {
                        terrain: this.terrain
                    })),
                    this._elevationFreeze = !1,
                    this.triggerRepaint()
                }
                ;
                this.terrainGrowing || this.terrainFlattening || this.fire("terrainAnimationStart", {
                    terrain: this.terrain
                }),
                this.terrainGrowing = !0,
                this.terrainFlattening = !1,
                requestAnimationFrame(n)
            }
            enableTerrain(e=this.terrainExaggeration) {
                if (e < 0) {
                    console.warn("Terrain exaggeration cannot be negative.");
                    return
                }
                let t = r => {
                    this.terrain && "data" === r.type && "source" === r.dataType && "source"in r && "maptiler-terrain" === r.sourceId && "raster-dem" === r.source.type && r.isSourceLoaded && (this.off("data", t),
                    this.growTerrain(e))
                }
                  , r = () => {
                    this.isTerrainEnabled = !0,
                    this.terrainExaggeration = e,
                    this.on("data", t),
                    this.addSource(K.terrainSourceId, {
                        type: "raster-dem",
                        url: K.terrainSourceURL
                    }),
                    this.setTerrain({
                        source: K.terrainSourceId,
                        exaggeration: 0
                    })
                }
                ;
                if (this.getTerrain()) {
                    this.isTerrainEnabled = !0,
                    this.growTerrain(e);
                    return
                }
                if (this.loaded() || this.isTerrainEnabled)
                    r();
                else {
                    let e = () => {
                        this.getTerrain() && this.getSource(K.terrainSourceId) || r()
                    }
                    ;
                    this.once("load", () => {
                        e()
                    }
                    ),
                    this.once("moveend", () => {
                        e()
                    }
                    )
                }
            }
            disableTerrain() {
                if (!this.terrain)
                    return;
                this.isTerrainEnabled = !1;
                let e = performance.now()
                  , t = this.terrain.exaggeration
                  , r = () => {
                    if (!this.terrain || this.terrainGrowing)
                        return;
                    let a = (performance.now() - e) / this.terrainAnimationDuration;
                    (this._elevationFreeze = !1,
                    a < .99) ? (this.terrain.exaggeration = t * (1 - a) ** 4,
                    requestAnimationFrame(r)) : (this.terrain.exaggeration = 0,
                    this.terrainGrowing = !1,
                    this.terrainFlattening = !1,
                    this.setTerrain(),
                    this.getSource(K.terrainSourceId) && this.removeSource(K.terrainSourceId),
                    this.fire("terrainAnimationStop", {
                        terrain: null
                    })),
                    this.triggerRepaint()
                }
                ;
                this.terrainGrowing || this.terrainFlattening || this.fire("terrainAnimationStart", {
                    terrain: this.terrain
                }),
                this.terrainGrowing = !1,
                this.terrainFlattening = !0,
                requestAnimationFrame(r)
            }
            setTerrainExaggeration(e, t=!0) {
                !t && this.terrain ? (this.terrainExaggeration = e,
                this.terrain.exaggeration = e,
                this.triggerRepaint()) : this.enableTerrain(e)
            }
            onStyleReady(e) {
                this.isStyleLoaded() ? e() : this.once("styledata", () => {
                    e()
                }
                )
            }
            async fitToIpBounds() {
                let e = await I.DP.info();
                this.fitBounds(e.country_bounds, {
                    duration: 0,
                    padding: 100
                })
            }
            async centerOnIpPoint(e) {
                let t = await I.DP.info();
                this.jumpTo({
                    center: [t.longitude ?? 0, t.latitude ?? 0],
                    zoom: e || 11
                })
            }
            getCameraHash() {
                let e = new Float32Array(5)
                  , t = this.getCenter();
                return e[0] = t.lng,
                e[1] = t.lat,
                e[2] = this.getZoom(),
                e[3] = this.getPitch(),
                e[4] = this.getBearing(),
                R.DS.fromUint8Array(new Uint8Array(e.buffer))
            }
            getSdkConfig() {
                return Y
            }
            getMaptilerSessionId() {
                return Z
            }
            setTransformRequest(e) {
                return super.setTransformRequest(ei(e)),
                this
            }
            isGlobeProjection() {
                let e = this.getProjection();
                return !!e && "globe" === e.type
            }
            enableGlobeProjection() {
                !0 !== this.isGlobeProjection() && (this.setProjection({
                    type: "globe"
                }),
                this.curentProjection = "globe")
            }
            enableMercatorProjection() {
                !1 !== this.isGlobeProjection() && (this.setProjection({
                    type: "mercator"
                }),
                this.curentProjection = "mercator")
            }
            isLanguageUpdated() {
                return this.languageIsUpdated
            }
        }
        ;
        function a8(e, t) {
            return e.getElementsByTagName(t)
        }
        function a6(e, t) {
            return e.getAttribute(t)
        }
        function a7(e, t) {
            return Number.parseFloat(a6(e, t) ?? "0")
        }
        function a9(e, t) {
            let r = a8(e, t);
            return r.length ? r[0] : null
        }
        function ne(e) {
            return e && e.normalize && e.normalize(),
            e && e.textContent
        }
        function nt(e, t) {
            let r, a;
            let n = {};
            for (a = 0; a < t.length; a++)
                (r = a9(e, t[a])) && (n[t[a]] = ne(r) ?? "");
            return n
        }
        function nr(e) {
            let t = e.toString(16);
            return 1 === t.length ? `0${t}` : t
        }
        class na extends Array {
            constructor(e={}) {
                super(),
                F(this, "min", 0),
                F(this, "max", 1),
                "min"in e && (this.min = e.min),
                "max"in e && (this.max = e.max),
                "stops"in e && this.setStops(e.stops, {
                    clone: !1
                })
            }
            static fromArrayDefinition(e) {
                return new na({
                    stops: e.map(e => ({
                        value: e[0],
                        color: e[1]
                    }))
                })
            }
            setStops(e, t={
                clone: !0
            }) {
                let r = t.clone ? this.clone() : this;
                r.length = 0;
                let a = Number.POSITIVE_INFINITY
                  , n = Number.NEGATIVE_INFINITY;
                for (let t = 0; t < e.length; t += 1)
                    a = Math.min(a, e[t].value),
                    n = Math.max(n, e[t].value),
                    r.push({
                        value: e[t].value,
                        color: e[t].color.slice()
                    });
                return r.sort( (e, t) => e.value < t.value ? -1 : 1),
                this.min = a,
                this.max = n,
                r
            }
            scale(e, t, r={
                clone: !0
            }) {
                let a = r.clone
                  , n = this[0].value
                  , o = this.at(-1).value - n
                  , i = t - e
                  , l = [];
                for (let t = 0; t < this.length; t += 1) {
                    let r = (this[t].value - n) / o * i + e;
                    a ? l.push({
                        value: r,
                        color: this[t].color.slice()
                    }) : this[t].value = r
                }
                return a ? new na({
                    stops: l
                }) : this
            }
            at(e) {
                return e < 0 ? this[this.length + e] : this[e]
            }
            clone() {
                return new na({
                    stops: this.getRawColorStops()
                })
            }
            getRawColorStops() {
                let e = [];
                for (let t = 0; t < this.length; t += 1)
                    e.push({
                        value: this[t].value,
                        color: this[t].color
                    });
                return e
            }
            reverse(e={
                clone: !0
            }) {
                let t = e.clone ? this.clone() : this;
                for (let e = 0; e < ~~(t.length / 2); e += 1) {
                    let r = t[e].color;
                    t[e].color = t.at(-(e + 1)).color,
                    t.at(-(e + 1)).color = r
                }
                return t
            }
            getBounds() {
                return {
                    min: this.min,
                    max: this.max
                }
            }
            getColor(e, t={
                smooth: !0
            }) {
                if (e <= this[0].value)
                    return this[0].color;
                if (e >= this.at(-1).value)
                    return this.at(-1).color;
                for (let r = 0; r < this.length - 1; r += 1) {
                    if (e > this[r + 1].value)
                        continue;
                    let a = this[r].color;
                    if (!t.smooth)
                        return a.slice();
                    let n = this[r].value
                      , o = this[r + 1].value
                      , i = this[r + 1].color
                      , l = (o - e) / (o - n);
                    return a.map( (e, t) => Math.round(e * l + i[t] * (1 - l)))
                }
                return [0, 0, 0]
            }
            getColorHex(e, t={
                smooth: !0,
                withAlpha: !1
            }) {
                var r;
                return r = this.getColor(e, t),
                `#${nr(r[0])}${nr(r[1])}${nr(r[2])}${4 === r.length ? nr(r[3]) : ""}`
            }
            getColorRelative(e, t={
                smooth: !0
            }) {
                let r = this.getBounds();
                return this.getColor(r.min + e * (r.max - r.min), t)
            }
            getCanvasStrip(e={
                horizontal: !0,
                size: 512,
                smooth: !0
            }) {
                let t = document.createElement("canvas");
                t.width = e.horizontal ? e.size : 1,
                t.height = e.horizontal ? 1 : e.size;
                let r = t.getContext("2d");
                if (!r)
                    throw Error("Canvs context is missing");
                let a = r.getImageData(0, 0, t.width, t.height)
                  , n = a.data
                  , o = e.size
                  , i = this[0].value
                  , l = (this.at(-1).value - i) / o;
                for (let t = 0; t < o; t += 1) {
                    let r = this.getColor(i + t * l, {
                        smooth: e.smooth
                    });
                    n[4 * t] = r[0],
                    n[4 * t + 1] = r[1],
                    n[4 * t + 2] = r[2],
                    n[4 * t + 3] = r.length > 3 ? r[3] : 255
                }
                return r.putImageData(a, 0, 0),
                t
            }
            resample(e, t=15) {
                let r;
                let a = this.getBounds()
                  , n = this.scale(0, 1)
                  , o = 1 / (t - 1);
                if ("ease-in-square" === e)
                    r = Array.from({
                        length: t
                    }, (e, t) => {
                        let r = t * o
                          , a = n.getColor(r ** 2);
                        return {
                            value: r,
                            color: a
                        }
                    }
                    );
                else if ("ease-out-square" === e)
                    r = Array.from({
                        length: t
                    }, (e, t) => {
                        let r = t * o
                          , a = n.getColor(1 - (1 - r) ** 2);
                        return {
                            value: r,
                            color: a
                        }
                    }
                    );
                else if ("ease-out-sqrt" === e)
                    r = Array.from({
                        length: t
                    }, (e, t) => {
                        let r = t * o
                          , a = n.getColor(r ** .5);
                        return {
                            value: r,
                            color: a
                        }
                    }
                    );
                else if ("ease-in-sqrt" === e)
                    r = Array.from({
                        length: t
                    }, (e, t) => {
                        let r = t * o
                          , a = n.getColor(1 - (1 - r) ** .5);
                        return {
                            value: r,
                            color: a
                        }
                    }
                    );
                else if ("ease-out-exp" === e)
                    r = Array.from({
                        length: t
                    }, (e, t) => {
                        let r = t * o
                          , a = n.getColor(1 - 2 ** (-10 * r));
                        return {
                            value: r,
                            color: a
                        }
                    }
                    );
                else if ("ease-in-exp" === e)
                    r = Array.from({
                        length: t
                    }, (e, t) => {
                        let r = t * o
                          , a = n.getColor(2 ** (10 * r - 10));
                        return {
                            value: r,
                            color: a
                        }
                    }
                    );
                else
                    throw Error("Invalid ressampling method.");
                return new na({
                    stops: r
                }).scale(a.min, a.max)
            }
            transparentStart() {
                let e = this.getRawColorStops();
                for (let t of (e.unshift({
                    value: e[0].value,
                    color: e[0].color.slice()
                }),
                e[1].value += .001,
                e))
                    3 === t.color.length && t.color.push(255);
                return e[0].color[3] = 0,
                new na({
                    stops: e
                })
            }
            hasTransparentStart() {
                return 4 === this[0].color.length && 0 === this[0].color[3]
            }
        }
        new na({
            stops: [{
                value: 0,
                color: [0, 0, 0, 0]
            }, {
                value: 1,
                color: [0, 0, 0, 0]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [0, 0, 0]
            }, {
                value: 1,
                color: [255, 255, 255]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [0, 0, 131]
            }, {
                value: .125,
                color: [0, 60, 170]
            }, {
                value: .375,
                color: [5, 255, 255]
            }, {
                value: .625,
                color: [255, 255, 0]
            }, {
                value: .875,
                color: [250, 0, 0]
            }, {
                value: 1,
                color: [128, 0, 0]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [255, 0, 0]
            }, {
                value: .169,
                color: [253, 255, 2]
            }, {
                value: .173,
                color: [247, 255, 2]
            }, {
                value: .337,
                color: [0, 252, 4]
            }, {
                value: .341,
                color: [0, 252, 10]
            }, {
                value: .506,
                color: [1, 249, 255]
            }, {
                value: .671,
                color: [2, 0, 253]
            }, {
                value: .675,
                color: [8, 0, 253]
            }, {
                value: .839,
                color: [255, 0, 251]
            }, {
                value: .843,
                color: [255, 0, 245]
            }, {
                value: 1,
                color: [255, 0, 6]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [0, 0, 0]
            }, {
                value: .3,
                color: [230, 0, 0]
            }, {
                value: .6,
                color: [255, 210, 0]
            }, {
                value: 1,
                color: [255, 255, 255]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [255, 0, 255]
            }, {
                value: 1,
                color: [255, 255, 0]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [0, 128, 102]
            }, {
                value: 1,
                color: [255, 255, 102]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [255, 0, 0]
            }, {
                value: 1,
                color: [255, 255, 0]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [0, 0, 255]
            }, {
                value: 1,
                color: [0, 255, 128]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [0, 0, 0]
            }, {
                value: .376,
                color: [84, 84, 116]
            }, {
                value: .753,
                color: [169, 200, 200]
            }, {
                value: 1,
                color: [255, 255, 255]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [0, 0, 0]
            }, {
                value: .804,
                color: [255, 160, 102]
            }, {
                value: 1,
                color: [255, 199, 127]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [0, 0, 0]
            }, {
                value: 1,
                color: [255, 255, 255]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [8, 29, 88]
            }, {
                value: .125,
                color: [37, 52, 148]
            }, {
                value: .25,
                color: [34, 94, 168]
            }, {
                value: .375,
                color: [29, 145, 192]
            }, {
                value: .5,
                color: [65, 182, 196]
            }, {
                value: .625,
                color: [127, 205, 187]
            }, {
                value: .75,
                color: [199, 233, 180]
            }, {
                value: .875,
                color: [237, 248, 217]
            }, {
                value: 1,
                color: [255, 255, 217]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [0, 68, 27]
            }, {
                value: .125,
                color: [0, 109, 44]
            }, {
                value: .25,
                color: [35, 139, 69]
            }, {
                value: .375,
                color: [65, 171, 93]
            }, {
                value: .5,
                color: [116, 196, 118]
            }, {
                value: .625,
                color: [161, 217, 155]
            }, {
                value: .75,
                color: [199, 233, 192]
            }, {
                value: .875,
                color: [229, 245, 224]
            }, {
                value: 1,
                color: [247, 252, 245]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [128, 0, 38]
            }, {
                value: .125,
                color: [189, 0, 38]
            }, {
                value: .25,
                color: [227, 26, 28]
            }, {
                value: .375,
                color: [252, 78, 42]
            }, {
                value: .5,
                color: [253, 141, 60]
            }, {
                value: .625,
                color: [254, 178, 76]
            }, {
                value: .75,
                color: [254, 217, 118]
            }, {
                value: .875,
                color: [255, 237, 160]
            }, {
                value: 1,
                color: [255, 255, 204]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [0, 0, 255]
            }, {
                value: 1,
                color: [255, 0, 0]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [5, 10, 172]
            }, {
                value: .35,
                color: [106, 137, 247]
            }, {
                value: .5,
                color: [190, 190, 190]
            }, {
                value: .6,
                color: [220, 170, 132]
            }, {
                value: .7,
                color: [230, 145, 90]
            }, {
                value: 1,
                color: [178, 10, 28]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [0, 0, 255]
            }, {
                value: .1,
                color: [51, 153, 255]
            }, {
                value: .2,
                color: [102, 204, 255]
            }, {
                value: .3,
                color: [153, 204, 255]
            }, {
                value: .4,
                color: [204, 204, 255]
            }, {
                value: .5,
                color: [255, 255, 255]
            }, {
                value: .6,
                color: [255, 204, 255]
            }, {
                value: .7,
                color: [255, 153, 255]
            }, {
                value: .8,
                color: [255, 102, 204]
            }, {
                value: .9,
                color: [255, 102, 102]
            }, {
                value: 1,
                color: [255, 0, 0]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [150, 0, 90]
            }, {
                value: .125,
                color: [0, 0, 200]
            }, {
                value: .25,
                color: [0, 25, 255]
            }, {
                value: .375,
                color: [0, 152, 255]
            }, {
                value: .5,
                color: [44, 255, 150]
            }, {
                value: .625,
                color: [151, 255, 0]
            }, {
                value: .75,
                color: [255, 234, 0]
            }, {
                value: .875,
                color: [255, 111, 0]
            }, {
                value: 1,
                color: [255, 0, 0]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [12, 51, 131]
            }, {
                value: .25,
                color: [10, 136, 186]
            }, {
                value: .5,
                color: [242, 211, 56]
            }, {
                value: .75,
                color: [242, 143, 56]
            }, {
                value: 1,
                color: [217, 30, 30]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [0, 0, 0]
            }, {
                value: .2,
                color: [230, 0, 0]
            }, {
                value: .4,
                color: [230, 210, 0]
            }, {
                value: .7,
                color: [255, 255, 255]
            }, {
                value: 1,
                color: [160, 200, 255]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [0, 0, 130]
            }, {
                value: .1,
                color: [0, 180, 180]
            }, {
                value: .2,
                color: [40, 210, 40]
            }, {
                value: .4,
                color: [230, 230, 50]
            }, {
                value: .6,
                color: [120, 70, 20]
            }, {
                value: 1,
                color: [255, 255, 255]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [0, 0, 0]
            }, {
                value: .15,
                color: [30, 0, 100]
            }, {
                value: .4,
                color: [120, 0, 100]
            }, {
                value: .6,
                color: [160, 90, 0]
            }, {
                value: .8,
                color: [230, 200, 0]
            }, {
                value: 1,
                color: [255, 250, 220]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [68, 1, 84]
            }, {
                value: .13,
                color: [71, 44, 122]
            }, {
                value: .25,
                color: [59, 81, 139]
            }, {
                value: .38,
                color: [44, 113, 142]
            }, {
                value: .5,
                color: [33, 144, 141]
            }, {
                value: .63,
                color: [39, 173, 129]
            }, {
                value: .75,
                color: [92, 200, 99]
            }, {
                value: .88,
                color: [170, 220, 50]
            }, {
                value: 1,
                color: [253, 231, 37]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [0, 0, 4]
            }, {
                value: .13,
                color: [31, 12, 72]
            }, {
                value: .25,
                color: [85, 15, 109]
            }, {
                value: .38,
                color: [136, 34, 106]
            }, {
                value: .5,
                color: [186, 54, 85]
            }, {
                value: .63,
                color: [227, 89, 51]
            }, {
                value: .75,
                color: [249, 140, 10]
            }, {
                value: .88,
                color: [249, 201, 50]
            }, {
                value: 1,
                color: [252, 255, 164]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [0, 0, 4]
            }, {
                value: .13,
                color: [28, 16, 68]
            }, {
                value: .25,
                color: [79, 18, 123]
            }, {
                value: .38,
                color: [129, 37, 129]
            }, {
                value: .5,
                color: [181, 54, 122]
            }, {
                value: .63,
                color: [229, 80, 100]
            }, {
                value: .75,
                color: [251, 135, 97]
            }, {
                value: .88,
                color: [254, 194, 135]
            }, {
                value: 1,
                color: [252, 253, 191]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [13, 8, 135]
            }, {
                value: .13,
                color: [75, 3, 161]
            }, {
                value: .25,
                color: [125, 3, 168]
            }, {
                value: .38,
                color: [168, 34, 150]
            }, {
                value: .5,
                color: [203, 70, 121]
            }, {
                value: .63,
                color: [229, 107, 93]
            }, {
                value: .75,
                color: [248, 148, 65]
            }, {
                value: .88,
                color: [253, 195, 40]
            }, {
                value: 1,
                color: [240, 249, 33]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [125, 0, 179]
            }, {
                value: .13,
                color: [172, 0, 187]
            }, {
                value: .25,
                color: [219, 0, 170]
            }, {
                value: .38,
                color: [255, 0, 130]
            }, {
                value: .5,
                color: [255, 63, 74]
            }, {
                value: .63,
                color: [255, 123, 0]
            }, {
                value: .75,
                color: [234, 176, 0]
            }, {
                value: .88,
                color: [190, 228, 0]
            }, {
                value: 1,
                color: [147, 255, 0]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [125, 0, 179]
            }, {
                value: .13,
                color: [116, 0, 218]
            }, {
                value: .25,
                color: [98, 74, 237]
            }, {
                value: .38,
                color: [68, 146, 231]
            }, {
                value: .5,
                color: [0, 204, 197]
            }, {
                value: .63,
                color: [0, 247, 146]
            }, {
                value: .75,
                color: [0, 255, 88]
            }, {
                value: .88,
                color: [40, 255, 8]
            }, {
                value: 1,
                color: [147, 255, 0]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [125, 0, 179]
            }, {
                value: .1,
                color: [199, 0, 180]
            }, {
                value: .2,
                color: [255, 0, 121]
            }, {
                value: .3,
                color: [255, 108, 0]
            }, {
                value: .4,
                color: [222, 194, 0]
            }, {
                value: .5,
                color: [150, 255, 0]
            }, {
                value: .6,
                color: [0, 255, 55]
            }, {
                value: .7,
                color: [0, 246, 150]
            }, {
                value: .8,
                color: [50, 167, 222]
            }, {
                value: .9,
                color: [103, 51, 235]
            }, {
                value: 1,
                color: [124, 0, 186]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [40, 26, 44]
            }, {
                value: .13,
                color: [59, 49, 90]
            }, {
                value: .25,
                color: [64, 76, 139]
            }, {
                value: .38,
                color: [63, 110, 151]
            }, {
                value: .5,
                color: [72, 142, 158]
            }, {
                value: .63,
                color: [85, 174, 163]
            }, {
                value: .75,
                color: [120, 206, 163]
            }, {
                value: .88,
                color: [187, 230, 172]
            }, {
                value: 1,
                color: [253, 254, 204]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [47, 15, 62]
            }, {
                value: .13,
                color: [87, 23, 86]
            }, {
                value: .25,
                color: [130, 28, 99]
            }, {
                value: .38,
                color: [171, 41, 96]
            }, {
                value: .5,
                color: [206, 67, 86]
            }, {
                value: .63,
                color: [230, 106, 84]
            }, {
                value: .75,
                color: [242, 149, 103]
            }, {
                value: .88,
                color: [249, 193, 135]
            }, {
                value: 1,
                color: [254, 237, 176]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [18, 36, 20]
            }, {
                value: .13,
                color: [25, 63, 41]
            }, {
                value: .25,
                color: [24, 91, 59]
            }, {
                value: .38,
                color: [13, 119, 72]
            }, {
                value: .5,
                color: [18, 148, 80]
            }, {
                value: .63,
                color: [80, 173, 89]
            }, {
                value: .75,
                color: [132, 196, 122]
            }, {
                value: .88,
                color: [175, 221, 162]
            }, {
                value: 1,
                color: [215, 249, 208]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [54, 14, 36]
            }, {
                value: .13,
                color: [89, 23, 80]
            }, {
                value: .25,
                color: [110, 45, 132]
            }, {
                value: .38,
                color: [120, 77, 178]
            }, {
                value: .5,
                color: [120, 113, 213]
            }, {
                value: .63,
                color: [115, 151, 228]
            }, {
                value: .75,
                color: [134, 185, 227]
            }, {
                value: .88,
                color: [177, 214, 227]
            }, {
                value: 1,
                color: [230, 241, 241]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [30, 4, 110]
            }, {
                value: .13,
                color: [47, 14, 176]
            }, {
                value: .25,
                color: [41, 45, 236]
            }, {
                value: .38,
                color: [25, 99, 212]
            }, {
                value: .5,
                color: [68, 131, 200]
            }, {
                value: .63,
                color: [114, 156, 197]
            }, {
                value: .75,
                color: [157, 181, 203]
            }, {
                value: .88,
                color: [200, 208, 216]
            }, {
                value: 1,
                color: [241, 237, 236]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [60, 9, 18]
            }, {
                value: .13,
                color: [100, 17, 27]
            }, {
                value: .25,
                color: [142, 20, 29]
            }, {
                value: .38,
                color: [177, 43, 27]
            }, {
                value: .5,
                color: [192, 87, 63]
            }, {
                value: .63,
                color: [205, 125, 105]
            }, {
                value: .75,
                color: [216, 162, 148]
            }, {
                value: .88,
                color: [227, 199, 193]
            }, {
                value: 1,
                color: [241, 237, 236]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [64, 5, 5]
            }, {
                value: .13,
                color: [106, 6, 15]
            }, {
                value: .25,
                color: [144, 26, 7]
            }, {
                value: .38,
                color: [168, 64, 3]
            }, {
                value: .5,
                color: [188, 100, 4]
            }, {
                value: .63,
                color: [206, 136, 11]
            }, {
                value: .75,
                color: [220, 174, 25]
            }, {
                value: .88,
                color: [231, 215, 44]
            }, {
                value: 1,
                color: [248, 254, 105]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [51, 20, 24]
            }, {
                value: .13,
                color: [90, 32, 35]
            }, {
                value: .25,
                color: [129, 44, 34]
            }, {
                value: .38,
                color: [159, 68, 25]
            }, {
                value: .5,
                color: [182, 99, 19]
            }, {
                value: .63,
                color: [199, 134, 22]
            }, {
                value: .75,
                color: [212, 171, 35]
            }, {
                value: .88,
                color: [221, 210, 54]
            }, {
                value: 1,
                color: [225, 253, 75]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [145, 105, 18]
            }, {
                value: .13,
                color: [184, 71, 38]
            }, {
                value: .25,
                color: [186, 58, 115]
            }, {
                value: .38,
                color: [160, 71, 185]
            }, {
                value: .5,
                color: [110, 97, 218]
            }, {
                value: .63,
                color: [50, 123, 164]
            }, {
                value: .75,
                color: [31, 131, 110]
            }, {
                value: .88,
                color: [77, 129, 34]
            }, {
                value: 1,
                color: [145, 105, 18]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [42, 24, 108]
            }, {
                value: .13,
                color: [33, 50, 162]
            }, {
                value: .25,
                color: [15, 90, 145]
            }, {
                value: .38,
                color: [40, 118, 137]
            }, {
                value: .5,
                color: [59, 146, 135]
            }, {
                value: .63,
                color: [79, 175, 126]
            }, {
                value: .75,
                color: [120, 203, 104]
            }, {
                value: .88,
                color: [193, 221, 100]
            }, {
                value: 1,
                color: [253, 239, 154]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [4, 35, 51]
            }, {
                value: .13,
                color: [23, 51, 122]
            }, {
                value: .25,
                color: [85, 59, 157]
            }, {
                value: .38,
                color: [129, 79, 143]
            }, {
                value: .5,
                color: [175, 95, 130]
            }, {
                value: .63,
                color: [222, 112, 101]
            }, {
                value: .75,
                color: [249, 146, 66]
            }, {
                value: .88,
                color: [249, 196, 65]
            }, {
                value: 1,
                color: [232, 250, 91]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [34, 31, 27]
            }, {
                value: .13,
                color: [65, 50, 41]
            }, {
                value: .25,
                color: [98, 69, 52]
            }, {
                value: .38,
                color: [131, 89, 57]
            }, {
                value: .5,
                color: [161, 112, 59]
            }, {
                value: .63,
                color: [185, 140, 66]
            }, {
                value: .75,
                color: [202, 174, 88]
            }, {
                value: .88,
                color: [216, 209, 126]
            }, {
                value: 1,
                color: [233, 246, 171]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [17, 32, 64]
            }, {
                value: .13,
                color: [35, 52, 116]
            }, {
                value: .25,
                color: [29, 81, 156]
            }, {
                value: .38,
                color: [31, 113, 162]
            }, {
                value: .5,
                color: [50, 144, 169]
            }, {
                value: .63,
                color: [87, 173, 176]
            }, {
                value: .75,
                color: [149, 196, 189]
            }, {
                value: .88,
                color: [203, 221, 211]
            }, {
                value: 1,
                color: [254, 251, 230]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [23, 35, 19]
            }, {
                value: .13,
                color: [24, 64, 38]
            }, {
                value: .25,
                color: [11, 95, 45]
            }, {
                value: .38,
                color: [39, 123, 35]
            }, {
                value: .5,
                color: [95, 146, 12]
            }, {
                value: .63,
                color: [152, 165, 18]
            }, {
                value: .75,
                color: [201, 186, 69]
            }, {
                value: .88,
                color: [233, 216, 137]
            }, {
                value: 1,
                color: [255, 253, 205]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [0, 0, 0]
            }, {
                value: .07,
                color: [22, 5, 59]
            }, {
                value: .13,
                color: [60, 4, 105]
            }, {
                value: .2,
                color: [109, 1, 135]
            }, {
                value: .27,
                color: [161, 0, 147]
            }, {
                value: .33,
                color: [210, 2, 142]
            }, {
                value: .4,
                color: [251, 11, 123]
            }, {
                value: .47,
                color: [255, 29, 97]
            }, {
                value: .53,
                color: [255, 54, 69]
            }, {
                value: .6,
                color: [255, 85, 46]
            }, {
                value: .67,
                color: [255, 120, 34]
            }, {
                value: .73,
                color: [255, 157, 37]
            }, {
                value: .8,
                color: [241, 191, 57]
            }, {
                value: .87,
                color: [224, 220, 93]
            }, {
                value: .93,
                color: [218, 241, 142]
            }, {
                value: 1,
                color: [227, 253, 198]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [0, 32, 77, 255]
            }, {
                value: .125,
                color: [5, 54, 110, 255]
            }, {
                value: .25,
                color: [65, 77, 108, 255]
            }, {
                value: .375,
                color: [97, 100, 111, 255]
            }, {
                value: .5,
                color: [125, 124, 121, 255]
            }, {
                value: .625,
                color: [156, 149, 120, 255]
            }, {
                value: .75,
                color: [190, 175, 111, 255]
            }, {
                value: .875,
                color: [225, 204, 94, 255]
            }, {
                value: 1,
                color: [255, 235, 70, 255]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [48, 18, 59, 255]
            }, {
                value: .125,
                color: [70, 107, 227, 255]
            }, {
                value: .25,
                color: [40, 187, 236, 255]
            }, {
                value: .375,
                color: [49, 242, 153, 255]
            }, {
                value: .5,
                color: [162, 252, 60, 255]
            }, {
                value: .625,
                color: [237, 208, 58, 255]
            }, {
                value: .75,
                color: [251, 128, 34, 255]
            }, {
                value: .875,
                color: [210, 49, 5, 255]
            }, {
                value: 1,
                color: [122, 4, 3, 255]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [250, 235, 221, 0]
            }, {
                value: .133,
                color: [250, 235, 221, 255]
            }, {
                value: .266,
                color: [246, 170, 130, 255]
            }, {
                value: .4,
                color: [240, 96, 67, 255]
            }, {
                value: .533,
                color: [203, 27, 79, 255]
            }, {
                value: .666,
                color: [132, 30, 90, 255]
            }, {
                value: .8,
                color: [63, 27, 68, 255]
            }, {
                value: 1,
                color: [3, 5, 26, 255]
            }]
        }),
        new na({
            stops: [{
                value: 0,
                color: [11, 4, 5, 255]
            }, {
                value: .125,
                color: [43, 28, 53, 255]
            }, {
                value: .25,
                color: [62, 53, 107, 255]
            }, {
                value: .375,
                color: [59, 86, 152, 255]
            }, {
                value: .5,
                color: [53, 123, 162, 255]
            }, {
                value: .625,
                color: [53, 158, 170, 255]
            }, {
                value: .75,
                color: [73, 193, 173, 255]
            }, {
                value: .875,
                color: [150, 221, 181, 255]
            }, {
                value: 1,
                color: [222, 245, 229, 255]
            }]
        }),
        function() {
            if (typeof window > "u")
                return;
            let e = $.getRTLTextPluginStatus();
            if ("unavailable" === e || "requested" === e)
                try {
                    $.setRTLTextPlugin(K.rtlPluginURL, !0)
                } catch {}
        }(),
        $.Map,
        $.Marker,
        $.Popup,
        $.Style,
        $.CanvasSource,
        $.GeoJSONSource,
        $.ImageSource,
        $.RasterTileSource,
        $.RasterDEMTileSource,
        $.VectorTileSource,
        $.VideoSource,
        $.NavigationControl,
        $.GeolocateControl,
        $.AttributionControl,
        $.LogoControl,
        $.ScaleControl,
        $.FullscreenControl,
        $.TerrainControl,
        $.BoxZoomHandler,
        $.ScrollZoomHandler,
        $.CooperativeGesturesHandler,
        $.KeyboardHandler,
        $.TwoFingersTouchPitchHandler,
        $.MapWheelEvent,
        $.MapTouchEvent,
        $.MapMouseEvent,
        $.config,
        $.getVersion;
        let {setRTLTextPlugin: nn, getRTLTextPluginStatus: no, LngLat: ni, LngLatBounds: nl, MercatorCoordinate: ns, Evented: nu, AJAXError: np, prewarm: nc, clearPrewarmedResources: nh, Hash: nd, Point: nf, EdgeInsets: nm, DragRotateHandler: ny, DragPanHandler: ng, TwoFingersTouchZoomRotateHandler: nv, DoubleClickZoomHandler: nb, TwoFingersTouchZoomHandler: nx, TwoFingersTouchRotateHandler: nw, getWorkerCount: nS, setWorkerCount: nk, getMaxParallelImageRequests: n_, setMaxParallelImageRequests: nC, getWorkerUrl: nE, setWorkerUrl: nA, addSourceType: nL, importScriptInWorkers: nT, addProtocol: nM, removeProtocol: nP} = $
    }
}]);
