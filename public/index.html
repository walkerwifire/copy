<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Technet Dashboard</title>
  <link rel="stylesheet" href="/styles/app.css" />
  <style>
    * { box-sizing: border-box; }
    :root { --bg: #f7f9fc; --card: #ffffff; --text: #1f2937; --muted: #6b7280; --accent: #2563eb; --accent-2: #16a34a; --danger: #ef4444; }
    body { font-family: system-ui, sans-serif; margin: 0; background: var(--bg); color: var(--text); font-size: 18px; line-height: 1.7; }
    header { padding: 16px 20px; background: #ffffff; border-bottom: 1px solid #e5e7eb; display: flex; align-items: center; justify-content: space-between; }
    .header-left { display:flex; align-items:center; gap:10px; }
  </style>
</head>
<body>
  <header>
    <div class="header-left">
      <div class="title">Technet Dashboard</div>
    </div>
  </header>
  <div class="container" style="padding:16px">
    <div id="controls" class="card">
      <div class="row" style="gap:8px; flex-wrap:wrap">
        <select id="techSelect" class="select">
          <option value="all">All Techs</option>
        </select>
        <input type="date" id="routeDate" class="select" />
        <button id="refreshBtn" class="btn">Refresh</button>
        <button id="refreshAllBtn" class="btn">Refresh All</button>
        <a id="routesCsvLink" class="btn" href="api/routes.csv?force=1" download>Export Routes CSV</a>
        <a id="routesXlsxLink" class="btn" href="api/routes.xlsx?force=1" download>Export Routes Excel</a>
        <a id="viewOnMapLink" class="btn btn-primary" href="/map.html" target="_blank">üìç View on Map</a>
        <span id="status" class="muted" style="margin-left:auto"></span>
      </div>
    </div>

    <div id="summary" class="card" style="display:none"></div>

    <div class="card">
      <div class="row" style="justify-content:space-between; align-items:center">
        <div class="title">Technicians <span id="techCount" class="sub"></span></div>
      </div>
      <table class="table" style="width:100%">
        <thead>
          <tr>
            <th></th><th>Tech</th><th>Name</th><th>Status</th><th>Activity</th><th>Actions</th>
          </tr>
        </thead>
        <tbody id="techRows"></tbody>
      </table>
      <div id="emptyState" class="muted" style="display:none; padding:12px">No technicians</div>
      <div id="rawHtml" class="card" style="display:none"></div>
      <form id="liveForm" class="row" style="margin-top:12px; flex-wrap:wrap">
        <input type="text" id="liveUser" placeholder="User" class="select" style="background:#0b1e3b; color:#fff; border-color:#2d4f8b" />
        <input type="password" id="livePass" placeholder="Password" class="select" style="background:#0b1e3b; color:#fff; border-color:#2d4f8b" />
        <input type="text" id="liveUrl" placeholder="URL (optional)" class="select" style="background:#0b1e3b; color:#fff; border-color:#2d4f8b; min-width:280px" />
        <button type="submit" class="btn btn-primary">Live Fetch (POST)</button>
      </form>
    </div>
    <script>
    document.getElementById('refreshBtn').addEventListener('click', async () => {
      const tech = getSelectedTech();
      const date = document.getElementById('routeDate')?.value || '';
      let dash = null;
      try {
        const today = new Date().toISOString().slice(0,10);
        if (date && date !== today) {
          const stored = await fetchStoredRoutesForDate(date);
          if (stored && stored.length) {
            dash = { routes: stored, mode: 'stored', technicians: buildTechniciansFromRoutes(stored) };
          }
        }
        if (!dash) {
          const url = '/api/dashboard?mode=live' + (tech ? ('&tech=' + encodeURIComponent(tech)) : '') + (date ? ('&date=' + encodeURIComponent(date)) : '') + '&force=1&_=' + Date.now();
          const res = await fetch(url);
          if (res.ok) dash = await res.json();
        }
      } catch (e) { dash = null; }
      if (dash) {
        renderSummaryTiles(dash);
        renderTechniciansWithRoutes(dash);
        updateRoutesCsvLink();
      } else {
        renderTechniciansWithRoutes({ technicians: [], routes: [] });
        updateRoutesCsvLink();
      }
    });
    (function setDefaultRouteDate() {
      const rd = document.getElementById('routeDate');
      if (!rd) return;
      if (!rd.value) {
        const d = new Date();
        const y = d.getFullYear();
        const m = ('0' + (d.getMonth() + 1)).slice(-2);
        const day = ('0' + d.getDate()).slice(-2);
        rd.value = `${y}-${m}-${day}`;
      }
    })();
    async function fetchStoredRoutesForDate(date) {
      try {
        const res = await fetch('/api/stored?date=' + encodeURIComponent(date));
        if (!res.ok) return null;
        const json = await res.json();
        if (json && Array.isArray(json.routes) && json.routes.length) return json.routes;
        // If aggregated file exists but is empty, attempt server-side rebuild from per-tech caches
        try {
          const statusEl = document.getElementById('status');
          if (statusEl) statusEl.textContent = 'Rebuilding stored aggregated routes...';
          await fetch('/api/debug/aggregate/rebuild', {
            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ date })
          });
          // re-fetch after rebuild
          const r2 = await fetch('/api/stored?date=' + encodeURIComponent(date) + '&_=' + Date.now());
          if (r2.ok) {
            const j2 = await r2.json();
            if (j2 && Array.isArray(j2.routes) && j2.routes.length) {
              if (statusEl) statusEl.textContent = '';
              return j2.routes;
            }
          }
          if (statusEl) statusEl.textContent = '';
        } catch (e) {
          // ignore rebuild failures, fall back to returned json
        }
        return json && Array.isArray(json.routes) ? json.routes : null;
      } catch (e) { return null; }
    }

    function buildTechniciansFromRoutes(routes) {
      try {
        const set = new Set();
        (routes || []).forEach(r => { if (r && r.techNo) set.add(String(r.techNo)); });
        const out = [];
        Array.from(set).forEach(t => out.push({ techNo: String(t), name: getTechName(t, `Tech ${t}`), status: 'N/A' }));
        return out;
      } catch (e) { return []; }
    }

    document.getElementById('routeDate').addEventListener('change', async () => {
      const tech = getSelectedTech();
      const date = document.getElementById('routeDate')?.value || '';
      let dash = null;
      try {
        // Prefer stored aggregated routes for past dates to avoid falling back to sample data
        const today = new Date().toISOString().slice(0,10);
        if (date && date !== today) {
          const stored = await fetchStoredRoutesForDate(date);
          if (stored && stored.length) {
            dash = { routes: stored, mode: 'stored', technicians: buildTechniciansFromRoutes(stored) };
          }
        }
        if (!dash) {
          const res = await fetch('/api/dashboard?mode=live' + (tech ? ('&tech=' + encodeURIComponent(tech)) : '') + (date ? ('&date=' + encodeURIComponent(date)) : '') + '&force=1&_=' + Date.now());
          if (res.ok) dash = await res.json();
          else dash = null;
        }
      } catch (e) { dash = null; }
      if (dash) {
        renderTechniciansWithRoutes(dash);
        updateRoutesCsvLink();
      } else {
        // nothing to render
        renderTechniciansWithRoutes({ technicians: [], routes: [] });
        updateRoutesCsvLink();
      }
    });
    document.getElementById('techSelect').addEventListener('change', async () => {
      const tech = getSelectedTech();
      const date = document.getElementById('routeDate')?.value || '';
      try {
        let dash = null;
        // For past dates, prefer stored aggregated first
        const today = new Date().toISOString().slice(0,10);
        if (date && date !== today) {
          const stored = await fetchStoredRoutesForDate(date);
          if (stored && stored.length) {
            dash = { routes: stored, mode: 'stored', technicians: buildTechniciansFromRoutes(stored) };
          }
        }
        if (!dash) {
          const res = await fetch('/api/dashboard?mode=live' + (tech ? ('&tech=' + encodeURIComponent(tech)) : '') + (date ? ('&date=' + encodeURIComponent(date)) : '') + '&force=1&_=' + Date.now());
          if (!res.ok) {
            const msg = await res.text().catch(() => '');
            const status = document.getElementById('status');
            const techLabel = tech ? ('Tech ' + tech) : 'Login';
            if (status) status.textContent = `${techLabel} error: ${msg}`;
            alert(`Login Failed for ${techLabel}. Attempts paused to protect the account.`);
            return;
          }
          dash = await res.json();
        }
        renderSummaryTiles(dash);
        renderTechniciansWithRoutes(dash);
        updateRoutesCsvLink();
      } catch (e) {
        const status = document.getElementById('status');
        status.textContent = 'Dashboard fetch error: ' + e.message;
      }
    });
    // Show export URL on click
    (function attachExportNotifier(){
      const a = document.getElementById('routesCsvLink');
      const status = document.getElementById('status');
      if (!a) return;
      a.addEventListener('click', () => {
        try {
          // Ensure latest href
          updateRoutesCsvLink();
          const url = a.getAttribute('href') || '/api/routes.csv';
          if (status) status.textContent = `Exporting CSV: ${url}`;
        } catch {}
      });
    })();
    (function attachExcelExportNotifier(){
      const a = document.getElementById('routesXlsxLink');
      const status = document.getElementById('status');
      if (!a) return;
      a.addEventListener('click', () => {
        try {
          updateRoutesCsvLink();
          const url = a.getAttribute('href') || 'api/routes.xlsx';
          if (status) status.textContent = `Exporting Excel: ${url}`;
        } catch {}
      });
    })();
    // Refresh All button: force tech=all
    document.getElementById('refreshAllBtn').addEventListener('click', async () => {
      const date = document.getElementById('routeDate')?.value || '';
      let dash = null;
      try {
        // Always request live-parsed data when Refresh All is pressed.
        // This forces server-side live fetch for the requested date and
        // bypasses returning previously stored aggregated files.
        const res = await fetch('/api/dashboard?mode=live&tech=all' + (date ? ('&date=' + encodeURIComponent(date)) : '') + '&force=1&_=' + Date.now());
        if (!res.ok) {
          const msg = await res.text();
          const status = document.getElementById('status');
          status.textContent = 'Login error: ' + msg;
          alert('Login Failed. Attempts paused to protect the account.');
          return;
        }
        dash = await res.json();
      } catch (e) { dash = null; }
      const sel = document.getElementById('techSelect');
      if (sel) sel.value = 'all';
      if (dash) {
        renderSummaryTiles(dash);
        renderTechniciansWithRoutes(dash);
        updateRoutesCsvLink();
      } else {
        renderTechniciansWithRoutes({ technicians: [], routes: [] });
        updateRoutesCsvLink();
      }
    });
    document.getElementById('liveForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const user = document.getElementById('liveUser').value;
      const pass = document.getElementById('livePass').value;
      const url = document.getElementById('liveUrl').value;
      const status = document.getElementById('status');
      status.textContent = 'Posting credentials to /api/technet/live...';
      try {
        const res = await fetch('/api/technet/live', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ user, pass, url })
        });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const json = await res.json();
        status.textContent = 'Live fetch succeeded ‚Äî rendering';
        const { data, html } = json;
        const summary = document.getElementById('summary');
        const rawHtml = document.getElementById('rawHtml');
        summary.style.display = 'block';
        summary.innerHTML = `<h2>Summary</h2><p class="muted">Title: ${data?.title || 'N/A'}</p>`;
        const dash = await (await fetch('/api/dashboard?mode=live')).json();
        renderSummaryTiles(dash);
        renderTechniciansWithRoutes(dash);
        // Hide raw HTML debug to prevent text leakage
        rawHtml.style.display = 'none';
        rawHtml.innerHTML = '';
      } catch (e) {
        status.textContent = 'Live fetch error: ' + e.message;
      }
    });
    // Initial load: ensure functions are defined before calling
    window.addEventListener('DOMContentLoaded', async () => {
      try { await loadTechNames(); } catch {}
      try { await loadData(); } catch (e) {
        const status = document.getElementById('status');
        if (status) status.textContent = 'Init error: ' + e.message;
      }
    });
  </script>
  <script>
    // Tech names mapping support
    let TECH_NAME_MAP = {};
    async function loadTechNames() {
      try {
        const res = await fetch('/tech-names.json?_=' + Date.now());
        if (res.ok) TECH_NAME_MAP = await res.json();
      } catch {}
    }
    function getTechName(techNo, fallbackLabel) {
      const n = String(techNo || '').trim();
      return TECH_NAME_MAP[n] || fallbackLabel || (n ? ('Tech ' + n) : '');
    }
    function getSelectedTech() {
      const sel = document.getElementById('techSelect');
      const val = sel ? sel.value : '';
      return (val && val !== 'all') ? val : '';
    }
    function updateRoutesCsvLink() {
      const date = document.getElementById('routeDate')?.value || '';
      const tech = document.getElementById('techSelect')?.value || '';
      const base = 'api/routes.csv';
      const qs = [];
      // Always include date; backend defaults to today if missing
      if (date) qs.push('date=' + encodeURIComponent(date));
      // When 'All Techs' selected, omit tech param to aggregate
      if (tech && tech !== 'all') qs.push('tech=' + encodeURIComponent(tech));
      qs.push('force=1');
      const href = base + '?' + qs.join('&');
      const a = document.getElementById('routesCsvLink');
      if (a) a.href = href;
      // Build Excel link similarly, but always aggregate all techs
      const xbase = 'api/routes.xlsx';
      const xqs = [];
      if (date) xqs.push('date=' + encodeURIComponent(date));
      xqs.push('force=1');
      const xhref = xbase + '?' + xqs.join('&');
      const xa = document.getElementById('routesXlsxLink');
      if (xa) xa.href = xhref;
      // Build View on Map link with current date (aggregate all techs)
      const mapBase = '/map.html';
      const mapQs = [];
      if (date) mapQs.push('date=' + encodeURIComponent(date));
      const mapHref = mapBase + (mapQs.length ? ('?' + mapQs.join('&')) : '');
      const mla = document.getElementById('viewOnMapLink');
      if (mla) mla.href = mapHref;
    }
    async function loadData() {
      const techSel = document.getElementById('techSelect');
      const date = document.getElementById('routeDate')?.value || '';
      try {
        let dash = null;
        // Prefer stored aggregated routes first for past dates
        const today = new Date().toISOString().slice(0,10);
        if (date && date !== today) {
          const stored = await fetchStoredRoutesForDate(date);
          if (stored && stored.length) dash = { routes: stored, mode: 'stored', technicians: buildTechniciansFromRoutes(stored) };
        }
        if (!dash) {
          const url = '/api/dashboard?mode=live&tech=all' + (date ? ('&date=' + encodeURIComponent(date)) : '') + '&_=' + Date.now();
          const res = await fetch(url);
          if (!res.ok) {
            const msg = await res.text().catch(() => '');
            const status = document.getElementById('status');
            if (status) status.textContent = 'Login error: ' + msg;
            alert('Login Failed. Attempts paused to protect the account.');
            return;
          }
          dash = await res.json();
        }
        // Populate tech selector from data if empty or minimal
        if (techSel && techSel.options.length <= 1) {
          const opts = ['<option value="all">All Techs</option>'];
          (dash.technicians||[]).forEach(t => {
            const label = getTechName(t.techNo, t.name);
            const value = t.techNo || label;
            opts.push(`<option value="${String(value)}">${label}</option>`);
          });
          techSel.innerHTML = opts.join('');
          techSel.value = 'all';
        }
        renderSummaryTiles(dash);
        renderTechniciansWithRoutes(dash);
        updateRoutesCsvLink();
      } catch (e) {
        const status = document.getElementById('status');
        if (status) status.textContent = 'Error loading dashboard: ' + e.message;
      }
    }
    function renderSummaryTiles(dash) {
      const el = document.getElementById('summary');
      if (!el) return;
      const routes = dash.routes || [];
      const kinds = ['TC','IN','COS'];
        const totals = { SUMMARY: { total:0, pending:0, done:0, cancelled:0, notDone:0 } };
        kinds.forEach(k => totals[k] = { total:0, pending:0, done:0, cancelled:0, notDone:0 });
      routes.forEach(r => (r.stops||[]).forEach(s => {
        const k = kinds.includes(s.type) ? s.type : null;
          const badge = String((s.normalizedStatus || s.badge || '')).toLowerCase();
        const inc = (obj) => {
          obj.total++;
          if (badge.includes('pending')) obj.pending++;
          else if (badge.includes('complete')) obj.done++;
          else if (badge.includes('cancel')) obj.cancelled++;
            else if (badge.includes('not-done')) obj.notDone++;
        };
        if (k) inc(totals[k]);
        inc(totals.SUMMARY);
      }));
      const tile = (label, data, highlight) => `
        <div class="tile ${highlight?"tile--highlight":""}">
          <div class="tile__title">${label}</div>
          <div class="tile__total">${data.total}</div>
          <div class="tile__rows">
            <div class="tile__row">
              <span class="tile__row-label">Total</span>
              <span class="tile__count tile__count--total">${data.total}</span>
            </div>
            <div class="tile__row">
              <span class="tile__row-label">Pending</span>
              <span class="tile__count tile__count--pending">${data.pending}</span>
            </div>
            <div class="tile__row">
              <span class="tile__row-label">Done</span>
              <span class="tile__count tile__count--done">${data.done}</span>
            </div>
            <div class="tile__row">
              <span class="tile__row-label">Cancelled</span>
              <span class="tile__count tile__count--cancelled">${data.cancelled}</span>
            </div>
              <div class="tile__row">
                <span class="tile__row-label">Not Done</span>
                <span class="tile__count tile__count--cancelled">${data.notDone}</span>
              </div>
          </div>
        </div>`;
      el.style.display = 'block';
      el.innerHTML = `
        <div class="tiles">
          ${tile('TC', totals.TC)}
          ${tile('IN', totals.IN)}
          ${tile('COS', totals.COS)}
          ${tile('SUMMARY', totals.SUMMARY, true)}
        </div>`;
    }
    // Reintroduce consolidated renderer, placed correctly near the bottom
    function renderTechniciansWithRoutes(dash) {
      const techRows = document.getElementById('techRows');
      const empty = document.getElementById('emptyState');
      const techCount = document.getElementById('techCount');
      const technicians = (dash.technicians || []).slice().sort((a,b) => Number(b.techNo||0) - Number(a.techNo||0));
      techCount.textContent = technicians.length ? `(LIVE)` : '';
      techRows.innerHTML = '';
      if (!technicians.length) { empty.style.display = 'block'; return; }
      empty.style.display = 'none';
      const routes = dash.routes || [];
      // Normalize selected date for comparison. Support YYYY-MM-DD and MM/DD/YYYY inputs.
      const rawSelected = document.getElementById('routeDate')?.value || '';
      const selectedDate = (function(d){
        if (!d) return '';
        // If already ISO (YYYY-MM-DD), return as-is
        if (/^\d{4}-\d{2}-\d{2}$/.test(d)) return d;
        // Try MM/DD/YYYY -> convert
        const m = d.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
        if (m) {
          const mm = ('0' + m[1]).slice(-2);
          const dd = ('0' + m[2]).slice(-2);
          return `${m[3]}-${mm}-${dd}`;
        }
        return d;
      })(rawSelected);
      const byTech = {};
      routes.filter(r => !selectedDate || String(r.date) === String(selectedDate)).forEach(r => { (byTech[r.techNo] ||= []).push(r); });
      // When a specific tech is selected, filter technicians list
      const techSel = document.getElementById('techSelect');
      const selectedTech = techSel?.value;
      const list = (selectedTech && selectedTech !== 'all') ? technicians.filter(t => String(t.techNo) === String(selectedTech)) : technicians;
      // Flat list without provider/area grouping
      list.forEach(t => {
        const tr = document.createElement('tr');
        const displayName = getTechName(t.techNo, t.name);
        tr.innerHTML = `
          <td><span class="badge">üßë‚Äçüîß</span></td>
          <td>${t.techNo || ''}</td>
          <td>${displayName || ''}</td>
          <td><span class="badge badge-status">${t.status || 'N/A'}</span></td>
          <td class="activity-cell">
            <div class="muted">Loading...</div>
          </td>
          <td class="actions">
            <button class="btn">Profile</button>
            <button class="btn">Schedule</button>
            <button class="btn">Notes</button>
            <button class="btn btn-route" aria-expanded="false">Route <span class="badge">${(byTech[t.techNo]||[]).reduce((acc,r)=>acc+(r.stops||[]).length,0)}</span></button>
          </td>
        `;
        techRows.appendChild(tr);
        // Fetch last activity asynchronously and update cell
        (async () => {
          try {
            const res = await fetch(`/api/tech/${encodeURIComponent(t.techNo)}/activity?_=${Date.now()}`);
            if (!res.ok) throw new Error('HTTP ' + res.status);
            const json = await res.json();
            const cell = tr.querySelector('.activity-cell');
            const value = String(json.lastActivity || '').trim();
            cell.innerHTML = value ? `<div class="badge" style="background:#eef2ff;border-color:#c7d2fe;color:#1f3b8f">${value}</div>` : `<div class="muted">N/A</div>`;
          } catch {
            const cell = tr.querySelector('.activity-cell');
            cell.innerHTML = `<div class="muted">N/A</div>`;
          }
        })();
        const bodyRow = document.createElement('tr');
        const bodyCell = document.createElement('td');
        bodyCell.colSpan = 9;
        const body = document.createElement('div');
        body.className = 'route-body';
        body.style.display = 'none';
        (byTech[t.techNo]||[]).forEach(route => {
          (route.stops||[]).forEach(s => {
            const row = document.createElement('div');
            row.className = 'route-row';
            const statusKey = String((s.normalizedStatus || s.badge || s.status || '').toLowerCase());
            // Treat not-done as red (same style as cancelled); default bucket is In Progress
            const statusClass = statusKey.includes('pending') ? 'pending' : (statusKey.includes('complete') ? 'completed' : ((statusKey.includes('cancel') || statusKey.includes('not-done')) ? 'cancelled' : 'in-progress'));
            const statusLabel = statusKey.includes('pending') ? 'Pending' : (statusKey.includes('complete') ? 'Completed' : ((statusKey.includes('cancel') || statusKey.includes('not-done')) ? (s.normalizedStatus || s.badge || 'Cancelled') : 'In Progress'));
            row.innerHTML = `
              <div class="route-left">
                <span class="pill pill--time">${s.time || ''}</span>
                <span class="pill pill--job">${s.job || ''}${statusClass==='in-progress' ? ' üîµ' : ''}</span>
                <span class="pill pill--type">${s.type || ''}</span>
                <span class="pill pill--status ${statusClass}">${statusLabel}</span>
                <span class="pill pill--tech">${route.techNo || s.tech || ''}</span>
              </div>
              <div class="route-right">
                <div class="route-name">${s.name || ''}</div>
                <div class="route-sub">${s.address || ''}${s.phone ? ' ‚Ä¢ ' + s.phone : ''}</div>
              </div>
            `;
            // Make job row interactable: open Manage Job modal on click
            row.style.cursor = 'pointer';
            row.addEventListener('click', () => openJobModal(s, route, t.techNo));
            body.appendChild(row);
          });
        });
        bodyCell.appendChild(body);
        bodyRow.appendChild(bodyCell);
        techRows.appendChild(bodyRow);
        const actions = tr.querySelector('.actions');
        const [profileBtn, scheduleBtn, notesBtn, toggleBtn] = actions.querySelectorAll('button');
        profileBtn.addEventListener('click', () => openProfileModal(t, t.techNo));
        scheduleBtn.addEventListener('click', () => openScheduleModal(t, t.techNo));
        notesBtn.addEventListener('click', () => openNotesModal(t, t.techNo));
        toggleBtn.addEventListener('click', () => {
          const open = toggleBtn.getAttribute('aria-expanded') === 'true';
          toggleBtn.setAttribute('aria-expanded', String(!open));
          body.style.display = open ? 'none' : 'block';
        });
      });
    }
  </script>
  <!-- Reusable Modals -->
  <div id="modalBackdrop" class="modal-backdrop">
    <div class="modal">
      <div class="modal-header">
        <div class="modal-title" id="modalTitle">Modal</div>
        <button class="btn close-btn" id="modalClose">Close</button>
      </div>
      <div class="modal-body" id="modalBody"></div>
      <div class="modal-actions" id="modalActions"></div>
    </div>
  </div>
  <script>
    function openModal(title, bodyHtml, actionsHtml) {
      const bd = document.getElementById('modalBackdrop');
      document.getElementById('modalTitle').textContent = title;
      document.getElementById('modalBody').innerHTML = bodyHtml || '';
      document.getElementById('modalActions').innerHTML = actionsHtml || '';
      bd.style.display = 'flex';
      const close = document.getElementById('modalClose');
      close.onclick = () => { bd.style.display = 'none'; };
      bd.onclick = (e) => { if (e.target === bd) bd.style.display = 'none'; };
    }
    function safeVal(v) { return (v == null || v === 'N/A') ? '' : String(v); }
    function openProfileModal(info, techNo) {
      Promise.all([
        fetch(`/api/tech/${encodeURIComponent(techNo)}/profile`).then(r => r.json()).catch(() => ({})),
        fetch(`/api/tech/${encodeURIComponent(techNo)}/activity?_=${Date.now()}`).then(r => r.json()).catch(() => ({}))
      ]).then(([p, a]) => {
        const name = safeVal(p.name) || ('Tech ' + techNo);
        const email = safeVal(p.email);
        const status = safeVal(p.status);
        const lastActivity = safeVal(p.lastActivity || a.lastActivity);
        const body = `
          <div class="card" style="margin:0">
            <div class="title">Profile - Tech ${techNo}</div>
            <div class="sub" style="margin-top:8px">Name: ${name}</div>
            <div class="sub">Status: ${status || 'N/A'}</div>
            <div class="sub">Last Activity: ${lastActivity || 'N/A'}</div>
            <div class="sub">Email: ${email || 'Not provided'}</div>
          </div>`;
        const actions = `<button class="btn" onclick="(async function(){ await fetch('/api/tech/${techNo}/profile',{ method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ lastActivity: new Date().toISOString() }) }); alert('Saved'); document.getElementById('modalBackdrop').style.display='none'; })()">Save</button>`;
        openModal(name, body, actions);
      }).catch(() => {
        openModal('Profile', '<div class="muted">Failed to load profile</div>', '');
      });
    }
    function openScheduleModal(info, techNo) {
      fetch(`/api/tech/${encodeURIComponent(techNo)}/schedule`).then(r => r.json()).then(s => {
        const selected = new Set((s.days||[]).map(Number));
        const daysGrid = Array.from({length:31}, (_,i)=>{
          const d = i+1; const on = selected.has(d);
          return `<button class='badge' data-day='${d}' style='text-align:center; padding:12px; ${on?"background:#dcfce7;border-color:#86efac;color:#166534":""}'>${d}</button>`;
        }).join('');
        const body = `
          <div class="card" style="margin:0">
            <div class="title">Manage Working Days - Tech ${techNo}</div>
            <div class="sub" style="margin-top:8px">Click on any day to toggle working/vacation.</div>
            <div id='daysGrid' style="margin-top:12px; display:grid; grid-template-columns: repeat(7, 1fr); gap:8px">${daysGrid}</div>
          </div>`;
        const actions = `<button class="btn btn-primary" id='saveDays'>Save Working Days</button>`;
        openModal('Schedule & Availability', body, actions);
        const grid = document.getElementById('daysGrid');
        grid.addEventListener('click', (e) => {
          const el = e.target.closest('button[data-day]'); if (!el) return;
          const day = Number(el.getAttribute('data-day'));
          if (selected.has(day)) { selected.delete(day); el.style.background=''; el.style.borderColor=''; el.style.color=''; }
          else { selected.add(day); el.style.background='#dcfce7'; el.style.borderColor='#86efac'; el.style.color='#166534'; }
        });
        document.getElementById('saveDays').onclick = async () => {
          const payload = { days: Array.from(selected.values()) };
          await fetch(`/api/tech/${techNo}/schedule`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
          alert('Saved');
          document.getElementById('modalBackdrop').style.display='none';
        };
      }).catch(() => {
        openModal('Schedule & Availability', '<div class="muted">Failed to load schedule</div>', '');
      });
    }
    function openNotesModal(info, techNo) {
      fetch(`/api/tech/${encodeURIComponent(techNo)}/notes`).then(r => r.json()).then(list => {
        const items = (list||[]).map(n => `<div class='sub' style='margin-top:6px'>‚Ä¢ ${n.text} <span class='muted'>(${n.ts})</span></div>`).join('') || `<div class='muted'>No notes yet.</div>`;
        const body = `
          <div class="card" style="margin:0">
            <div class="title">Notes for Tech ${techNo}</div>
            <div id='notesList' style='margin-top:8px'>${items}</div>
            <textarea id='noteInput' style='width:100%; margin-top:12px; padding:12px; border-radius:8px; border:1px solid #e5e7eb' placeholder='Enter your note here...'></textarea>
          </div>`;
        const actions = `<button class="btn btn-success" id='addNote'>Add Note</button>`;
        openModal('Tech Notes', body, actions);
        document.getElementById('addNote').onclick = async () => {
          const t = document.getElementById('noteInput').value;
          if (!t) return;
          const res = await fetch(`/api/tech/${techNo}/notes`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ text: t }) });
          const updated = await res.json();
          const html = (updated.notes||[]).map(n => `<div class='sub' style='margin-top:6px'>‚Ä¢ ${n.text} <span class='muted'>(${n.ts})</span></div>`).join('');
          document.getElementById('notesList').innerHTML = html;
          document.getElementById('noteInput').value = '';
        };
      }).catch(() => {
        openModal('Tech Notes', '<div class="muted">Failed to load notes</div>', '');
      });
    }
  </script>
  <script>
    function openJobModal(stop, route, techNo) {
      const statusKey = String((stop.normalizedStatus || stop.badge || stop.status || '').toLowerCase());
      const statusClass = statusKey.includes('pending') ? 'pending' : (statusKey.includes('complete') ? 'completed' : ((statusKey.includes('cancel')||statusKey.includes('not-done')) ? 'cancelled' : 'in-progress'));
      const body = `
        <div class="card" style="margin:0">
          <div class="title">Manage Job</div>
          <div class="row" style="margin-top:10px; flex-wrap:wrap">
            <span class="pill pill--time">${stop.time || ''}</span>
            <span class="pill pill--job">${stop.job || ''}</span>
            <span class="pill pill--type">${stop.type || ''}</span>
            <span class="pill pill--status ${statusClass}">${(stop.normalizedStatus ? (stop.normalizedStatus==='in-progress'?'In Progress': stop.normalizedStatus) : (stop.badge || stop.status || ''))}</span>
            <span class="pill pill--tech">${route.techNo || stop.tech || techNo || ''}</span>
          </div>
          <div class="route-right" style="margin-top:12px">
            <div class="route-name">${stop.name || ''}</div>
            <div class="route-sub">${stop.address || ''}${stop.phone ? ' ‚Ä¢ ' + stop.phone : ''}</div>
          </div>
          <div style="margin-top:16px">
            <div class="title" style="font-size:16px">Job Details</div>
            <div class="row" style="flex-wrap:wrap; gap:16px; margin-top:8px">
              <div class="sub" style="min-width:260px"><strong>Job Number</strong><br>${stop.job || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>Job Type</strong><br>${stop.type || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>Status</strong><br>${stop.badge || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>Customer Name</strong><br>${stop.name || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>Customer Phone</strong><br>${stop.phone || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>Address</strong><br>${stop.address || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>Time Frame</strong><br>${stop.time || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>Assigned Tech</strong><br>${route.techNo || stop.tech || techNo || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>Create</strong><br>${stop.create || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>Schedule Date (Schd)</strong><br>${stop.scheduleDate || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>CpTime</strong><br>${stop.staticCompletionTime || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>DS (Status)</strong><br>${stop.staticStatus || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>TS (Time Frame)</strong><br>${stop.timeFrame || stop.time || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>Units</strong><br>${stop.units || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>ReaCd/ReaDesc</strong><br>${stop.reason || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>Addr2</strong><br>${stop.address2 || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>City</strong><br>${stop.city || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>Home #</strong><br>${stop.homePhone || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>Work #</strong><br>${stop.workPhone || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>Map CD</strong><br>${stop.mapCd || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>Job Cmt</strong><br>${stop.jobComment || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>Node</strong><br>${stop.node || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>Delq</strong><br>${stop.delq || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>Dispatch Cmt</strong><br>${stop.dispatchComment || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>Receipt Cmt</strong><br>${stop.receiptComment || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>FSM Cmt</strong><br>${stop.fsmComment || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>Full Account Number</strong><br>${stop.accountNumber || 'N/A'}</div>
              <div class="sub" style="min-width:260px"><strong>Resolution Codes</strong><br>${stop.resolutionCodes || 'N/A'}</div>
            </div>
            <div class="sub" style="margin-top:12px"><strong>Description</strong><br>${(stop.description||'').trim() || 'N/A'}</div>
          </div>
        </div>`;
      const actions = `
        <button class="btn btn-success" id="jobImport">Import</button>
        <button class="btn btn-primary" id="jobAddStop">Add Stop</button>
        <button class="btn btn-warning" id="jobReassign">Reassign Jobs</button>
        <button class="btn" id="jobFixLocation">Fix Location</button>`;
      openModal('Manage Job', body, actions);
      // Fetch and hydrate additional job details from backend
      (async () => {
        try {
          if (!stop.job) return;
          const techQuery = encodeURIComponent(String(route.techNo || stop.tech || techNo || '').trim());
          const res = await fetch(`/api/job/${encodeURIComponent(stop.job)}?tech=${techQuery}&_=${Date.now()}`);
          if (!res.ok) return;
          const j = await res.json();
          // Update details if available
          const map = [
            ['Create','create'],
            ['Schedule Date (Schd)','scheduleDate'],
            ['CpTime','staticCompletionTime'],
            ['DS (Status)','staticStatus'],
            ['TS (Time Frame)','timeFrame'],
            ['Units','units'],
            ['ReaCd/ReaDesc','reason'],
            ['Addr2','address2'],
            ['City','city'],
            ['Home #','homePhone'],
            ['Work #','workPhone'],
            ['Map CD','mapCd'],
            ['Job Cmt','jobComment'],
            ['Node','node'],
            ['Delq','delq'],
            ['Dispatch Cmt','dispatchComment'],
            ['Receipt Cmt','receiptComment'],
            ['FSM Cmt','fsmComment'],
            ['Full Account Number','accountNumber'],
            ['Resolution Codes','resolutionCodes'],
            ['Customer Name','name'],
            ['Customer Phone','phone'],
            ['Address','address']
          ];
          const bodyEl = document.getElementById('modalBody');
          if (!bodyEl) return;
          let html = bodyEl.innerHTML;
          map.forEach(([label, key]) => {
            const val = j[key];
            if (!val) return;
            const re = new RegExp(`<strong>${label}<\\/strong><br>[^<]*`, 'i');
            html = html.replace(re, `<strong>${label}</strong><br>${String(val)}`);
          });
          bodyEl.innerHTML = html;
        } catch {}
      })();
      const bd = document.getElementById('modalBackdrop');
      const close = () => { bd.style.display = 'none'; };
      const toast = (msg) => { alert(msg); close(); };
      document.getElementById('jobImport').onclick = () => toast('Import triggered for job ' + (stop.job||''));
      document.getElementById('jobAddStop').onclick = () => toast('Add Stop for job ' + (stop.job||''));
      document.getElementById('jobReassign').onclick = () => toast('Reassign Jobs from job ' + (stop.job||''));
      document.getElementById('jobFixLocation').onclick = async () => {
        try {
          const cur = { lat: (stop.point&&stop.point.lat)||'', lng: (stop.point&&stop.point.lng)||'' };
          const lat = prompt('Enter latitude', String(cur.lat));
          if (lat == null) return;
          const lng = prompt('Enter longitude', String(cur.lng));
          if (lng == null) return;
          const payload = { jobId: stop.job || '', address: stop.address || '', lat: Number(lat), lng: Number(lng) };
          const res = await fetch('/api/geocode/override', { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify(payload) });
          if (!res.ok) throw new Error('HTTP ' + res.status);
          alert('Saved corrected location.');
          close();
        } catch (e) {
          alert('Failed to save location: ' + e.message);
        }
      };
    }
  </script>
</body>
</html>
