"use strict";
(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([[4358], {
    8456: function(e, t, n) {
        n.d(t, {
            $5: function() {
                return uZ
            },
            $q: function() {
                return uu
            },
            AE: function() {
                return oP
            },
            AK: function() {
                return uQ
            },
            Ab: function() {
                return uJ
            },
            B$: function() {
                return oz
            },
            Bt: function() {
                return uj
            },
            Cf: function() {
                return oF
            },
            Cy: function() {
                return u1
            },
            EK: function() {
                return z
            },
            ET: function() {
                return ub
            },
            EZ: function() {
                return A
            },
            Eo: function() {
                return oG
            },
            F8: function() {
                return lo
            },
            Fc: function() {
                return o4
            },
            G9: function() {
                return u2
            },
            GH: function() {
                return la
            },
            GK: function() {
                return q
            },
            GL: function() {
                return uS
            },
            Hp: function() {
                return uC
            },
            IO: function() {
                return lB
            },
            IX: function() {
                return oJ
            },
            Ix: function() {
                return o3
            },
            JU: function() {
                return oK
            },
            Jj: function() {
                return lr
            },
            Jm: function() {
                return ls
            },
            K9: function() {
                return x
            },
            Ky: function() {
                return W
            },
            L$: function() {
                return le
            },
            LV: function() {
                return oY
            },
            Lx: function() {
                return l2
            },
            Lz: function() {
                return li
            },
            Md: function() {
                return u7
            },
            Me: function() {
                return e9
            },
            Mu: function() {
                return P
            },
            Mx: function() {
                return o8
            },
            NS: function() {
                return u9
            },
            O$: function() {
                return lU
            },
            PL: function() {
                return up
            },
            PU: function() {
                return uz
            },
            Pb: function() {
                return o7
            },
            QT: function() {
                return ud
            },
            QX: function() {
                return ui
            },
            RA: function() {
                return o9
            },
            ST: function() {
                return o1
            },
            Sm: function() {
                return un
            },
            St: function() {
                return uF
            },
            TF: function() {
                return o6
            },
            TQ: function() {
                return l0
            },
            UQ: function() {
                return uy
            },
            Ub: function() {
                return _
            },
            Up: function() {
                return ln
            },
            W: function() {
                return uc
            },
            WA: function() {
                return C
            },
            WS: function() {
                return lt
            },
            Wi: function() {
                return oN
            },
            Wu: function() {
                return l5
            },
            Xb: function() {
                return j
            },
            Xk: function() {
                return ug
            },
            Xo: function() {
                return lW
            },
            Y8: function() {
                return ur
            },
            YF: function() {
                return lj
            },
            YW: function() {
                return uG
            },
            Yp: function() {
                return uD
            },
            _T: function() {
                return u8
            },
            ad: function() {
                return oX
            },
            ar: function() {
                return lK
            },
            at: function() {
                return oL
            },
            b9: function() {
                return lH
            },
            cC: function() {
                return u5
            },
            cf: function() {
                return uT
            },
            dL: function() {
                return lG
            },
            dX: function() {
                return us
            },
            e0: function() {
                return lZ
            },
            en: function() {
                return lX
            },
            fH: function() {
                return o2
            },
            gg: function() {
                return oH
            },
            hJ: function() {
                return oB
            },
            hx: function() {
                return oU
            },
            i3: function() {
                return u$
            },
            iE: function() {
                return o$
            },
            j5: function() {
                return uO
            },
            j6: function() {
                return ce
            },
            kl: function() {
                return um
            },
            l7: function() {
                return tl
            },
            ms: function() {
                return uM
            },
            my: function() {
                return oq
            },
            n3: function() {
                return uU
            },
            nP: function() {
                return uH
            },
            o: function() {
                return lz
            },
            o2: function() {
                return e7
            },
            oZ: function() {
                return uo
            },
            oe: function() {
                return uI
            },
            or: function() {
                return l$
            },
            p4: function() {
                return lJ
            },
            pl: function() {
                return uv
            },
            qK: function() {
                return uh
            },
            qR: function() {
                return u4
            },
            qY: function() {
                return oZ
            },
            qs: function() {
                return uX
            },
            r7: function() {
                return u_
            },
            ri: function() {
                return ll
            },
            sc: function() {
                return uE
            },
            tO: function() {
                return oW
            },
            u7: function() {
                return l7
            },
            ux: function() {
                return uV
            },
            vh: function() {
                return lY
            },
            vr: function() {
                return uW
            },
            we: function() {
                return uq
            },
            xD: function() {
                return lQ
            },
            xU: function() {
                return ul
            },
            xr: function() {
                return uY
            },
            yf: function() {
                return ua
            },
            yq: function() {
                return T
            },
            zN: function() {
                return uw
            },
            zf: function() {
                return l1
            }
        });
        var r, i, s, a, o = n(9697), l = n(8965), u = n(8667), c = n(230), h = n(7134), d = n(5916), f = n(257), m = n(6434).Buffer;
        let g = "@firebase/firestore";
        class p {
            constructor(e) {
                this.uid = e
            }
            isAuthenticated() {
                return null != this.uid
            }
            toKey() {
                return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user"
            }
            isEqual(e) {
                return e.uid === this.uid
            }
        }
        p.UNAUTHENTICATED = new p(null),
        p.GOOGLE_CREDENTIALS = new p("google-credentials-uid"),
        p.FIRST_PARTY = new p("first-party-uid"),
        p.MOCK_USER = new p("mock-user");
        let y = "10.14.0"
          , w = new u.Yd("@firebase/firestore");
        function v() {
            return w.logLevel
        }
        function _(e) {
            w.setLogLevel(e)
        }
        function I(e, ...t) {
            if (w.logLevel <= u.in.DEBUG) {
                let n = t.map(E);
                w.debug(`Firestore (${y}): ${e}`, ...n)
            }
        }
        function b(e, ...t) {
            if (w.logLevel <= u.in.ERROR) {
                let n = t.map(E);
                w.error(`Firestore (${y}): ${e}`, ...n)
            }
        }
        function T(e, ...t) {
            if (w.logLevel <= u.in.WARN) {
                let n = t.map(E);
                w.warn(`Firestore (${y}): ${e}`, ...n)
            }
        }
        function E(e) {
            if ("string" == typeof e)
                return e;
            try {
                return JSON.stringify(e)
            } catch (t) {
                return e
            }
        }
        function S(e="Unexpected state") {
            let t = `FIRESTORE (${y}) INTERNAL ASSERTION FAILED: ` + e;
            throw b(t),
            Error(t)
        }
        function x(e, t) {
            e || S()
        }
        let D = {
            OK: "ok",
            CANCELLED: "cancelled",
            UNKNOWN: "unknown",
            INVALID_ARGUMENT: "invalid-argument",
            DEADLINE_EXCEEDED: "deadline-exceeded",
            NOT_FOUND: "not-found",
            ALREADY_EXISTS: "already-exists",
            PERMISSION_DENIED: "permission-denied",
            UNAUTHENTICATED: "unauthenticated",
            RESOURCE_EXHAUSTED: "resource-exhausted",
            FAILED_PRECONDITION: "failed-precondition",
            ABORTED: "aborted",
            OUT_OF_RANGE: "out-of-range",
            UNIMPLEMENTED: "unimplemented",
            INTERNAL: "internal",
            UNAVAILABLE: "unavailable",
            DATA_LOSS: "data-loss"
        };
        class C extends c.ZR {
            constructor(e, t) {
                super(e, t),
                this.code = e,
                this.message = t,
                this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`
            }
        }
        class N {
            constructor() {
                this.promise = new Promise( (e, t) => {
                    this.resolve = e,
                    this.reject = t
                }
                )
            }
        }
        class k {
            constructor(e, t) {
                this.user = t,
                this.type = "OAuth",
                this.headers = new Map,
                this.headers.set("Authorization", `Bearer ${e}`)
            }
        }
        class A {
            getToken() {
                return Promise.resolve(null)
            }
            invalidateToken() {}
            start(e, t) {
                e.enqueueRetryable( () => t(p.UNAUTHENTICATED))
            }
            shutdown() {}
        }
        class R {
            constructor(e) {
                this.token = e,
                this.changeListener = null
            }
            getToken() {
                return Promise.resolve(this.token)
            }
            invalidateToken() {}
            start(e, t) {
                this.changeListener = t,
                e.enqueueRetryable( () => t(this.token.user))
            }
            shutdown() {
                this.changeListener = null
            }
        }
        class F {
            constructor(e) {
                this.t = e,
                this.currentUser = p.UNAUTHENTICATED,
                this.i = 0,
                this.forceRefresh = !1,
                this.auth = null
            }
            start(e, t) {
                void 0 === this.o || S();
                let n = this.i
                  , r = e => this.i !== n ? (n = this.i,
                t(e)) : Promise.resolve()
                  , i = new N;
                this.o = () => {
                    this.i++,
                    this.currentUser = this.u(),
                    i.resolve(),
                    i = new N,
                    e.enqueueRetryable( () => r(this.currentUser))
                }
                ;
                let s = () => {
                    let t = i;
                    e.enqueueRetryable(async () => {
                        await t.promise,
                        await r(this.currentUser)
                    }
                    )
                }
                  , a = e => {
                    I("FirebaseAuthCredentialsProvider", "Auth detected"),
                    this.auth = e,
                    this.o && (this.auth.addAuthTokenListener(this.o),
                    s())
                }
                ;
                this.t.onInit(e => a(e)),
                setTimeout( () => {
                    if (!this.auth) {
                        let e = this.t.getImmediate({
                            optional: !0
                        });
                        e ? a(e) : (I("FirebaseAuthCredentialsProvider", "Auth not yet detected"),
                        i.resolve(),
                        i = new N)
                    }
                }
                , 0),
                s()
            }
            getToken() {
                let e = this.i
                  , t = this.forceRefresh;
                return this.forceRefresh = !1,
                this.auth ? this.auth.getToken(t).then(t => this.i !== e ? (I("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."),
                this.getToken()) : t ? ("string" == typeof t.accessToken || S(),
                new k(t.accessToken,this.currentUser)) : null) : Promise.resolve(null)
            }
            invalidateToken() {
                this.forceRefresh = !0
            }
            shutdown() {
                this.auth && this.o && this.auth.removeAuthTokenListener(this.o),
                this.o = void 0
            }
            u() {
                let e = this.auth && this.auth.getUid();
                return null === e || "string" == typeof e || S(),
                new p(e)
            }
        }
        class V {
            constructor(e, t, n) {
                this.l = e,
                this.h = t,
                this.P = n,
                this.type = "FirstParty",
                this.user = p.FIRST_PARTY,
                this.I = new Map
            }
            T() {
                return this.P ? this.P() : null
            }
            get headers() {
                this.I.set("X-Goog-AuthUser", this.l);
                let e = this.T();
                return e && this.I.set("Authorization", e),
                this.h && this.I.set("X-Goog-Iam-Authorization-Token", this.h),
                this.I
            }
        }
        class M {
            constructor(e, t, n) {
                this.l = e,
                this.h = t,
                this.P = n
            }
            getToken() {
                return Promise.resolve(new V(this.l,this.h,this.P))
            }
            start(e, t) {
                e.enqueueRetryable( () => t(p.FIRST_PARTY))
            }
            shutdown() {}
            invalidateToken() {}
        }
        class O {
            constructor(e) {
                this.value = e,
                this.type = "AppCheck",
                this.headers = new Map,
                e && e.length > 0 && this.headers.set("x-firebase-appcheck", this.value)
            }
        }
        class L {
            constructor(e) {
                this.A = e,
                this.forceRefresh = !1,
                this.appCheck = null,
                this.R = null
            }
            start(e, t) {
                void 0 === this.o || S();
                let n = e => {
                    null != e.error && I("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${e.error.message}`);
                    let n = e.token !== this.R;
                    return this.R = e.token,
                    I("FirebaseAppCheckTokenProvider", `Received ${n ? "new" : "existing"} token.`),
                    n ? t(e.token) : Promise.resolve()
                }
                ;
                this.o = t => {
                    e.enqueueRetryable( () => n(t))
                }
                ;
                let r = e => {
                    I("FirebaseAppCheckTokenProvider", "AppCheck detected"),
                    this.appCheck = e,
                    this.o && this.appCheck.addTokenListener(this.o)
                }
                ;
                this.A.onInit(e => r(e)),
                setTimeout( () => {
                    if (!this.appCheck) {
                        let e = this.A.getImmediate({
                            optional: !0
                        });
                        e ? r(e) : I("FirebaseAppCheckTokenProvider", "AppCheck not yet detected")
                    }
                }
                , 0)
            }
            getToken() {
                let e = this.forceRefresh;
                return this.forceRefresh = !1,
                this.appCheck ? this.appCheck.getToken(e).then(e => e ? ("string" == typeof e.token || S(),
                this.R = e.token,
                new O(e.token)) : null) : Promise.resolve(null)
            }
            invalidateToken() {
                this.forceRefresh = !0
            }
            shutdown() {
                this.appCheck && this.o && this.appCheck.removeTokenListener(this.o),
                this.o = void 0
            }
        }
        class P {
            getToken() {
                return Promise.resolve(new O(""))
            }
            invalidateToken() {}
            start(e, t) {}
            shutdown() {}
        }
        class q {
            static newId() {
                let e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
                  , t = Math.floor(256 / e.length) * e.length
                  , n = "";
                for (; n.length < 20; ) {
                    let r = function(e) {
                        let t = "undefined" != typeof self && (self.crypto || self.msCrypto)
                          , n = new Uint8Array(40);
                        if (t && "function" == typeof t.getRandomValues)
                            t.getRandomValues(n);
                        else
                            for (let e = 0; e < 40; e++)
                                n[e] = Math.floor(256 * Math.random());
                        return n
                    }(0);
                    for (let i = 0; i < r.length; ++i)
                        n.length < 20 && r[i] < t && (n += e.charAt(r[i] % e.length))
                }
                return n
            }
        }
        function U(e, t) {
            return e < t ? -1 : e > t ? 1 : 0
        }
        function B(e, t, n) {
            return e.length === t.length && e.every( (e, r) => n(e, t[r]))
        }
        class z {
            constructor(e, t) {
                if (this.seconds = e,
                this.nanoseconds = t,
                t < 0 || t >= 1e9)
                    throw new C(D.INVALID_ARGUMENT,"Timestamp nanoseconds out of range: " + t);
                if (e < -62135596800 || e >= 253402300800)
                    throw new C(D.INVALID_ARGUMENT,"Timestamp seconds out of range: " + e)
            }
            static now() {
                return z.fromMillis(Date.now())
            }
            static fromDate(e) {
                return z.fromMillis(e.getTime())
            }
            static fromMillis(e) {
                let t = Math.floor(e / 1e3);
                return new z(t,Math.floor(1e6 * (e - 1e3 * t)))
            }
            toDate() {
                return new Date(this.toMillis())
            }
            toMillis() {
                return 1e3 * this.seconds + this.nanoseconds / 1e6
            }
            _compareTo(e) {
                return this.seconds === e.seconds ? U(this.nanoseconds, e.nanoseconds) : U(this.seconds, e.seconds)
            }
            isEqual(e) {
                return e.seconds === this.seconds && e.nanoseconds === this.nanoseconds
            }
            toString() {
                return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")"
            }
            toJSON() {
                return {
                    seconds: this.seconds,
                    nanoseconds: this.nanoseconds
                }
            }
            valueOf() {
                return String(this.seconds - -62135596800).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0")
            }
        }
        class K {
            constructor(e) {
                this.timestamp = e
            }
            static fromTimestamp(e) {
                return new K(e)
            }
            static min() {
                return new K(new z(0,0))
            }
            static max() {
                return new K(new z(253402300799,999999999))
            }
            compareTo(e) {
                return this.timestamp._compareTo(e.timestamp)
            }
            isEqual(e) {
                return this.timestamp.isEqual(e.timestamp)
            }
            toMicroseconds() {
                return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3
            }
            toString() {
                return "SnapshotVersion(" + this.timestamp.toString() + ")"
            }
            toTimestamp() {
                return this.timestamp
            }
        }
        class G {
            constructor(e, t, n) {
                void 0 === t ? t = 0 : t > e.length && S(),
                void 0 === n ? n = e.length - t : n > e.length - t && S(),
                this.segments = e,
                this.offset = t,
                this.len = n
            }
            get length() {
                return this.len
            }
            isEqual(e) {
                return 0 === G.comparator(this, e)
            }
            child(e) {
                let t = this.segments.slice(this.offset, this.limit());
                return e instanceof G ? e.forEach(e => {
                    t.push(e)
                }
                ) : t.push(e),
                this.construct(t)
            }
            limit() {
                return this.offset + this.length
            }
            popFirst(e) {
                return e = void 0 === e ? 1 : e,
                this.construct(this.segments, this.offset + e, this.length - e)
            }
            popLast() {
                return this.construct(this.segments, this.offset, this.length - 1)
            }
            firstSegment() {
                return this.segments[this.offset]
            }
            lastSegment() {
                return this.get(this.length - 1)
            }
            get(e) {
                return this.segments[this.offset + e]
            }
            isEmpty() {
                return 0 === this.length
            }
            isPrefixOf(e) {
                if (e.length < this.length)
                    return !1;
                for (let t = 0; t < this.length; t++)
                    if (this.get(t) !== e.get(t))
                        return !1;
                return !0
            }
            isImmediateParentOf(e) {
                if (this.length + 1 !== e.length)
                    return !1;
                for (let t = 0; t < this.length; t++)
                    if (this.get(t) !== e.get(t))
                        return !1;
                return !0
            }
            forEach(e) {
                for (let t = this.offset, n = this.limit(); t < n; t++)
                    e(this.segments[t])
            }
            toArray() {
                return this.segments.slice(this.offset, this.limit())
            }
            static comparator(e, t) {
                let n = Math.min(e.length, t.length);
                for (let r = 0; r < n; r++) {
                    let n = e.get(r)
                      , i = t.get(r);
                    if (n < i)
                        return -1;
                    if (n > i)
                        return 1
                }
                return e.length < t.length ? -1 : e.length > t.length ? 1 : 0
            }
        }
        class $ extends G {
            construct(e, t, n) {
                return new $(e,t,n)
            }
            canonicalString() {
                return this.toArray().join("/")
            }
            toString() {
                return this.canonicalString()
            }
            toUriEncodedString() {
                return this.toArray().map(encodeURIComponent).join("/")
            }
            static fromString(...e) {
                let t = [];
                for (let n of e) {
                    if (n.indexOf("//") >= 0)
                        throw new C(D.INVALID_ARGUMENT,`Invalid segment (${n}). Paths must not contain // in them.`);
                    t.push(...n.split("/").filter(e => e.length > 0))
                }
                return new $(t)
            }
            static emptyPath() {
                return new $([])
            }
        }
        let Q = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
        class j extends G {
            construct(e, t, n) {
                return new j(e,t,n)
            }
            static isValidIdentifier(e) {
                return Q.test(e)
            }
            canonicalString() {
                return this.toArray().map(e => (e = e.replace(/\\/g, "\\\\").replace(/`/g, "\\`"),
                j.isValidIdentifier(e) || (e = "`" + e + "`"),
                e)).join(".")
            }
            toString() {
                return this.canonicalString()
            }
            isKeyField() {
                return 1 === this.length && "__name__" === this.get(0)
            }
            static keyField() {
                return new j(["__name__"])
            }
            static fromServerFormat(e) {
                let t = []
                  , n = ""
                  , r = 0
                  , i = () => {
                    if (0 === n.length)
                        throw new C(D.INVALID_ARGUMENT,`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
                    t.push(n),
                    n = ""
                }
                  , s = !1;
                for (; r < e.length; ) {
                    let t = e[r];
                    if ("\\" === t) {
                        if (r + 1 === e.length)
                            throw new C(D.INVALID_ARGUMENT,"Path has trailing escape character: " + e);
                        let t = e[r + 1];
                        if ("\\" !== t && "." !== t && "`" !== t)
                            throw new C(D.INVALID_ARGUMENT,"Path has invalid escape sequence: " + e);
                        n += t,
                        r += 2
                    } else
                        "`" === t ? s = !s : "." !== t || s ? n += t : i(),
                        r++
                }
                if (i(),
                s)
                    throw new C(D.INVALID_ARGUMENT,"Unterminated ` in path: " + e);
                return new j(t)
            }
            static emptyPath() {
                return new j([])
            }
        }
        class W {
            constructor(e) {
                this.path = e
            }
            static fromPath(e) {
                return new W($.fromString(e))
            }
            static fromName(e) {
                return new W($.fromString(e).popFirst(5))
            }
            static empty() {
                return new W($.emptyPath())
            }
            get collectionGroup() {
                return this.path.popLast().lastSegment()
            }
            hasCollectionId(e) {
                return this.path.length >= 2 && this.path.get(this.path.length - 2) === e
            }
            getCollectionGroup() {
                return this.path.get(this.path.length - 2)
            }
            getCollectionPath() {
                return this.path.popLast()
            }
            isEqual(e) {
                return null !== e && 0 === $.comparator(this.path, e.path)
            }
            toString() {
                return this.path.toString()
            }
            static comparator(e, t) {
                return $.comparator(e.path, t.path)
            }
            static isDocumentKey(e) {
                return e.length % 2 == 0
            }
            static fromSegments(e) {
                return new W(new $(e.slice()))
            }
        }
        class J {
            constructor(e, t, n, r) {
                this.indexId = e,
                this.collectionGroup = t,
                this.fields = n,
                this.indexState = r
            }
        }
        function H(e) {
            return e.fields.find(e => 2 === e.kind)
        }
        function Y(e) {
            return e.fields.filter(e => 2 !== e.kind)
        }
        function X(e, t) {
            let n = U(e.collectionGroup, t.collectionGroup);
            if (0 !== n)
                return n;
            for (let r = 0; r < Math.min(e.fields.length, t.fields.length); ++r)
                if (0 !== (n = function(e, t) {
                    let n = j.comparator(e.fieldPath, t.fieldPath);
                    return 0 !== n ? n : U(e.kind, t.kind)
                }(e.fields[r], t.fields[r])))
                    return n;
            return U(e.fields.length, t.fields.length)
        }
        J.UNKNOWN_ID = -1;
        class Z {
            constructor(e, t) {
                this.fieldPath = e,
                this.kind = t
            }
        }
        class ee {
            constructor(e, t) {
                this.sequenceNumber = e,
                this.offset = t
            }
            static empty() {
                return new ee(0,er.min())
            }
        }
        function et(e, t) {
            let n = e.toTimestamp().seconds
              , r = e.toTimestamp().nanoseconds + 1;
            return new er(K.fromTimestamp(1e9 === r ? new z(n + 1,0) : new z(n,r)),W.empty(),t)
        }
        function en(e) {
            return new er(e.readTime,e.key,-1)
        }
        class er {
            constructor(e, t, n) {
                this.readTime = e,
                this.documentKey = t,
                this.largestBatchId = n
            }
            static min() {
                return new er(K.min(),W.empty(),-1)
            }
            static max() {
                return new er(K.max(),W.empty(),-1)
            }
        }
        function ei(e, t) {
            let n = e.readTime.compareTo(t.readTime);
            return 0 !== n ? n : 0 !== (n = W.comparator(e.documentKey, t.documentKey)) ? n : U(e.largestBatchId, t.largestBatchId)
        }
        let es = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
        class ea {
            constructor() {
                this.onCommittedListeners = []
            }
            addOnCommittedListener(e) {
                this.onCommittedListeners.push(e)
            }
            raiseOnCommittedEvent() {
                this.onCommittedListeners.forEach(e => e())
            }
        }
        async function eo(e) {
            if (e.code !== D.FAILED_PRECONDITION || e.message !== es)
                throw e;
            I("LocalStore", "Unexpectedly lost primary lease")
        }
        class el {
            constructor(e) {
                this.nextCallback = null,
                this.catchCallback = null,
                this.result = void 0,
                this.error = void 0,
                this.isDone = !1,
                this.callbackAttached = !1,
                e(e => {
                    this.isDone = !0,
                    this.result = e,
                    this.nextCallback && this.nextCallback(e)
                }
                , e => {
                    this.isDone = !0,
                    this.error = e,
                    this.catchCallback && this.catchCallback(e)
                }
                )
            }
            catch(e) {
                return this.next(void 0, e)
            }
            next(e, t) {
                return this.callbackAttached && S(),
                this.callbackAttached = !0,
                this.isDone ? this.error ? this.wrapFailure(t, this.error) : this.wrapSuccess(e, this.result) : new el( (n, r) => {
                    this.nextCallback = t => {
                        this.wrapSuccess(e, t).next(n, r)
                    }
                    ,
                    this.catchCallback = e => {
                        this.wrapFailure(t, e).next(n, r)
                    }
                }
                )
            }
            toPromise() {
                return new Promise( (e, t) => {
                    this.next(e, t)
                }
                )
            }
            wrapUserFunction(e) {
                try {
                    let t = e();
                    return t instanceof el ? t : el.resolve(t)
                } catch (e) {
                    return el.reject(e)
                }
            }
            wrapSuccess(e, t) {
                return e ? this.wrapUserFunction( () => e(t)) : el.resolve(t)
            }
            wrapFailure(e, t) {
                return e ? this.wrapUserFunction( () => e(t)) : el.reject(t)
            }
            static resolve(e) {
                return new el( (t, n) => {
                    t(e)
                }
                )
            }
            static reject(e) {
                return new el( (t, n) => {
                    n(e)
                }
                )
            }
            static waitFor(e) {
                return new el( (t, n) => {
                    let r = 0
                      , i = 0
                      , s = !1;
                    e.forEach(e => {
                        ++r,
                        e.next( () => {
                            ++i,
                            s && i === r && t()
                        }
                        , e => n(e))
                    }
                    ),
                    s = !0,
                    i === r && t()
                }
                )
            }
            static or(e) {
                let t = el.resolve(!1);
                for (let n of e)
                    t = t.next(e => e ? el.resolve(e) : n());
                return t
            }
            static forEach(e, t) {
                let n = [];
                return e.forEach( (e, r) => {
                    n.push(t.call(this, e, r))
                }
                ),
                this.waitFor(n)
            }
            static mapArray(e, t) {
                return new el( (n, r) => {
                    let i = e.length
                      , s = Array(i)
                      , a = 0;
                    for (let o = 0; o < i; o++) {
                        let l = o;
                        t(e[l]).next(e => {
                            s[l] = e,
                            ++a === i && n(s)
                        }
                        , e => r(e))
                    }
                }
                )
            }
            static doWhile(e, t) {
                return new el( (n, r) => {
                    let i = () => {
                        !0 === e() ? t().next( () => {
                            i()
                        }
                        , r) : n()
                    }
                    ;
                    i()
                }
                )
            }
        }
        class eu {
            constructor(e, t) {
                this.action = e,
                this.transaction = t,
                this.aborted = !1,
                this.V = new N,
                this.transaction.oncomplete = () => {
                    this.V.resolve()
                }
                ,
                this.transaction.onabort = () => {
                    t.error ? this.V.reject(new ef(e,t.error)) : this.V.resolve()
                }
                ,
                this.transaction.onerror = t => {
                    let n = ew(t.target.error);
                    this.V.reject(new ef(e,n))
                }
            }
            static open(e, t, n, r) {
                try {
                    return new eu(t,e.transaction(r, n))
                } catch (e) {
                    throw new ef(t,e)
                }
            }
            get m() {
                return this.V.promise
            }
            abort(e) {
                e && this.V.reject(e),
                this.aborted || (I("SimpleDb", "Aborting transaction:", e ? e.message : "Client-initiated abort"),
                this.aborted = !0,
                this.transaction.abort())
            }
            g() {
                let e = this.transaction;
                this.aborted || "function" != typeof e.commit || e.commit()
            }
            store(e) {
                return new eg(this.transaction.objectStore(e))
            }
        }
        class ec {
            constructor(e, t, n) {
                this.name = e,
                this.version = t,
                this.p = n,
                12.2 === ec.S((0,
                c.z$)()) && b("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.")
            }
            static delete(e) {
                return I("SimpleDb", "Removing database:", e),
                ep(window.indexedDB.deleteDatabase(e)).toPromise()
            }
            static D() {
                if (!(0,
                c.hl)())
                    return !1;
                if (ec.v())
                    return !0;
                let e = (0,
                c.z$)()
                  , t = ec.S(e)
                  , n = eh(e);
                return !(e.indexOf("MSIE ") > 0 || e.indexOf("Trident/") > 0 || e.indexOf("Edge/") > 0 || 0 < t && t < 10 || 0 < n && n < 4.5)
            }
            static v() {
                var e;
                return void 0 !== f && "YES" === (null === (e = f.__PRIVATE_env) || void 0 === e ? void 0 : e.C)
            }
            static F(e, t) {
                return e.store(t)
            }
            static S(e) {
                let t = e.match(/i(?:phone|pad|pod) os ([\d_]+)/i);
                return Number(t ? t[1].split("_").slice(0, 2).join(".") : "-1")
            }
            async M(e) {
                return this.db || (I("SimpleDb", "Opening database:", this.name),
                this.db = await new Promise( (t, n) => {
                    let r = indexedDB.open(this.name, this.version);
                    r.onsuccess = e => {
                        t(e.target.result)
                    }
                    ,
                    r.onblocked = () => {
                        n(new ef(e,"Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."))
                    }
                    ,
                    r.onerror = t => {
                        let r = t.target.error;
                        "VersionError" === r.name ? n(new C(D.FAILED_PRECONDITION,"A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.")) : "InvalidStateError" === r.name ? n(new C(D.FAILED_PRECONDITION,"Unable to open an IndexedDB connection. This could be due to running in a private browsing session on a browser whose private browsing sessions do not support IndexedDB: " + r)) : n(new ef(e,r))
                    }
                    ,
                    r.onupgradeneeded = e => {
                        I("SimpleDb", 'Database "' + this.name + '" requires upgrade from version:', e.oldVersion);
                        let t = e.target.result;
                        this.p.O(t, r.transaction, e.oldVersion, this.version).next( () => {
                            I("SimpleDb", "Database upgrade to version " + this.version + " complete")
                        }
                        )
                    }
                }
                )),
                this.N && (this.db.onversionchange = e => this.N(e)),
                this.db
            }
            L(e) {
                this.N = e,
                this.db && (this.db.onversionchange = t => e(t))
            }
            async runTransaction(e, t, n, r) {
                let i = "readonly" === t
                  , s = 0;
                for (; ; ) {
                    ++s;
                    try {
                        this.db = await this.M(e);
                        let t = eu.open(this.db, e, i ? "readonly" : "readwrite", n)
                          , s = r(t).next(e => (t.g(),
                        e)).catch(e => (t.abort(e),
                        el.reject(e))).toPromise();
                        return s.catch( () => {}
                        ),
                        await t.m,
                        s
                    } catch (t) {
                        let e = "FirebaseError" !== t.name && s < 3;
                        if (I("SimpleDb", "Transaction failed with error:", t.message, "Retrying:", e),
                        this.close(),
                        !e)
                            return Promise.reject(t)
                    }
                }
            }
            close() {
                this.db && this.db.close(),
                this.db = void 0
            }
        }
        function eh(e) {
            let t = e.match(/Android ([\d.]+)/i);
            return Number(t ? t[1].split(".").slice(0, 2).join(".") : "-1")
        }
        class ed {
            constructor(e) {
                this.B = e,
                this.k = !1,
                this.q = null
            }
            get isDone() {
                return this.k
            }
            get K() {
                return this.q
            }
            set cursor(e) {
                this.B = e
            }
            done() {
                this.k = !0
            }
            $(e) {
                this.q = e
            }
            delete() {
                return ep(this.B.delete())
            }
        }
        class ef extends C {
            constructor(e, t) {
                super(D.UNAVAILABLE, `IndexedDB transaction '${e}' failed: ${t}`),
                this.name = "IndexedDbTransactionError"
            }
        }
        function em(e) {
            return "IndexedDbTransactionError" === e.name
        }
        class eg {
            constructor(e) {
                this.store = e
            }
            put(e, t) {
                let n;
                return void 0 !== t ? (I("SimpleDb", "PUT", this.store.name, e, t),
                n = this.store.put(t, e)) : (I("SimpleDb", "PUT", this.store.name, "<auto-key>", e),
                n = this.store.put(e)),
                ep(n)
            }
            add(e) {
                return I("SimpleDb", "ADD", this.store.name, e, e),
                ep(this.store.add(e))
            }
            get(e) {
                return ep(this.store.get(e)).next(t => (void 0 === t && (t = null),
                I("SimpleDb", "GET", this.store.name, e, t),
                t))
            }
            delete(e) {
                return I("SimpleDb", "DELETE", this.store.name, e),
                ep(this.store.delete(e))
            }
            count() {
                return I("SimpleDb", "COUNT", this.store.name),
                ep(this.store.count())
            }
            U(e, t) {
                let n = this.options(e, t)
                  , r = n.index ? this.store.index(n.index) : this.store;
                if ("function" == typeof r.getAll) {
                    let e = r.getAll(n.range);
                    return new el( (t, n) => {
                        e.onerror = e => {
                            n(e.target.error)
                        }
                        ,
                        e.onsuccess = e => {
                            t(e.target.result)
                        }
                    }
                    )
                }
                {
                    let e = this.cursor(n)
                      , t = [];
                    return this.W(e, (e, n) => {
                        t.push(n)
                    }
                    ).next( () => t)
                }
            }
            G(e, t) {
                let n = this.store.getAll(e, null === t ? void 0 : t);
                return new el( (e, t) => {
                    n.onerror = e => {
                        t(e.target.error)
                    }
                    ,
                    n.onsuccess = t => {
                        e(t.target.result)
                    }
                }
                )
            }
            j(e, t) {
                I("SimpleDb", "DELETE ALL", this.store.name);
                let n = this.options(e, t);
                n.H = !1;
                let r = this.cursor(n);
                return this.W(r, (e, t, n) => n.delete())
            }
            J(e, t) {
                let n;
                t ? n = e : (n = {},
                t = e);
                let r = this.cursor(n);
                return this.W(r, t)
            }
            Y(e) {
                let t = this.cursor({});
                return new el( (n, r) => {
                    t.onerror = e => {
                        r(ew(e.target.error))
                    }
                    ,
                    t.onsuccess = t => {
                        let r = t.target.result;
                        r ? e(r.primaryKey, r.value).next(e => {
                            e ? r.continue() : n()
                        }
                        ) : n()
                    }
                }
                )
            }
            W(e, t) {
                let n = [];
                return new el( (r, i) => {
                    e.onerror = e => {
                        i(e.target.error)
                    }
                    ,
                    e.onsuccess = e => {
                        let i = e.target.result;
                        if (!i)
                            return void r();
                        let s = new ed(i)
                          , a = t(i.primaryKey, i.value, s);
                        if (a instanceof el) {
                            let e = a.catch(e => (s.done(),
                            el.reject(e)));
                            n.push(e)
                        }
                        s.isDone ? r() : null === s.K ? i.continue() : i.continue(s.K)
                    }
                }
                ).next( () => el.waitFor(n))
            }
            options(e, t) {
                let n;
                return void 0 !== e && ("string" == typeof e ? n = e : t = e),
                {
                    index: n,
                    range: t
                }
            }
            cursor(e) {
                let t = "next";
                if (e.reverse && (t = "prev"),
                e.index) {
                    let n = this.store.index(e.index);
                    return e.H ? n.openKeyCursor(e.range, t) : n.openCursor(e.range, t)
                }
                return this.store.openCursor(e.range, t)
            }
        }
        function ep(e) {
            return new el( (t, n) => {
                e.onsuccess = e => {
                    t(e.target.result)
                }
                ,
                e.onerror = e => {
                    n(ew(e.target.error))
                }
            }
            )
        }
        let ey = !1;
        function ew(e) {
            let t = ec.S((0,
            c.z$)());
            if (t >= 12.2 && t < 13) {
                let t = "An internal error was encountered in the Indexed Database server";
                if (e.message.indexOf(t) >= 0) {
                    let e = new C("internal",`IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${t}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`);
                    return ey || (ey = !0,
                    setTimeout( () => {
                        throw e
                    }
                    , 0)),
                    e
                }
            }
            return e
        }
        class ev {
            constructor(e, t) {
                this.asyncQueue = e,
                this.Z = t,
                this.task = null
            }
            start() {
                this.X(15e3)
            }
            stop() {
                this.task && (this.task.cancel(),
                this.task = null)
            }
            get started() {
                return null !== this.task
            }
            X(e) {
                I("IndexBackfiller", `Scheduled in ${e}ms`),
                this.task = this.asyncQueue.enqueueAfterDelay("index_backfill", e, async () => {
                    this.task = null;
                    try {
                        I("IndexBackfiller", `Documents written: ${await this.Z.ee()}`)
                    } catch (e) {
                        em(e) ? I("IndexBackfiller", "Ignoring IndexedDB error during index backfill: ", e) : await eo(e)
                    }
                    await this.X(6e4)
                }
                )
            }
        }
        class e_ {
            constructor(e, t) {
                this.localStore = e,
                this.persistence = t
            }
            async ee(e=50) {
                return this.persistence.runTransaction("Backfill Indexes", "readwrite-primary", t => this.te(t, e))
            }
            te(e, t) {
                let n = new Set
                  , r = t
                  , i = !0;
                return el.doWhile( () => !0 === i && r > 0, () => this.localStore.indexManager.getNextCollectionGroupToUpdate(e).next(t => {
                    if (null !== t && !n.has(t))
                        return I("IndexBackfiller", `Processing collection: ${t}`),
                        this.ne(e, t, r).next(e => {
                            r -= e,
                            n.add(t)
                        }
                        );
                    i = !1
                }
                )).next( () => t - r)
            }
            ne(e, t, n) {
                return this.localStore.indexManager.getMinOffsetFromCollectionGroup(e, t).next(r => this.localStore.localDocuments.getNextDocuments(e, t, r, n).next(n => {
                    let i = n.changes;
                    return this.localStore.indexManager.updateIndexEntries(e, i).next( () => this.re(r, n)).next(n => (I("IndexBackfiller", `Updating offset: ${n}`),
                    this.localStore.indexManager.updateCollectionGroup(e, t, n))).next( () => i.size)
                }
                ))
            }
            re(e, t) {
                let n = e;
                return t.changes.forEach( (e, t) => {
                    let r = en(t);
                    ei(r, n) > 0 && (n = r)
                }
                ),
                new er(n.readTime,n.documentKey,Math.max(t.batchId, e.largestBatchId))
            }
        }
        class eI {
            constructor(e, t) {
                this.previousValue = e,
                t && (t.sequenceNumberHandler = e => this.ie(e),
                this.se = e => t.writeSequenceNumber(e))
            }
            ie(e) {
                return this.previousValue = Math.max(e, this.previousValue),
                this.previousValue
            }
            next() {
                let e = ++this.previousValue;
                return this.se && this.se(e),
                e
            }
        }
        function eb(e) {
            return null == e
        }
        function eT(e) {
            return 0 === e && 1 / e == -1 / 0
        }
        function eE(e) {
            return "number" == typeof e && Number.isInteger(e) && !eT(e) && e <= Number.MAX_SAFE_INTEGER && e >= Number.MIN_SAFE_INTEGER
        }
        function eS(e) {
            let t = "";
            for (let n = 0; n < e.length; n++)
                t.length > 0 && (t += "\x01\x01"),
                t = function(e, t) {
                    let n = t
                      , r = e.length;
                    for (let t = 0; t < r; t++) {
                        let r = e.charAt(t);
                        switch (r) {
                        case "\0":
                            n += "\x01\x10";
                            break;
                        case "\x01":
                            n += "\x01\x11";
                            break;
                        default:
                            n += r
                        }
                    }
                    return n
                }(e.get(n), t);
            return t + "\x01\x01"
        }
        function ex(e) {
            let t = e.length;
            if (t >= 2 || S(),
            2 === t)
                return "\x01" === e.charAt(0) && "\x01" === e.charAt(1) || S(),
                $.emptyPath();
            let n = t - 2
              , r = []
              , i = "";
            for (let s = 0; s < t; ) {
                let t = e.indexOf("\x01", s);
                switch ((t < 0 || t > n) && S(),
                e.charAt(t + 1)) {
                case "\x01":
                    let a;
                    let o = e.substring(s, t);
                    0 === i.length ? a = o : (i += o,
                    a = i,
                    i = ""),
                    r.push(a);
                    break;
                case "\x10":
                    i += e.substring(s, t) + "\0";
                    break;
                case "\x11":
                    i += e.substring(s, t + 1);
                    break;
                default:
                    S()
                }
                s = t + 2
            }
            return new $(r)
        }
        eI.oe = -1;
        let eD = ["userId", "batchId"]
          , eC = {}
          , eN = ["prefixPath", "collectionGroup", "readTime", "documentId"]
          , ek = ["prefixPath", "collectionGroup", "documentId"]
          , eA = ["collectionGroup", "readTime", "prefixPath", "documentId"]
          , eR = ["canonicalId", "targetId"]
          , eF = ["targetId", "path"]
          , eV = ["path", "targetId"]
          , eM = ["collectionId", "parent"]
          , eO = ["indexId", "uid"]
          , eL = ["uid", "sequenceNumber"]
          , eP = ["indexId", "uid", "arrayValue", "directionalValue", "orderedDocumentKey", "documentKey"]
          , eq = ["indexId", "uid", "orderedDocumentKey"]
          , eU = ["userId", "collectionPath", "documentId"]
          , eB = ["userId", "collectionPath", "largestBatchId"]
          , ez = ["userId", "collectionGroup", "largestBatchId"]
          , eK = ["mutationQueues", "mutations", "documentMutations", "remoteDocuments", "targets", "owner", "targetGlobal", "targetDocuments", "clientMetadata", "remoteDocumentGlobal", "collectionParents", "bundles", "namedQueries"]
          , eG = [...eK, "documentOverlays"]
          , e$ = ["mutationQueues", "mutations", "documentMutations", "remoteDocumentsV14", "targets", "owner", "targetGlobal", "targetDocuments", "clientMetadata", "remoteDocumentGlobal", "collectionParents", "bundles", "namedQueries", "documentOverlays"]
          , eQ = [...e$, "indexConfiguration", "indexState", "indexEntries"]
          , ej = [...eQ, "globals"];
        class eW extends ea {
            constructor(e, t) {
                super(),
                this._e = e,
                this.currentSequenceNumber = t
            }
        }
        function eJ(e, t) {
            return ec.F(e._e, t)
        }
        function eH(e) {
            let t = 0;
            for (let n in e)
                Object.prototype.hasOwnProperty.call(e, n) && t++;
            return t
        }
        function eY(e, t) {
            for (let n in e)
                Object.prototype.hasOwnProperty.call(e, n) && t(n, e[n])
        }
        function eX(e, t) {
            let n = [];
            for (let r in e)
                Object.prototype.hasOwnProperty.call(e, r) && n.push(t(e[r], r, e));
            return n
        }
        function eZ(e) {
            for (let t in e)
                if (Object.prototype.hasOwnProperty.call(e, t))
                    return !1;
            return !0
        }
        class e0 {
            constructor(e, t) {
                this.comparator = e,
                this.root = t || e2.EMPTY
            }
            insert(e, t) {
                return new e0(this.comparator,this.root.insert(e, t, this.comparator).copy(null, null, e2.BLACK, null, null))
            }
            remove(e) {
                return new e0(this.comparator,this.root.remove(e, this.comparator).copy(null, null, e2.BLACK, null, null))
            }
            get(e) {
                let t = this.root;
                for (; !t.isEmpty(); ) {
                    let n = this.comparator(e, t.key);
                    if (0 === n)
                        return t.value;
                    n < 0 ? t = t.left : n > 0 && (t = t.right)
                }
                return null
            }
            indexOf(e) {
                let t = 0
                  , n = this.root;
                for (; !n.isEmpty(); ) {
                    let r = this.comparator(e, n.key);
                    if (0 === r)
                        return t + n.left.size;
                    r < 0 ? n = n.left : (t += n.left.size + 1,
                    n = n.right)
                }
                return -1
            }
            isEmpty() {
                return this.root.isEmpty()
            }
            get size() {
                return this.root.size
            }
            minKey() {
                return this.root.minKey()
            }
            maxKey() {
                return this.root.maxKey()
            }
            inorderTraversal(e) {
                return this.root.inorderTraversal(e)
            }
            forEach(e) {
                this.inorderTraversal( (t, n) => (e(t, n),
                !1))
            }
            toString() {
                let e = [];
                return this.inorderTraversal( (t, n) => (e.push(`${t}:${n}`),
                !1)),
                `{${e.join(", ")}}`
            }
            reverseTraversal(e) {
                return this.root.reverseTraversal(e)
            }
            getIterator() {
                return new e1(this.root,null,this.comparator,!1)
            }
            getIteratorFrom(e) {
                return new e1(this.root,e,this.comparator,!1)
            }
            getReverseIterator() {
                return new e1(this.root,null,this.comparator,!0)
            }
            getReverseIteratorFrom(e) {
                return new e1(this.root,e,this.comparator,!0)
            }
        }
        class e1 {
            constructor(e, t, n, r) {
                this.isReverse = r,
                this.nodeStack = [];
                let i = 1;
                for (; !e.isEmpty(); )
                    if (i = t ? n(e.key, t) : 1,
                    t && r && (i *= -1),
                    i < 0)
                        e = this.isReverse ? e.left : e.right;
                    else {
                        if (0 === i) {
                            this.nodeStack.push(e);
                            break
                        }
                        this.nodeStack.push(e),
                        e = this.isReverse ? e.right : e.left
                    }
            }
            getNext() {
                let e = this.nodeStack.pop()
                  , t = {
                    key: e.key,
                    value: e.value
                };
                if (this.isReverse)
                    for (e = e.left; !e.isEmpty(); )
                        this.nodeStack.push(e),
                        e = e.right;
                else
                    for (e = e.right; !e.isEmpty(); )
                        this.nodeStack.push(e),
                        e = e.left;
                return t
            }
            hasNext() {
                return this.nodeStack.length > 0
            }
            peek() {
                if (0 === this.nodeStack.length)
                    return null;
                let e = this.nodeStack[this.nodeStack.length - 1];
                return {
                    key: e.key,
                    value: e.value
                }
            }
        }
        class e2 {
            constructor(e, t, n, r, i) {
                this.key = e,
                this.value = t,
                this.color = null != n ? n : e2.RED,
                this.left = null != r ? r : e2.EMPTY,
                this.right = null != i ? i : e2.EMPTY,
                this.size = this.left.size + 1 + this.right.size
            }
            copy(e, t, n, r, i) {
                return new e2(null != e ? e : this.key,null != t ? t : this.value,null != n ? n : this.color,null != r ? r : this.left,null != i ? i : this.right)
            }
            isEmpty() {
                return !1
            }
            inorderTraversal(e) {
                return this.left.inorderTraversal(e) || e(this.key, this.value) || this.right.inorderTraversal(e)
            }
            reverseTraversal(e) {
                return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e)
            }
            min() {
                return this.left.isEmpty() ? this : this.left.min()
            }
            minKey() {
                return this.min().key
            }
            maxKey() {
                return this.right.isEmpty() ? this.key : this.right.maxKey()
            }
            insert(e, t, n) {
                let r = this
                  , i = n(e, r.key);
                return (r = i < 0 ? r.copy(null, null, null, r.left.insert(e, t, n), null) : 0 === i ? r.copy(null, t, null, null, null) : r.copy(null, null, null, null, r.right.insert(e, t, n))).fixUp()
            }
            removeMin() {
                if (this.left.isEmpty())
                    return e2.EMPTY;
                let e = this;
                return e.left.isRed() || e.left.left.isRed() || (e = e.moveRedLeft()),
                (e = e.copy(null, null, null, e.left.removeMin(), null)).fixUp()
            }
            remove(e, t) {
                let n, r = this;
                if (0 > t(e, r.key))
                    r.left.isEmpty() || r.left.isRed() || r.left.left.isRed() || (r = r.moveRedLeft()),
                    r = r.copy(null, null, null, r.left.remove(e, t), null);
                else {
                    if (r.left.isRed() && (r = r.rotateRight()),
                    r.right.isEmpty() || r.right.isRed() || r.right.left.isRed() || (r = r.moveRedRight()),
                    0 === t(e, r.key)) {
                        if (r.right.isEmpty())
                            return e2.EMPTY;
                        n = r.right.min(),
                        r = r.copy(n.key, n.value, null, null, r.right.removeMin())
                    }
                    r = r.copy(null, null, null, null, r.right.remove(e, t))
                }
                return r.fixUp()
            }
            isRed() {
                return this.color
            }
            fixUp() {
                let e = this;
                return e.right.isRed() && !e.left.isRed() && (e = e.rotateLeft()),
                e.left.isRed() && e.left.left.isRed() && (e = e.rotateRight()),
                e.left.isRed() && e.right.isRed() && (e = e.colorFlip()),
                e
            }
            moveRedLeft() {
                let e = this.colorFlip();
                return e.right.left.isRed() && (e = (e = (e = e.copy(null, null, null, null, e.right.rotateRight())).rotateLeft()).colorFlip()),
                e
            }
            moveRedRight() {
                let e = this.colorFlip();
                return e.left.left.isRed() && (e = (e = e.rotateRight()).colorFlip()),
                e
            }
            rotateLeft() {
                let e = this.copy(null, null, e2.RED, null, this.right.left);
                return this.right.copy(null, null, this.color, e, null)
            }
            rotateRight() {
                let e = this.copy(null, null, e2.RED, this.left.right, null);
                return this.left.copy(null, null, this.color, null, e)
            }
            colorFlip() {
                let e = this.left.copy(null, null, !this.left.color, null, null)
                  , t = this.right.copy(null, null, !this.right.color, null, null);
                return this.copy(null, null, !this.color, e, t)
            }
            checkMaxDepth() {
                return Math.pow(2, this.check()) <= this.size + 1
            }
            check() {
                if (this.isRed() && this.left.isRed() || this.right.isRed())
                    throw S();
                let e = this.left.check();
                if (e !== this.right.check())
                    throw S();
                return e + (this.isRed() ? 0 : 1)
            }
        }
        e2.EMPTY = null,
        e2.RED = !0,
        e2.BLACK = !1,
        e2.EMPTY = new class {
            constructor() {
                this.size = 0
            }
            get key() {
                throw S()
            }
            get value() {
                throw S()
            }
            get color() {
                throw S()
            }
            get left() {
                throw S()
            }
            get right() {
                throw S()
            }
            copy(e, t, n, r, i) {
                return this
            }
            insert(e, t, n) {
                return new e2(e,t)
            }
            remove(e, t) {
                return this
            }
            isEmpty() {
                return !0
            }
            inorderTraversal(e) {
                return !1
            }
            reverseTraversal(e) {
                return !1
            }
            minKey() {
                return null
            }
            maxKey() {
                return null
            }
            isRed() {
                return !1
            }
            checkMaxDepth() {
                return !0
            }
            check() {
                return 0
            }
        }
        ;
        class e5 {
            constructor(e) {
                this.comparator = e,
                this.data = new e0(this.comparator)
            }
            has(e) {
                return null !== this.data.get(e)
            }
            first() {
                return this.data.minKey()
            }
            last() {
                return this.data.maxKey()
            }
            get size() {
                return this.data.size
            }
            indexOf(e) {
                return this.data.indexOf(e)
            }
            forEach(e) {
                this.data.inorderTraversal( (t, n) => (e(t),
                !1))
            }
            forEachInRange(e, t) {
                let n = this.data.getIteratorFrom(e[0]);
                for (; n.hasNext(); ) {
                    let r = n.getNext();
                    if (this.comparator(r.key, e[1]) >= 0)
                        return;
                    t(r.key)
                }
            }
            forEachWhile(e, t) {
                let n;
                for (n = void 0 !== t ? this.data.getIteratorFrom(t) : this.data.getIterator(); n.hasNext(); )
                    if (!e(n.getNext().key))
                        return
            }
            firstAfterOrEqual(e) {
                let t = this.data.getIteratorFrom(e);
                return t.hasNext() ? t.getNext().key : null
            }
            getIterator() {
                return new e4(this.data.getIterator())
            }
            getIteratorFrom(e) {
                return new e4(this.data.getIteratorFrom(e))
            }
            add(e) {
                return this.copy(this.data.remove(e).insert(e, !0))
            }
            delete(e) {
                return this.has(e) ? this.copy(this.data.remove(e)) : this
            }
            isEmpty() {
                return this.data.isEmpty()
            }
            unionWith(e) {
                let t = this;
                return t.size < e.size && (t = e,
                e = this),
                e.forEach(e => {
                    t = t.add(e)
                }
                ),
                t
            }
            isEqual(e) {
                if (!(e instanceof e5) || this.size !== e.size)
                    return !1;
                let t = this.data.getIterator()
                  , n = e.data.getIterator();
                for (; t.hasNext(); ) {
                    let e = t.getNext().key
                      , r = n.getNext().key;
                    if (0 !== this.comparator(e, r))
                        return !1
                }
                return !0
            }
            toArray() {
                let e = [];
                return this.forEach(t => {
                    e.push(t)
                }
                ),
                e
            }
            toString() {
                let e = [];
                return this.forEach(t => e.push(t)),
                "SortedSet(" + e.toString() + ")"
            }
            copy(e) {
                let t = new e5(this.comparator);
                return t.data = e,
                t
            }
        }
        class e4 {
            constructor(e) {
                this.iter = e
            }
            getNext() {
                return this.iter.getNext().key
            }
            hasNext() {
                return this.iter.hasNext()
            }
        }
        function e8(e) {
            return e.hasNext() ? e.getNext() : void 0
        }
        class e3 {
            constructor(e) {
                this.fields = e,
                e.sort(j.comparator)
            }
            static empty() {
                return new e3([])
            }
            unionWith(e) {
                let t = new e5(j.comparator);
                for (let e of this.fields)
                    t = t.add(e);
                for (let n of e)
                    t = t.add(n);
                return new e3(t.toArray())
            }
            covers(e) {
                for (let t of this.fields)
                    if (t.isPrefixOf(e))
                        return !0;
                return !1
            }
            isEqual(e) {
                return B(this.fields, e.fields, (e, t) => e.isEqual(t))
            }
        }
        class e6 extends Error {
            constructor() {
                super(...arguments),
                this.name = "Base64DecodeError"
            }
        }
        function e9() {
            return "undefined" != typeof atob
        }
        class e7 {
            constructor(e) {
                this.binaryString = e
            }
            static fromBase64String(e) {
                return new e7(function(e) {
                    try {
                        return atob(e)
                    } catch (e) {
                        throw "undefined" != typeof DOMException && e instanceof DOMException ? new e6("Invalid base64 string: " + e) : e
                    }
                }(e))
            }
            static fromUint8Array(e) {
                return new e7(function(e) {
                    let t = "";
                    for (let n = 0; n < e.length; ++n)
                        t += String.fromCharCode(e[n]);
                    return t
                }(e))
            }
            [Symbol.iterator]() {
                let e = 0;
                return {
                    next: () => e < this.binaryString.length ? {
                        value: this.binaryString.charCodeAt(e++),
                        done: !1
                    } : {
                        value: void 0,
                        done: !0
                    }
                }
            }
            toBase64() {
                return btoa(this.binaryString)
            }
            toUint8Array() {
                return function(e) {
                    let t = new Uint8Array(e.length);
                    for (let n = 0; n < e.length; n++)
                        t[n] = e.charCodeAt(n);
                    return t
                }(this.binaryString)
            }
            approximateByteSize() {
                return 2 * this.binaryString.length
            }
            compareTo(e) {
                return U(this.binaryString, e.binaryString)
            }
            isEqual(e) {
                return this.binaryString === e.binaryString
            }
        }
        e7.EMPTY_BYTE_STRING = new e7("");
        let te = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
        function tt(e) {
            if (e || S(),
            "string" == typeof e) {
                let t = 0
                  , n = te.exec(e);
                if (n || S(),
                n[1]) {
                    let e = n[1];
                    t = Number(e = (e + "000000000").substr(0, 9))
                }
                return {
                    seconds: Math.floor(new Date(e).getTime() / 1e3),
                    nanos: t
                }
            }
            return {
                seconds: tn(e.seconds),
                nanos: tn(e.nanos)
            }
        }
        function tn(e) {
            return "number" == typeof e ? e : "string" == typeof e ? Number(e) : 0
        }
        function tr(e) {
            return "string" == typeof e ? e7.fromBase64String(e) : e7.fromUint8Array(e)
        }
        function ti(e) {
            var t, n;
            return "server_timestamp" === (null === (n = ((null === (t = null == e ? void 0 : e.mapValue) || void 0 === t ? void 0 : t.fields) || {}).__type__) || void 0 === n ? void 0 : n.stringValue)
        }
        function ts(e) {
            let t = e.mapValue.fields.__previous_value__;
            return ti(t) ? ts(t) : t
        }
        function ta(e) {
            let t = tt(e.mapValue.fields.__local_write_time__.timestampValue);
            return new z(t.seconds,t.nanos)
        }
        class to {
            constructor(e, t, n, r, i, s, a, o, l) {
                this.databaseId = e,
                this.appId = t,
                this.persistenceKey = n,
                this.host = r,
                this.ssl = i,
                this.forceLongPolling = s,
                this.autoDetectLongPolling = a,
                this.longPollingOptions = o,
                this.useFetchStreams = l
            }
        }
        class tl {
            constructor(e, t) {
                this.projectId = e,
                this.database = t || "(default)"
            }
            static empty() {
                return new tl("","")
            }
            get isDefaultDatabase() {
                return "(default)" === this.database
            }
            isEqual(e) {
                return e instanceof tl && e.projectId === this.projectId && e.database === this.database
            }
        }
        let tu = {
            mapValue: {
                fields: {
                    __type__: {
                        stringValue: "__max__"
                    }
                }
            }
        }
          , tc = {
            nullValue: "NULL_VALUE"
        };
        function th(e) {
            return "nullValue"in e ? 0 : "booleanValue"in e ? 1 : "integerValue"in e || "doubleValue"in e ? 2 : "timestampValue"in e ? 3 : "stringValue"in e ? 5 : "bytesValue"in e ? 6 : "referenceValue"in e ? 7 : "geoPointValue"in e ? 8 : "arrayValue"in e ? 9 : "mapValue"in e ? ti(e) ? 4 : tx(e) ? 9007199254740991 : tE(e) ? 10 : 11 : S()
        }
        function td(e, t) {
            if (e === t)
                return !0;
            let n = th(e);
            if (n !== th(t))
                return !1;
            switch (n) {
            case 0:
            case 9007199254740991:
                return !0;
            case 1:
                return e.booleanValue === t.booleanValue;
            case 4:
                return ta(e).isEqual(ta(t));
            case 3:
                return function(e, t) {
                    if ("string" == typeof e.timestampValue && "string" == typeof t.timestampValue && e.timestampValue.length === t.timestampValue.length)
                        return e.timestampValue === t.timestampValue;
                    let n = tt(e.timestampValue)
                      , r = tt(t.timestampValue);
                    return n.seconds === r.seconds && n.nanos === r.nanos
                }(e, t);
            case 5:
                return e.stringValue === t.stringValue;
            case 6:
                return tr(e.bytesValue).isEqual(tr(t.bytesValue));
            case 7:
                return e.referenceValue === t.referenceValue;
            case 8:
                return tn(e.geoPointValue.latitude) === tn(t.geoPointValue.latitude) && tn(e.geoPointValue.longitude) === tn(t.geoPointValue.longitude);
            case 2:
                return function(e, t) {
                    if ("integerValue"in e && "integerValue"in t)
                        return tn(e.integerValue) === tn(t.integerValue);
                    if ("doubleValue"in e && "doubleValue"in t) {
                        let n = tn(e.doubleValue)
                          , r = tn(t.doubleValue);
                        return n === r ? eT(n) === eT(r) : isNaN(n) && isNaN(r)
                    }
                    return !1
                }(e, t);
            case 9:
                return B(e.arrayValue.values || [], t.arrayValue.values || [], td);
            case 10:
            case 11:
                return function(e, t) {
                    let n = e.mapValue.fields || {}
                      , r = t.mapValue.fields || {};
                    if (eH(n) !== eH(r))
                        return !1;
                    for (let e in n)
                        if (n.hasOwnProperty(e) && (void 0 === r[e] || !td(n[e], r[e])))
                            return !1;
                    return !0
                }(e, t);
            default:
                return S()
            }
        }
        function tf(e, t) {
            return void 0 !== (e.values || []).find(e => td(e, t))
        }
        function tm(e, t) {
            if (e === t)
                return 0;
            let n = th(e)
              , r = th(t);
            if (n !== r)
                return U(n, r);
            switch (n) {
            case 0:
            case 9007199254740991:
                return 0;
            case 1:
                return U(e.booleanValue, t.booleanValue);
            case 2:
                return function(e, t) {
                    let n = tn(e.integerValue || e.doubleValue)
                      , r = tn(t.integerValue || t.doubleValue);
                    return n < r ? -1 : n > r ? 1 : n === r ? 0 : isNaN(n) ? isNaN(r) ? 0 : -1 : 1
                }(e, t);
            case 3:
                return tg(e.timestampValue, t.timestampValue);
            case 4:
                return tg(ta(e), ta(t));
            case 5:
                return U(e.stringValue, t.stringValue);
            case 6:
                return function(e, t) {
                    let n = tr(e)
                      , r = tr(t);
                    return n.compareTo(r)
                }(e.bytesValue, t.bytesValue);
            case 7:
                return function(e, t) {
                    let n = e.split("/")
                      , r = t.split("/");
                    for (let e = 0; e < n.length && e < r.length; e++) {
                        let t = U(n[e], r[e]);
                        if (0 !== t)
                            return t
                    }
                    return U(n.length, r.length)
                }(e.referenceValue, t.referenceValue);
            case 8:
                return function(e, t) {
                    let n = U(tn(e.latitude), tn(t.latitude));
                    return 0 !== n ? n : U(tn(e.longitude), tn(t.longitude))
                }(e.geoPointValue, t.geoPointValue);
            case 9:
                return tp(e.arrayValue, t.arrayValue);
            case 10:
                return function(e, t) {
                    var n, r, i, s;
                    let a = e.fields || {}
                      , o = t.fields || {}
                      , l = null === (n = a.value) || void 0 === n ? void 0 : n.arrayValue
                      , u = null === (r = o.value) || void 0 === r ? void 0 : r.arrayValue
                      , c = U((null === (i = null == l ? void 0 : l.values) || void 0 === i ? void 0 : i.length) || 0, (null === (s = null == u ? void 0 : u.values) || void 0 === s ? void 0 : s.length) || 0);
                    return 0 !== c ? c : tp(l, u)
                }(e.mapValue, t.mapValue);
            case 11:
                return function(e, t) {
                    if (e === tu.mapValue && t === tu.mapValue)
                        return 0;
                    if (e === tu.mapValue)
                        return 1;
                    if (t === tu.mapValue)
                        return -1;
                    let n = e.fields || {}
                      , r = Object.keys(n)
                      , i = t.fields || {}
                      , s = Object.keys(i);
                    r.sort(),
                    s.sort();
                    for (let e = 0; e < r.length && e < s.length; ++e) {
                        let t = U(r[e], s[e]);
                        if (0 !== t)
                            return t;
                        let a = tm(n[r[e]], i[s[e]]);
                        if (0 !== a)
                            return a
                    }
                    return U(r.length, s.length)
                }(e.mapValue, t.mapValue);
            default:
                throw S()
            }
        }
        function tg(e, t) {
            if ("string" == typeof e && "string" == typeof t && e.length === t.length)
                return U(e, t);
            let n = tt(e)
              , r = tt(t)
              , i = U(n.seconds, r.seconds);
            return 0 !== i ? i : U(n.nanos, r.nanos)
        }
        function tp(e, t) {
            let n = e.values || []
              , r = t.values || [];
            for (let e = 0; e < n.length && e < r.length; ++e) {
                let t = tm(n[e], r[e]);
                if (t)
                    return t
            }
            return U(n.length, r.length)
        }
        function ty(e) {
            var t, n;
            return "nullValue"in e ? "null" : "booleanValue"in e ? "" + e.booleanValue : "integerValue"in e ? "" + e.integerValue : "doubleValue"in e ? "" + e.doubleValue : "timestampValue"in e ? function(e) {
                let t = tt(e);
                return `time(${t.seconds},${t.nanos})`
            }(e.timestampValue) : "stringValue"in e ? e.stringValue : "bytesValue"in e ? tr(e.bytesValue).toBase64() : "referenceValue"in e ? (t = e.referenceValue,
            W.fromName(t).toString()) : "geoPointValue"in e ? (n = e.geoPointValue,
            `geo(${n.latitude},${n.longitude})`) : "arrayValue"in e ? function(e) {
                let t = "["
                  , n = !0;
                for (let r of e.values || [])
                    n ? n = !1 : t += ",",
                    t += ty(r);
                return t + "]"
            }(e.arrayValue) : "mapValue"in e ? function(e) {
                let t = Object.keys(e.fields || {}).sort()
                  , n = "{"
                  , r = !0;
                for (let i of t)
                    r ? r = !1 : n += ",",
                    n += `${i}:${ty(e.fields[i])}`;
                return n + "}"
            }(e.mapValue) : S()
        }
        function tw(e, t) {
            return {
                referenceValue: `projects/${e.projectId}/databases/${e.database}/documents/${t.path.canonicalString()}`
            }
        }
        function tv(e) {
            return !!e && "integerValue"in e
        }
        function t_(e) {
            return !!e && "arrayValue"in e
        }
        function tI(e) {
            return !!e && "nullValue"in e
        }
        function tb(e) {
            return !!e && "doubleValue"in e && isNaN(Number(e.doubleValue))
        }
        function tT(e) {
            return !!e && "mapValue"in e
        }
        function tE(e) {
            var t, n;
            return "__vector__" === (null === (n = ((null === (t = null == e ? void 0 : e.mapValue) || void 0 === t ? void 0 : t.fields) || {}).__type__) || void 0 === n ? void 0 : n.stringValue)
        }
        function tS(e) {
            if (e.geoPointValue)
                return {
                    geoPointValue: Object.assign({}, e.geoPointValue)
                };
            if (e.timestampValue && "object" == typeof e.timestampValue)
                return {
                    timestampValue: Object.assign({}, e.timestampValue)
                };
            if (e.mapValue) {
                let t = {
                    mapValue: {
                        fields: {}
                    }
                };
                return eY(e.mapValue.fields, (e, n) => t.mapValue.fields[e] = tS(n)),
                t
            }
            if (e.arrayValue) {
                let t = {
                    arrayValue: {
                        values: []
                    }
                };
                for (let n = 0; n < (e.arrayValue.values || []).length; ++n)
                    t.arrayValue.values[n] = tS(e.arrayValue.values[n]);
                return t
            }
            return Object.assign({}, e)
        }
        function tx(e) {
            return "__max__" === (((e.mapValue || {}).fields || {}).__type__ || {}).stringValue
        }
        let tD = {
            mapValue: {
                fields: {
                    __type__: {
                        stringValue: "__vector__"
                    },
                    value: {
                        arrayValue: {}
                    }
                }
            }
        };
        function tC(e, t) {
            let n = tm(e.value, t.value);
            return 0 !== n ? n : e.inclusive && !t.inclusive ? -1 : !e.inclusive && t.inclusive ? 1 : 0
        }
        function tN(e, t) {
            let n = tm(e.value, t.value);
            return 0 !== n ? n : e.inclusive && !t.inclusive ? 1 : !e.inclusive && t.inclusive ? -1 : 0
        }
        class tk {
            constructor(e) {
                this.value = e
            }
            static empty() {
                return new tk({
                    mapValue: {}
                })
            }
            field(e) {
                if (e.isEmpty())
                    return this.value;
                {
                    let t = this.value;
                    for (let n = 0; n < e.length - 1; ++n)
                        if (!tT(t = (t.mapValue.fields || {})[e.get(n)]))
                            return null;
                    return (t = (t.mapValue.fields || {})[e.lastSegment()]) || null
                }
            }
            set(e, t) {
                this.getFieldsMap(e.popLast())[e.lastSegment()] = tS(t)
            }
            setAll(e) {
                let t = j.emptyPath()
                  , n = {}
                  , r = [];
                e.forEach( (e, i) => {
                    if (!t.isImmediateParentOf(i)) {
                        let e = this.getFieldsMap(t);
                        this.applyChanges(e, n, r),
                        n = {},
                        r = [],
                        t = i.popLast()
                    }
                    e ? n[i.lastSegment()] = tS(e) : r.push(i.lastSegment())
                }
                );
                let i = this.getFieldsMap(t);
                this.applyChanges(i, n, r)
            }
            delete(e) {
                let t = this.field(e.popLast());
                tT(t) && t.mapValue.fields && delete t.mapValue.fields[e.lastSegment()]
            }
            isEqual(e) {
                return td(this.value, e.value)
            }
            getFieldsMap(e) {
                let t = this.value;
                t.mapValue.fields || (t.mapValue = {
                    fields: {}
                });
                for (let n = 0; n < e.length; ++n) {
                    let r = t.mapValue.fields[e.get(n)];
                    tT(r) && r.mapValue.fields || (r = {
                        mapValue: {
                            fields: {}
                        }
                    },
                    t.mapValue.fields[e.get(n)] = r),
                    t = r
                }
                return t.mapValue.fields
            }
            applyChanges(e, t, n) {
                for (let r of (eY(t, (t, n) => e[t] = n),
                n))
                    delete e[r]
            }
            clone() {
                return new tk(tS(this.value))
            }
        }
        class tA {
            constructor(e, t, n, r, i, s, a) {
                this.key = e,
                this.documentType = t,
                this.version = n,
                this.readTime = r,
                this.createTime = i,
                this.data = s,
                this.documentState = a
            }
            static newInvalidDocument(e) {
                return new tA(e,0,K.min(),K.min(),K.min(),tk.empty(),0)
            }
            static newFoundDocument(e, t, n, r) {
                return new tA(e,1,t,K.min(),n,r,0)
            }
            static newNoDocument(e, t) {
                return new tA(e,2,t,K.min(),K.min(),tk.empty(),0)
            }
            static newUnknownDocument(e, t) {
                return new tA(e,3,t,K.min(),K.min(),tk.empty(),2)
            }
            convertToFoundDocument(e, t) {
                return this.createTime.isEqual(K.min()) && (2 === this.documentType || 0 === this.documentType) && (this.createTime = e),
                this.version = e,
                this.documentType = 1,
                this.data = t,
                this.documentState = 0,
                this
            }
            convertToNoDocument(e) {
                return this.version = e,
                this.documentType = 2,
                this.data = tk.empty(),
                this.documentState = 0,
                this
            }
            convertToUnknownDocument(e) {
                return this.version = e,
                this.documentType = 3,
                this.data = tk.empty(),
                this.documentState = 2,
                this
            }
            setHasCommittedMutations() {
                return this.documentState = 2,
                this
            }
            setHasLocalMutations() {
                return this.documentState = 1,
                this.version = K.min(),
                this
            }
            setReadTime(e) {
                return this.readTime = e,
                this
            }
            get hasLocalMutations() {
                return 1 === this.documentState
            }
            get hasCommittedMutations() {
                return 2 === this.documentState
            }
            get hasPendingWrites() {
                return this.hasLocalMutations || this.hasCommittedMutations
            }
            isValidDocument() {
                return 0 !== this.documentType
            }
            isFoundDocument() {
                return 1 === this.documentType
            }
            isNoDocument() {
                return 2 === this.documentType
            }
            isUnknownDocument() {
                return 3 === this.documentType
            }
            isEqual(e) {
                return e instanceof tA && this.key.isEqual(e.key) && this.version.isEqual(e.version) && this.documentType === e.documentType && this.documentState === e.documentState && this.data.isEqual(e.data)
            }
            mutableCopy() {
                return new tA(this.key,this.documentType,this.version,this.readTime,this.createTime,this.data.clone(),this.documentState)
            }
            toString() {
                return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`
            }
        }
        class tR {
            constructor(e, t) {
                this.position = e,
                this.inclusive = t
            }
        }
        function tF(e, t, n) {
            let r = 0;
            for (let i = 0; i < e.position.length; i++) {
                let s = t[i]
                  , a = e.position[i];
                if (r = s.field.isKeyField() ? W.comparator(W.fromName(a.referenceValue), n.key) : tm(a, n.data.field(s.field)),
                "desc" === s.dir && (r *= -1),
                0 !== r)
                    break
            }
            return r
        }
        function tV(e, t) {
            if (null === e)
                return null === t;
            if (null === t || e.inclusive !== t.inclusive || e.position.length !== t.position.length)
                return !1;
            for (let n = 0; n < e.position.length; n++)
                if (!td(e.position[n], t.position[n]))
                    return !1;
            return !0
        }
        class tM {
            constructor(e, t="asc") {
                this.field = e,
                this.dir = t
            }
        }
        class tO {
        }
        class tL extends tO {
            constructor(e, t, n) {
                super(),
                this.field = e,
                this.op = t,
                this.value = n
            }
            static create(e, t, n) {
                return e.isKeyField() ? "in" === t || "not-in" === t ? this.createKeyFieldInFilter(e, t, n) : new tG(e,t,n) : "array-contains" === t ? new tW(e,n) : "in" === t ? new tJ(e,n) : "not-in" === t ? new tH(e,n) : "array-contains-any" === t ? new tY(e,n) : new tL(e,t,n)
            }
            static createKeyFieldInFilter(e, t, n) {
                return "in" === t ? new t$(e,n) : new tQ(e,n)
            }
            matches(e) {
                let t = e.data.field(this.field);
                return "!=" === this.op ? null !== t && this.matchesComparison(tm(t, this.value)) : null !== t && th(this.value) === th(t) && this.matchesComparison(tm(t, this.value))
            }
            matchesComparison(e) {
                switch (this.op) {
                case "<":
                    return e < 0;
                case "<=":
                    return e <= 0;
                case "==":
                    return 0 === e;
                case "!=":
                    return 0 !== e;
                case ">":
                    return e > 0;
                case ">=":
                    return e >= 0;
                default:
                    return S()
                }
            }
            isInequality() {
                return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0
            }
            getFlattenedFilters() {
                return [this]
            }
            getFilters() {
                return [this]
            }
        }
        class tP extends tO {
            constructor(e, t) {
                super(),
                this.filters = e,
                this.op = t,
                this.ae = null
            }
            static create(e, t) {
                return new tP(e,t)
            }
            matches(e) {
                return tq(this) ? void 0 === this.filters.find(t => !t.matches(e)) : void 0 !== this.filters.find(t => t.matches(e))
            }
            getFlattenedFilters() {
                return null !== this.ae || (this.ae = this.filters.reduce( (e, t) => e.concat(t.getFlattenedFilters()), [])),
                this.ae
            }
            getFilters() {
                return Object.assign([], this.filters)
            }
        }
        function tq(e) {
            return "and" === e.op
        }
        function tU(e) {
            return "or" === e.op
        }
        function tB(e) {
            return tz(e) && tq(e)
        }
        function tz(e) {
            for (let t of e.filters)
                if (t instanceof tP)
                    return !1;
            return !0
        }
        function tK(e, t) {
            let n = e.filters.concat(t);
            return tP.create(n, e.op)
        }
        class tG extends tL {
            constructor(e, t, n) {
                super(e, t, n),
                this.key = W.fromName(n.referenceValue)
            }
            matches(e) {
                let t = W.comparator(e.key, this.key);
                return this.matchesComparison(t)
            }
        }
        class t$ extends tL {
            constructor(e, t) {
                super(e, "in", t),
                this.keys = tj("in", t)
            }
            matches(e) {
                return this.keys.some(t => t.isEqual(e.key))
            }
        }
        class tQ extends tL {
            constructor(e, t) {
                super(e, "not-in", t),
                this.keys = tj("not-in", t)
            }
            matches(e) {
                return !this.keys.some(t => t.isEqual(e.key))
            }
        }
        function tj(e, t) {
            var n;
            return ((null === (n = t.arrayValue) || void 0 === n ? void 0 : n.values) || []).map(e => W.fromName(e.referenceValue))
        }
        class tW extends tL {
            constructor(e, t) {
                super(e, "array-contains", t)
            }
            matches(e) {
                let t = e.data.field(this.field);
                return t_(t) && tf(t.arrayValue, this.value)
            }
        }
        class tJ extends tL {
            constructor(e, t) {
                super(e, "in", t)
            }
            matches(e) {
                let t = e.data.field(this.field);
                return null !== t && tf(this.value.arrayValue, t)
            }
        }
        class tH extends tL {
            constructor(e, t) {
                super(e, "not-in", t)
            }
            matches(e) {
                if (tf(this.value.arrayValue, {
                    nullValue: "NULL_VALUE"
                }))
                    return !1;
                let t = e.data.field(this.field);
                return null !== t && !tf(this.value.arrayValue, t)
            }
        }
        class tY extends tL {
            constructor(e, t) {
                super(e, "array-contains-any", t)
            }
            matches(e) {
                let t = e.data.field(this.field);
                return !(!t_(t) || !t.arrayValue.values) && t.arrayValue.values.some(e => tf(this.value.arrayValue, e))
            }
        }
        class tX {
            constructor(e, t=null, n=[], r=[], i=null, s=null, a=null) {
                this.path = e,
                this.collectionGroup = t,
                this.orderBy = n,
                this.filters = r,
                this.limit = i,
                this.startAt = s,
                this.endAt = a,
                this.ue = null
            }
        }
        function tZ(e, t=null, n=[], r=[], i=null, s=null, a=null) {
            return new tX(e,t,n,r,i,s,a)
        }
        function t0(e) {
            if (null === e.ue) {
                let t = e.path.canonicalString();
                null !== e.collectionGroup && (t += "|cg:" + e.collectionGroup),
                t += "|f:" + e.filters.map(e => (function e(t) {
                    if (t instanceof tL)
                        return t.field.canonicalString() + t.op.toString() + ty(t.value);
                    if (tB(t))
                        return t.filters.map(t => e(t)).join(",");
                    {
                        let n = t.filters.map(t => e(t)).join(",");
                        return `${t.op}(${n})`
                    }
                }
                )(e)).join(",") + "|ob:" + e.orderBy.map(e => e.field.canonicalString() + e.dir).join(","),
                eb(e.limit) || (t += "|l:" + e.limit),
                e.startAt && (t += "|lb:" + (e.startAt.inclusive ? "b:" : "a:") + e.startAt.position.map(e => ty(e)).join(",")),
                e.endAt && (t += "|ub:" + (e.endAt.inclusive ? "a:" : "b:") + e.endAt.position.map(e => ty(e)).join(",")),
                e.ue = t
            }
            return e.ue
        }
        function t1(e, t) {
            if (e.limit !== t.limit || e.orderBy.length !== t.orderBy.length)
                return !1;
            for (let i = 0; i < e.orderBy.length; i++) {
                var n, r;
                if (n = e.orderBy[i],
                r = t.orderBy[i],
                !(n.dir === r.dir && n.field.isEqual(r.field)))
                    return !1
            }
            if (e.filters.length !== t.filters.length)
                return !1;
            for (let n = 0; n < e.filters.length; n++)
                if (!function e(t, n) {
                    return t instanceof tL ? n instanceof tL && t.op === n.op && t.field.isEqual(n.field) && td(t.value, n.value) : t instanceof tP ? n instanceof tP && t.op === n.op && t.filters.length === n.filters.length && t.filters.reduce( (t, r, i) => t && e(r, n.filters[i]), !0) : void S()
                }(e.filters[n], t.filters[n]))
                    return !1;
            return e.collectionGroup === t.collectionGroup && !!e.path.isEqual(t.path) && !!tV(e.startAt, t.startAt) && tV(e.endAt, t.endAt)
        }
        function t2(e) {
            return W.isDocumentKey(e.path) && null === e.collectionGroup && 0 === e.filters.length
        }
        function t5(e, t) {
            return e.filters.filter(e => e instanceof tL && e.field.isEqual(t))
        }
        function t4(e, t, n) {
            let r = tc
              , i = !0;
            for (let n of t5(e, t)) {
                let e = tc
                  , t = !0;
                switch (n.op) {
                case "<":
                case "<=":
                    var s;
                    e = "nullValue"in (s = n.value) ? tc : "booleanValue"in s ? {
                        booleanValue: !1
                    } : "integerValue"in s || "doubleValue"in s ? {
                        doubleValue: NaN
                    } : "timestampValue"in s ? {
                        timestampValue: {
                            seconds: Number.MIN_SAFE_INTEGER
                        }
                    } : "stringValue"in s ? {
                        stringValue: ""
                    } : "bytesValue"in s ? {
                        bytesValue: ""
                    } : "referenceValue"in s ? tw(tl.empty(), W.empty()) : "geoPointValue"in s ? {
                        geoPointValue: {
                            latitude: -90,
                            longitude: -180
                        }
                    } : "arrayValue"in s ? {
                        arrayValue: {}
                    } : "mapValue"in s ? tE(s) ? tD : {
                        mapValue: {}
                    } : S();
                    break;
                case "==":
                case "in":
                case ">=":
                    e = n.value;
                    break;
                case ">":
                    e = n.value,
                    t = !1;
                    break;
                case "!=":
                case "not-in":
                    e = tc
                }
                0 > tC({
                    value: r,
                    inclusive: i
                }, {
                    value: e,
                    inclusive: t
                }) && (r = e,
                i = t)
            }
            if (null !== n) {
                for (let s = 0; s < e.orderBy.length; ++s)
                    if (e.orderBy[s].field.isEqual(t)) {
                        let e = n.position[s];
                        0 > tC({
                            value: r,
                            inclusive: i
                        }, {
                            value: e,
                            inclusive: n.inclusive
                        }) && (r = e,
                        i = n.inclusive);
                        break
                    }
            }
            return {
                value: r,
                inclusive: i
            }
        }
        function t8(e, t, n) {
            let r = tu
              , i = !0;
            for (let n of t5(e, t)) {
                let e = tu
                  , t = !0;
                switch (n.op) {
                case ">=":
                case ">":
                    var s;
                    e = "nullValue"in (s = n.value) ? {
                        booleanValue: !1
                    } : "booleanValue"in s ? {
                        doubleValue: NaN
                    } : "integerValue"in s || "doubleValue"in s ? {
                        timestampValue: {
                            seconds: Number.MIN_SAFE_INTEGER
                        }
                    } : "timestampValue"in s ? {
                        stringValue: ""
                    } : "stringValue"in s ? {
                        bytesValue: ""
                    } : "bytesValue"in s ? tw(tl.empty(), W.empty()) : "referenceValue"in s ? {
                        geoPointValue: {
                            latitude: -90,
                            longitude: -180
                        }
                    } : "geoPointValue"in s ? {
                        arrayValue: {}
                    } : "arrayValue"in s ? tD : "mapValue"in s ? tE(s) ? {
                        mapValue: {}
                    } : tu : S(),
                    t = !1;
                    break;
                case "==":
                case "in":
                case "<=":
                    e = n.value;
                    break;
                case "<":
                    e = n.value,
                    t = !1;
                    break;
                case "!=":
                case "not-in":
                    e = tu
                }
                tN({
                    value: r,
                    inclusive: i
                }, {
                    value: e,
                    inclusive: t
                }) > 0 && (r = e,
                i = t)
            }
            if (null !== n) {
                for (let s = 0; s < e.orderBy.length; ++s)
                    if (e.orderBy[s].field.isEqual(t)) {
                        let e = n.position[s];
                        tN({
                            value: r,
                            inclusive: i
                        }, {
                            value: e,
                            inclusive: n.inclusive
                        }) > 0 && (r = e,
                        i = n.inclusive);
                        break
                    }
            }
            return {
                value: r,
                inclusive: i
            }
        }
        class t3 {
            constructor(e, t=null, n=[], r=[], i=null, s="F", a=null, o=null) {
                this.path = e,
                this.collectionGroup = t,
                this.explicitOrderBy = n,
                this.filters = r,
                this.limit = i,
                this.limitType = s,
                this.startAt = a,
                this.endAt = o,
                this.ce = null,
                this.le = null,
                this.he = null,
                this.startAt,
                this.endAt
            }
        }
        function t6(e) {
            return new t3(e)
        }
        function t9(e) {
            return 0 === e.filters.length && null === e.limit && null == e.startAt && null == e.endAt && (0 === e.explicitOrderBy.length || 1 === e.explicitOrderBy.length && e.explicitOrderBy[0].field.isKeyField())
        }
        function t7(e) {
            return null !== e.collectionGroup
        }
        function ne(e) {
            if (null === e.ce) {
                let t;
                e.ce = [];
                let n = new Set;
                for (let t of e.explicitOrderBy)
                    e.ce.push(t),
                    n.add(t.field.canonicalString());
                let r = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
                (t = new e5(j.comparator),
                e.filters.forEach(e => {
                    e.getFlattenedFilters().forEach(e => {
                        e.isInequality() && (t = t.add(e.field))
                    }
                    )
                }
                ),
                t).forEach(t => {
                    n.has(t.canonicalString()) || t.isKeyField() || e.ce.push(new tM(t,r))
                }
                ),
                n.has(j.keyField().canonicalString()) || e.ce.push(new tM(j.keyField(),r))
            }
            return e.ce
        }
        function nt(e) {
            return e.le || (e.le = nr(e, ne(e))),
            e.le
        }
        function nn(e) {
            return e.he || (e.he = nr(e, e.explicitOrderBy)),
            e.he
        }
        function nr(e, t) {
            if ("F" === e.limitType)
                return tZ(e.path, e.collectionGroup, t, e.filters, e.limit, e.startAt, e.endAt);
            {
                t = t.map(e => {
                    let t = "desc" === e.dir ? "asc" : "desc";
                    return new tM(e.field,t)
                }
                );
                let n = e.endAt ? new tR(e.endAt.position,e.endAt.inclusive) : null
                  , r = e.startAt ? new tR(e.startAt.position,e.startAt.inclusive) : null;
                return tZ(e.path, e.collectionGroup, t, e.filters, e.limit, n, r)
            }
        }
        function ni(e, t) {
            let n = e.filters.concat([t]);
            return new t3(e.path,e.collectionGroup,e.explicitOrderBy.slice(),n,e.limit,e.limitType,e.startAt,e.endAt)
        }
        function ns(e, t, n) {
            return new t3(e.path,e.collectionGroup,e.explicitOrderBy.slice(),e.filters.slice(),t,n,e.startAt,e.endAt)
        }
        function na(e, t) {
            return t1(nt(e), nt(t)) && e.limitType === t.limitType
        }
        function no(e) {
            return `${t0(nt(e))}|lt:${e.limitType}`
        }
        function nl(e) {
            var t;
            let n;
            return `Query(target=${n = (t = nt(e)).path.canonicalString(),
            null !== t.collectionGroup && (n += " collectionGroup=" + t.collectionGroup),
            t.filters.length > 0 && (n += `, filters: [${t.filters.map(e => (function e(t) {
                return tinstanceof tL ? `${t.field.canonicalString()} ${t.op} ${ty(t.value)}` : t instanceof tP ? t.op.toString() + " {" + t.getFilters().map(e).join(" ,") + "}" : "Filter"
            }
            )(e)).join(", ")}]`),
            eb(t.limit) || (n += ", limit: " + t.limit),
            t.orderBy.length > 0 && (n += `, orderBy: [${t.orderBy.map(e => `${e.field.canonicalString()} (${e.dir})`).join(", ")}]`),
            t.startAt && (n += ", startAt: " + (t.startAt.inclusive ? "b:" : "a:") + t.startAt.position.map(e => ty(e)).join(",")),
            t.endAt && (n += ", endAt: " + (t.endAt.inclusive ? "a:" : "b:") + t.endAt.position.map(e => ty(e)).join(",")),
            `Target(${n})`}; limitType=${e.limitType})`
        }
        function nu(e, t) {
            return t.isFoundDocument() && function(e, t) {
                let n = t.key.path;
                return null !== e.collectionGroup ? t.key.hasCollectionId(e.collectionGroup) && e.path.isPrefixOf(n) : W.isDocumentKey(e.path) ? e.path.isEqual(n) : e.path.isImmediateParentOf(n)
            }(e, t) && function(e, t) {
                for (let n of ne(e))
                    if (!n.field.isKeyField() && null === t.data.field(n.field))
                        return !1;
                return !0
            }(e, t) && function(e, t) {
                for (let n of e.filters)
                    if (!n.matches(t))
                        return !1;
                return !0
            }(e, t) && (!e.startAt || !!function(e, t, n) {
                let r = tF(e, t, n);
                return e.inclusive ? r <= 0 : r < 0
            }(e.startAt, ne(e), t)) && (!e.endAt || !!function(e, t, n) {
                let r = tF(e, t, n);
                return e.inclusive ? r >= 0 : r > 0
            }(e.endAt, ne(e), t))
        }
        function nc(e) {
            return e.collectionGroup || (e.path.length % 2 == 1 ? e.path.lastSegment() : e.path.get(e.path.length - 2))
        }
        function nh(e) {
            return (t, n) => {
                let r = !1;
                for (let i of ne(e)) {
                    let e = function(e, t, n) {
                        let r = e.field.isKeyField() ? W.comparator(t.key, n.key) : function(e, t, n) {
                            let r = t.data.field(e)
                              , i = n.data.field(e);
                            return null !== r && null !== i ? tm(r, i) : S()
                        }(e.field, t, n);
                        switch (e.dir) {
                        case "asc":
                            return r;
                        case "desc":
                            return -1 * r;
                        default:
                            return S()
                        }
                    }(i, t, n);
                    if (0 !== e)
                        return e;
                    r = r || i.field.isKeyField()
                }
                return 0
            }
        }
        class nd {
            constructor(e, t) {
                this.mapKeyFn = e,
                this.equalsFn = t,
                this.inner = {},
                this.innerSize = 0
            }
            get(e) {
                let t = this.mapKeyFn(e)
                  , n = this.inner[t];
                if (void 0 !== n) {
                    for (let[t,r] of n)
                        if (this.equalsFn(t, e))
                            return r
                }
            }
            has(e) {
                return void 0 !== this.get(e)
            }
            set(e, t) {
                let n = this.mapKeyFn(e)
                  , r = this.inner[n];
                if (void 0 === r)
                    return this.inner[n] = [[e, t]],
                    void this.innerSize++;
                for (let n = 0; n < r.length; n++)
                    if (this.equalsFn(r[n][0], e))
                        return void (r[n] = [e, t]);
                r.push([e, t]),
                this.innerSize++
            }
            delete(e) {
                let t = this.mapKeyFn(e)
                  , n = this.inner[t];
                if (void 0 === n)
                    return !1;
                for (let r = 0; r < n.length; r++)
                    if (this.equalsFn(n[r][0], e))
                        return 1 === n.length ? delete this.inner[t] : n.splice(r, 1),
                        this.innerSize--,
                        !0;
                return !1
            }
            forEach(e) {
                eY(this.inner, (t, n) => {
                    for (let[t,r] of n)
                        e(t, r)
                }
                )
            }
            isEmpty() {
                return eZ(this.inner)
            }
            size() {
                return this.innerSize
            }
        }
        let nf = new e0(W.comparator)
          , nm = new e0(W.comparator);
        function ng(...e) {
            let t = nm;
            for (let n of e)
                t = t.insert(n.key, n);
            return t
        }
        function np(e) {
            let t = nm;
            return e.forEach( (e, n) => t = t.insert(e, n.overlayedDocument)),
            t
        }
        function ny() {
            return new nd(e => e.toString(), (e, t) => e.isEqual(t))
        }
        let nw = new e0(W.comparator)
          , nv = new e5(W.comparator);
        function n_(...e) {
            let t = nv;
            for (let n of e)
                t = t.add(n);
            return t
        }
        let nI = new e5(U);
        function nb(e, t) {
            if (e.useProto3Json) {
                if (isNaN(t))
                    return {
                        doubleValue: "NaN"
                    };
                if (t === 1 / 0)
                    return {
                        doubleValue: "Infinity"
                    };
                if (t === -1 / 0)
                    return {
                        doubleValue: "-Infinity"
                    }
            }
            return {
                doubleValue: eT(t) ? "-0" : t
            }
        }
        function nT(e) {
            return {
                integerValue: "" + e
            }
        }
        function nE(e, t) {
            return eE(t) ? nT(t) : nb(e, t)
        }
        class nS {
            constructor() {
                this._ = void 0
            }
        }
        function nx(e, t) {
            return e instanceof nR ? tv(t) || t && "doubleValue"in t ? t : {
                integerValue: 0
            } : null
        }
        class nD extends nS {
        }
        class nC extends nS {
            constructor(e) {
                super(),
                this.elements = e
            }
        }
        function nN(e, t) {
            let n = nV(t);
            for (let t of e.elements)
                n.some(e => td(e, t)) || n.push(t);
            return {
                arrayValue: {
                    values: n
                }
            }
        }
        class nk extends nS {
            constructor(e) {
                super(),
                this.elements = e
            }
        }
        function nA(e, t) {
            let n = nV(t);
            for (let t of e.elements)
                n = n.filter(e => !td(e, t));
            return {
                arrayValue: {
                    values: n
                }
            }
        }
        class nR extends nS {
            constructor(e, t) {
                super(),
                this.serializer = e,
                this.Pe = t
            }
        }
        function nF(e) {
            return tn(e.integerValue || e.doubleValue)
        }
        function nV(e) {
            return t_(e) && e.arrayValue.values ? e.arrayValue.values.slice() : []
        }
        class nM {
            constructor(e, t) {
                this.field = e,
                this.transform = t
            }
        }
        class nO {
            constructor(e, t) {
                this.version = e,
                this.transformResults = t
            }
        }
        class nL {
            constructor(e, t) {
                this.updateTime = e,
                this.exists = t
            }
            static none() {
                return new nL
            }
            static exists(e) {
                return new nL(void 0,e)
            }
            static updateTime(e) {
                return new nL(e)
            }
            get isNone() {
                return void 0 === this.updateTime && void 0 === this.exists
            }
            isEqual(e) {
                return this.exists === e.exists && (this.updateTime ? !!e.updateTime && this.updateTime.isEqual(e.updateTime) : !e.updateTime)
            }
        }
        function nP(e, t) {
            return void 0 !== e.updateTime ? t.isFoundDocument() && t.version.isEqual(e.updateTime) : void 0 === e.exists || e.exists === t.isFoundDocument()
        }
        class nq {
        }
        function nU(e, t) {
            if (!e.hasLocalMutations || t && 0 === t.fields.length)
                return null;
            if (null === t)
                return e.isNoDocument() ? new nW(e.key,nL.none()) : new nK(e.key,e.data,nL.none());
            {
                let n = e.data
                  , r = tk.empty()
                  , i = new e5(j.comparator);
                for (let e of t.fields)
                    if (!i.has(e)) {
                        let t = n.field(e);
                        null === t && e.length > 1 && (e = e.popLast(),
                        t = n.field(e)),
                        null === t ? r.delete(e) : r.set(e, t),
                        i = i.add(e)
                    }
                return new nG(e.key,r,new e3(i.toArray()),nL.none())
            }
        }
        function nB(e, t, n, r) {
            return e instanceof nK ? function(e, t, n, r) {
                if (!nP(e.precondition, t))
                    return n;
                let i = e.value.clone()
                  , s = nj(e.fieldTransforms, r, t);
                return i.setAll(s),
                t.convertToFoundDocument(t.version, i).setHasLocalMutations(),
                null
            }(e, t, n, r) : e instanceof nG ? function(e, t, n, r) {
                if (!nP(e.precondition, t))
                    return n;
                let i = nj(e.fieldTransforms, r, t)
                  , s = t.data;
                return (s.setAll(n$(e)),
                s.setAll(i),
                t.convertToFoundDocument(t.version, s).setHasLocalMutations(),
                null === n) ? null : n.unionWith(e.fieldMask.fields).unionWith(e.fieldTransforms.map(e => e.field))
            }(e, t, n, r) : nP(e.precondition, t) ? (t.convertToNoDocument(t.version).setHasLocalMutations(),
            null) : n
        }
        function nz(e, t) {
            var n, r;
            return e.type === t.type && !!e.key.isEqual(t.key) && !!e.precondition.isEqual(t.precondition) && (n = e.fieldTransforms,
            r = t.fieldTransforms,
            !!(void 0 === n && void 0 === r || !(!n || !r) && B(n, r, (e, t) => {
                var n, r;
                return e.field.isEqual(t.field) && (n = e.transform,
                r = t.transform,
                n instanceof nC && r instanceof nC || n instanceof nk && r instanceof nk ? B(n.elements, r.elements, td) : n instanceof nR && r instanceof nR ? td(n.Pe, r.Pe) : n instanceof nD && r instanceof nD)
            }
            ))) && (0 === e.type ? e.value.isEqual(t.value) : 1 !== e.type || e.data.isEqual(t.data) && e.fieldMask.isEqual(t.fieldMask))
        }
        class nK extends nq {
            constructor(e, t, n, r=[]) {
                super(),
                this.key = e,
                this.value = t,
                this.precondition = n,
                this.fieldTransforms = r,
                this.type = 0
            }
            getFieldMask() {
                return null
            }
        }
        class nG extends nq {
            constructor(e, t, n, r, i=[]) {
                super(),
                this.key = e,
                this.data = t,
                this.fieldMask = n,
                this.precondition = r,
                this.fieldTransforms = i,
                this.type = 1
            }
            getFieldMask() {
                return this.fieldMask
            }
        }
        function n$(e) {
            let t = new Map;
            return e.fieldMask.fields.forEach(n => {
                if (!n.isEmpty()) {
                    let r = e.data.field(n);
                    t.set(n, r)
                }
            }
            ),
            t
        }
        function nQ(e, t, n) {
            var r;
            let i = new Map;
            e.length === n.length || S();
            for (let s = 0; s < n.length; s++) {
                let a = e[s]
                  , o = a.transform
                  , l = t.data.field(a.field);
                i.set(a.field, (r = n[s],
                o instanceof nC ? nN(o, l) : o instanceof nk ? nA(o, l) : r))
            }
            return i
        }
        function nj(e, t, n) {
            let r = new Map;
            for (let i of e) {
                let e = i.transform
                  , s = n.data.field(i.field);
                r.set(i.field, e instanceof nD ? function(e, t) {
                    let n = {
                        fields: {
                            __type__: {
                                stringValue: "server_timestamp"
                            },
                            __local_write_time__: {
                                timestampValue: {
                                    seconds: e.seconds,
                                    nanos: e.nanoseconds
                                }
                            }
                        }
                    };
                    return t && ti(t) && (t = ts(t)),
                    t && (n.fields.__previous_value__ = t),
                    {
                        mapValue: n
                    }
                }(t, s) : e instanceof nC ? nN(e, s) : e instanceof nk ? nA(e, s) : function(e, t) {
                    let n = nx(e, t)
                      , r = nF(n) + nF(e.Pe);
                    return tv(n) && tv(e.Pe) ? nT(r) : nb(e.serializer, r)
                }(e, s))
            }
            return r
        }
        class nW extends nq {
            constructor(e, t) {
                super(),
                this.key = e,
                this.precondition = t,
                this.type = 2,
                this.fieldTransforms = []
            }
            getFieldMask() {
                return null
            }
        }
        class nJ extends nq {
            constructor(e, t) {
                super(),
                this.key = e,
                this.precondition = t,
                this.type = 3,
                this.fieldTransforms = []
            }
            getFieldMask() {
                return null
            }
        }
        class nH {
            constructor(e, t, n, r) {
                this.batchId = e,
                this.localWriteTime = t,
                this.baseMutations = n,
                this.mutations = r
            }
            applyToRemoteDocument(e, t) {
                let n = t.mutationResults;
                for (let t = 0; t < this.mutations.length; t++) {
                    let i = this.mutations[t];
                    if (i.key.isEqual(e.key)) {
                        var r;
                        r = n[t],
                        i instanceof nK ? function(e, t, n) {
                            let r = e.value.clone()
                              , i = nQ(e.fieldTransforms, t, n.transformResults);
                            r.setAll(i),
                            t.convertToFoundDocument(n.version, r).setHasCommittedMutations()
                        }(i, e, r) : i instanceof nG ? function(e, t, n) {
                            if (!nP(e.precondition, t))
                                return void t.convertToUnknownDocument(n.version);
                            let r = nQ(e.fieldTransforms, t, n.transformResults)
                              , i = t.data;
                            i.setAll(n$(e)),
                            i.setAll(r),
                            t.convertToFoundDocument(n.version, i).setHasCommittedMutations()
                        }(i, e, r) : function(e, t, n) {
                            t.convertToNoDocument(n.version).setHasCommittedMutations()
                        }(0, e, r)
                    }
                }
            }
            applyToLocalView(e, t) {
                for (let n of this.baseMutations)
                    n.key.isEqual(e.key) && (t = nB(n, e, t, this.localWriteTime));
                for (let n of this.mutations)
                    n.key.isEqual(e.key) && (t = nB(n, e, t, this.localWriteTime));
                return t
            }
            applyToLocalDocumentSet(e, t) {
                let n = ny();
                return this.mutations.forEach(r => {
                    let i = e.get(r.key)
                      , s = i.overlayedDocument
                      , a = this.applyToLocalView(s, i.mutatedFields)
                      , o = nU(s, a = t.has(r.key) ? null : a);
                    null !== o && n.set(r.key, o),
                    s.isValidDocument() || s.convertToNoDocument(K.min())
                }
                ),
                n
            }
            keys() {
                return this.mutations.reduce( (e, t) => e.add(t.key), n_())
            }
            isEqual(e) {
                return this.batchId === e.batchId && B(this.mutations, e.mutations, (e, t) => nz(e, t)) && B(this.baseMutations, e.baseMutations, (e, t) => nz(e, t))
            }
        }
        class nY {
            constructor(e, t, n, r) {
                this.batch = e,
                this.commitVersion = t,
                this.mutationResults = n,
                this.docVersions = r
            }
            static from(e, t, n) {
                e.mutations.length === n.length || S();
                let r = nw
                  , i = e.mutations;
                for (let e = 0; e < i.length; e++)
                    r = r.insert(i[e].key, n[e].version);
                return new nY(e,t,n,r)
            }
        }
        class nX {
            constructor(e, t) {
                this.largestBatchId = e,
                this.mutation = t
            }
            getKey() {
                return this.mutation.key
            }
            isEqual(e) {
                return null !== e && this.mutation === e.mutation
            }
            toString() {
                return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`
            }
        }
        class nZ {
            constructor(e, t, n) {
                this.alias = e,
                this.aggregateType = t,
                this.fieldPath = n
            }
        }
        class n0 {
            constructor(e, t) {
                this.count = e,
                this.unchangedNames = t
            }
        }
        function n1(e) {
            switch (e) {
            default:
                return S();
            case D.CANCELLED:
            case D.UNKNOWN:
            case D.DEADLINE_EXCEEDED:
            case D.RESOURCE_EXHAUSTED:
            case D.INTERNAL:
            case D.UNAVAILABLE:
            case D.UNAUTHENTICATED:
                return !1;
            case D.INVALID_ARGUMENT:
            case D.NOT_FOUND:
            case D.ALREADY_EXISTS:
            case D.PERMISSION_DENIED:
            case D.FAILED_PRECONDITION:
            case D.ABORTED:
            case D.OUT_OF_RANGE:
            case D.UNIMPLEMENTED:
            case D.DATA_LOSS:
                return !0
            }
        }
        function n2(e) {
            if (void 0 === e)
                return b("GRPC error has no .code"),
                D.UNKNOWN;
            switch (e) {
            case r.OK:
                return D.OK;
            case r.CANCELLED:
                return D.CANCELLED;
            case r.UNKNOWN:
                return D.UNKNOWN;
            case r.DEADLINE_EXCEEDED:
                return D.DEADLINE_EXCEEDED;
            case r.RESOURCE_EXHAUSTED:
                return D.RESOURCE_EXHAUSTED;
            case r.INTERNAL:
                return D.INTERNAL;
            case r.UNAVAILABLE:
                return D.UNAVAILABLE;
            case r.UNAUTHENTICATED:
                return D.UNAUTHENTICATED;
            case r.INVALID_ARGUMENT:
                return D.INVALID_ARGUMENT;
            case r.NOT_FOUND:
                return D.NOT_FOUND;
            case r.ALREADY_EXISTS:
                return D.ALREADY_EXISTS;
            case r.PERMISSION_DENIED:
                return D.PERMISSION_DENIED;
            case r.FAILED_PRECONDITION:
                return D.FAILED_PRECONDITION;
            case r.ABORTED:
                return D.ABORTED;
            case r.OUT_OF_RANGE:
                return D.OUT_OF_RANGE;
            case r.UNIMPLEMENTED:
                return D.UNIMPLEMENTED;
            case r.DATA_LOSS:
                return D.DATA_LOSS;
            default:
                return S()
            }
        }
        (i = r || (r = {}))[i.OK = 0] = "OK",
        i[i.CANCELLED = 1] = "CANCELLED",
        i[i.UNKNOWN = 2] = "UNKNOWN",
        i[i.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT",
        i[i.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED",
        i[i.NOT_FOUND = 5] = "NOT_FOUND",
        i[i.ALREADY_EXISTS = 6] = "ALREADY_EXISTS",
        i[i.PERMISSION_DENIED = 7] = "PERMISSION_DENIED",
        i[i.UNAUTHENTICATED = 16] = "UNAUTHENTICATED",
        i[i.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED",
        i[i.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION",
        i[i.ABORTED = 10] = "ABORTED",
        i[i.OUT_OF_RANGE = 11] = "OUT_OF_RANGE",
        i[i.UNIMPLEMENTED = 12] = "UNIMPLEMENTED",
        i[i.INTERNAL = 13] = "INTERNAL",
        i[i.UNAVAILABLE = 14] = "UNAVAILABLE",
        i[i.DATA_LOSS = 15] = "DATA_LOSS";
        let n5 = null;
        function n4() {
            return new TextEncoder
        }
        let n8 = new h.z8([4294967295, 4294967295],0);
        function n3(e) {
            let t = n4().encode(e)
              , n = new h.V8;
            return n.update(t),
            new Uint8Array(n.digest())
        }
        function n6(e) {
            let t = new DataView(e.buffer)
              , n = t.getUint32(0, !0)
              , r = t.getUint32(4, !0)
              , i = t.getUint32(8, !0)
              , s = t.getUint32(12, !0);
            return [new h.z8([n, r],0), new h.z8([i, s],0)]
        }
        class n9 {
            constructor(e, t, n) {
                if (this.bitmap = e,
                this.padding = t,
                this.hashCount = n,
                t < 0 || t >= 8)
                    throw new n7(`Invalid padding: ${t}`);
                if (n < 0 || e.length > 0 && 0 === this.hashCount)
                    throw new n7(`Invalid hash count: ${n}`);
                if (0 === e.length && 0 !== t)
                    throw new n7(`Invalid padding when bitmap length is 0: ${t}`);
                this.Ie = 8 * e.length - t,
                this.Te = h.z8.fromNumber(this.Ie)
            }
            Ee(e, t, n) {
                let r = e.add(t.multiply(h.z8.fromNumber(n)));
                return 1 === r.compare(n8) && (r = new h.z8([r.getBits(0), r.getBits(1)],0)),
                r.modulo(this.Te).toNumber()
            }
            de(e) {
                return 0 != (this.bitmap[Math.floor(e / 8)] & 1 << e % 8)
            }
            mightContain(e) {
                if (0 === this.Ie)
                    return !1;
                let[t,n] = n6(n3(e));
                for (let e = 0; e < this.hashCount; e++) {
                    let r = this.Ee(t, n, e);
                    if (!this.de(r))
                        return !1
                }
                return !0
            }
            static create(e, t, n) {
                let r = new n9(new Uint8Array(Math.ceil(e / 8)),e % 8 == 0 ? 0 : 8 - e % 8,t);
                return n.forEach(e => r.insert(e)),
                r
            }
            insert(e) {
                if (0 === this.Ie)
                    return;
                let[t,n] = n6(n3(e));
                for (let e = 0; e < this.hashCount; e++) {
                    let r = this.Ee(t, n, e);
                    this.Ae(r)
                }
            }
            Ae(e) {
                this.bitmap[Math.floor(e / 8)] |= 1 << e % 8
            }
        }
        class n7 extends Error {
            constructor() {
                super(...arguments),
                this.name = "BloomFilterError"
            }
        }
        class re {
            constructor(e, t, n, r, i) {
                this.snapshotVersion = e,
                this.targetChanges = t,
                this.targetMismatches = n,
                this.documentUpdates = r,
                this.resolvedLimboDocuments = i
            }
            static createSynthesizedRemoteEventForCurrentChange(e, t, n) {
                let r = new Map;
                return r.set(e, rt.createSynthesizedTargetChangeForCurrentChange(e, t, n)),
                new re(K.min(),r,new e0(U),nf,n_())
            }
        }
        class rt {
            constructor(e, t, n, r, i) {
                this.resumeToken = e,
                this.current = t,
                this.addedDocuments = n,
                this.modifiedDocuments = r,
                this.removedDocuments = i
            }
            static createSynthesizedTargetChangeForCurrentChange(e, t, n) {
                return new rt(n,t,n_(),n_(),n_())
            }
        }
        class rn {
            constructor(e, t, n, r) {
                this.Re = e,
                this.removedTargetIds = t,
                this.key = n,
                this.Ve = r
            }
        }
        class rr {
            constructor(e, t) {
                this.targetId = e,
                this.me = t
            }
        }
        class ri {
            constructor(e, t, n=e7.EMPTY_BYTE_STRING, r=null) {
                this.state = e,
                this.targetIds = t,
                this.resumeToken = n,
                this.cause = r
            }
        }
        class rs {
            constructor() {
                this.fe = 0,
                this.ge = rl(),
                this.pe = e7.EMPTY_BYTE_STRING,
                this.ye = !1,
                this.we = !0
            }
            get current() {
                return this.ye
            }
            get resumeToken() {
                return this.pe
            }
            get Se() {
                return 0 !== this.fe
            }
            get be() {
                return this.we
            }
            De(e) {
                e.approximateByteSize() > 0 && (this.we = !0,
                this.pe = e)
            }
            ve() {
                let e = n_()
                  , t = n_()
                  , n = n_();
                return this.ge.forEach( (r, i) => {
                    switch (i) {
                    case 0:
                        e = e.add(r);
                        break;
                    case 2:
                        t = t.add(r);
                        break;
                    case 1:
                        n = n.add(r);
                        break;
                    default:
                        S()
                    }
                }
                ),
                new rt(this.pe,this.ye,e,t,n)
            }
            Ce() {
                this.we = !1,
                this.ge = rl()
            }
            Fe(e, t) {
                this.we = !0,
                this.ge = this.ge.insert(e, t)
            }
            Me(e) {
                this.we = !0,
                this.ge = this.ge.remove(e)
            }
            xe() {
                this.fe += 1
            }
            Oe() {
                this.fe -= 1,
                this.fe >= 0 || S()
            }
            Ne() {
                this.we = !0,
                this.ye = !0
            }
        }
        class ra {
            constructor(e) {
                this.Le = e,
                this.Be = new Map,
                this.ke = nf,
                this.qe = ro(),
                this.Qe = new e0(U)
            }
            Ke(e) {
                for (let t of e.Re)
                    e.Ve && e.Ve.isFoundDocument() ? this.$e(t, e.Ve) : this.Ue(t, e.key, e.Ve);
                for (let t of e.removedTargetIds)
                    this.Ue(t, e.key, e.Ve)
            }
            We(e) {
                this.forEachTarget(e, t => {
                    let n = this.Ge(t);
                    switch (e.state) {
                    case 0:
                        this.ze(t) && n.De(e.resumeToken);
                        break;
                    case 1:
                        n.Oe(),
                        n.Se || n.Ce(),
                        n.De(e.resumeToken);
                        break;
                    case 2:
                        n.Oe(),
                        n.Se || this.removeTarget(t);
                        break;
                    case 3:
                        this.ze(t) && (n.Ne(),
                        n.De(e.resumeToken));
                        break;
                    case 4:
                        this.ze(t) && (this.je(t),
                        n.De(e.resumeToken));
                        break;
                    default:
                        S()
                    }
                }
                )
            }
            forEachTarget(e, t) {
                e.targetIds.length > 0 ? e.targetIds.forEach(t) : this.Be.forEach( (e, n) => {
                    this.ze(n) && t(n)
                }
                )
            }
            He(e) {
                let t = e.targetId
                  , n = e.me.count
                  , r = this.Je(t);
                if (r) {
                    let i = r.target;
                    if (t2(i)) {
                        if (0 === n) {
                            let e = new W(i.path);
                            this.Ue(t, e, tA.newNoDocument(e, K.min()))
                        } else
                            1 === n || S()
                    } else {
                        let r = this.Ye(t);
                        if (r !== n) {
                            let n = this.Ze(e)
                              , i = n ? this.Xe(n, e, r) : 1;
                            0 !== i && (this.je(t),
                            this.Qe = this.Qe.insert(t, 2 === i ? "TargetPurposeExistenceFilterMismatchBloom" : "TargetPurposeExistenceFilterMismatch")),
                            null == n5 || n5.et(function(e, t, n, r, i) {
                                var s, a, o, l, u, c;
                                let h = {
                                    localCacheCount: e,
                                    existenceFilterCount: t.count,
                                    databaseId: n.database,
                                    projectId: n.projectId
                                }
                                  , d = t.unchangedNames;
                                return d && (h.bloomFilter = {
                                    applied: 0 === i,
                                    hashCount: null !== (s = null == d ? void 0 : d.hashCount) && void 0 !== s ? s : 0,
                                    bitmapLength: null !== (l = null === (o = null === (a = null == d ? void 0 : d.bits) || void 0 === a ? void 0 : a.bitmap) || void 0 === o ? void 0 : o.length) && void 0 !== l ? l : 0,
                                    padding: null !== (c = null === (u = null == d ? void 0 : d.bits) || void 0 === u ? void 0 : u.padding) && void 0 !== c ? c : 0,
                                    mightContain: e => {
                                        var t;
                                        return null !== (t = null == r ? void 0 : r.mightContain(e)) && void 0 !== t && t
                                    }
                                }),
                                h
                            }(r, e.me, this.Le.tt(), n, i))
                        }
                    }
                }
            }
            Ze(e) {
                let t, n;
                let r = e.me.unchangedNames;
                if (!r || !r.bits)
                    return null;
                let {bits: {bitmap: i="", padding: s=0}, hashCount: a=0} = r;
                try {
                    t = tr(i).toUint8Array()
                } catch (e) {
                    if (e instanceof e6)
                        return T("Decoding the base64 bloom filter in existence filter failed (" + e.message + "); ignoring the bloom filter and falling back to full re-query."),
                        null;
                    throw e
                }
                try {
                    n = new n9(t,s,a)
                } catch (e) {
                    return T(e instanceof n7 ? "BloomFilter error: " : "Applying bloom filter failed: ", e),
                    null
                }
                return 0 === n.Ie ? null : n
            }
            Xe(e, t, n) {
                return t.me.count === n - this.nt(e, t.targetId) ? 0 : 2
            }
            nt(e, t) {
                let n = this.Le.getRemoteKeysForTarget(t)
                  , r = 0;
                return n.forEach(n => {
                    let i = this.Le.tt()
                      , s = `projects/${i.projectId}/databases/${i.database}/documents/${n.path.canonicalString()}`;
                    e.mightContain(s) || (this.Ue(t, n, null),
                    r++)
                }
                ),
                r
            }
            rt(e) {
                let t = new Map;
                this.Be.forEach( (n, r) => {
                    let i = this.Je(r);
                    if (i) {
                        if (n.current && t2(i.target)) {
                            let t = new W(i.target.path);
                            null !== this.ke.get(t) || this.it(r, t) || this.Ue(r, t, tA.newNoDocument(t, e))
                        }
                        n.be && (t.set(r, n.ve()),
                        n.Ce())
                    }
                }
                );
                let n = n_();
                this.qe.forEach( (e, t) => {
                    let r = !0;
                    t.forEachWhile(e => {
                        let t = this.Je(e);
                        return !t || "TargetPurposeLimboResolution" === t.purpose || (r = !1,
                        !1)
                    }
                    ),
                    r && (n = n.add(e))
                }
                ),
                this.ke.forEach( (t, n) => n.setReadTime(e));
                let r = new re(e,t,this.Qe,this.ke,n);
                return this.ke = nf,
                this.qe = ro(),
                this.Qe = new e0(U),
                r
            }
            $e(e, t) {
                if (!this.ze(e))
                    return;
                let n = this.it(e, t.key) ? 2 : 0;
                this.Ge(e).Fe(t.key, n),
                this.ke = this.ke.insert(t.key, t),
                this.qe = this.qe.insert(t.key, this.st(t.key).add(e))
            }
            Ue(e, t, n) {
                if (!this.ze(e))
                    return;
                let r = this.Ge(e);
                this.it(e, t) ? r.Fe(t, 1) : r.Me(t),
                this.qe = this.qe.insert(t, this.st(t).delete(e)),
                n && (this.ke = this.ke.insert(t, n))
            }
            removeTarget(e) {
                this.Be.delete(e)
            }
            Ye(e) {
                let t = this.Ge(e).ve();
                return this.Le.getRemoteKeysForTarget(e).size + t.addedDocuments.size - t.removedDocuments.size
            }
            xe(e) {
                this.Ge(e).xe()
            }
            Ge(e) {
                let t = this.Be.get(e);
                return t || (t = new rs,
                this.Be.set(e, t)),
                t
            }
            st(e) {
                let t = this.qe.get(e);
                return t || (t = new e5(U),
                this.qe = this.qe.insert(e, t)),
                t
            }
            ze(e) {
                let t = null !== this.Je(e);
                return t || I("WatchChangeAggregator", "Detected inactive target", e),
                t
            }
            Je(e) {
                let t = this.Be.get(e);
                return t && t.Se ? null : this.Le.ot(e)
            }
            je(e) {
                this.Be.set(e, new rs),
                this.Le.getRemoteKeysForTarget(e).forEach(t => {
                    this.Ue(e, t, null)
                }
                )
            }
            it(e, t) {
                return this.Le.getRemoteKeysForTarget(e).has(t)
            }
        }
        function ro() {
            return new e0(W.comparator)
        }
        function rl() {
            return new e0(W.comparator)
        }
        let ru = {
            asc: "ASCENDING",
            desc: "DESCENDING"
        }
          , rc = {
            "<": "LESS_THAN",
            "<=": "LESS_THAN_OR_EQUAL",
            ">": "GREATER_THAN",
            ">=": "GREATER_THAN_OR_EQUAL",
            "==": "EQUAL",
            "!=": "NOT_EQUAL",
            "array-contains": "ARRAY_CONTAINS",
            in: "IN",
            "not-in": "NOT_IN",
            "array-contains-any": "ARRAY_CONTAINS_ANY"
        }
          , rh = {
            and: "AND",
            or: "OR"
        };
        class rd {
            constructor(e, t) {
                this.databaseId = e,
                this.useProto3Json = t
            }
        }
        function rf(e, t) {
            return e.useProto3Json || eb(t) ? t : {
                value: t
            }
        }
        function rm(e, t) {
            return e.useProto3Json ? `${new Date(1e3 * t.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + t.nanoseconds).slice(-9)}Z` : {
                seconds: "" + t.seconds,
                nanos: t.nanoseconds
            }
        }
        function rg(e, t) {
            return e.useProto3Json ? t.toBase64() : t.toUint8Array()
        }
        function rp(e) {
            return e || S(),
            K.fromTimestamp(function(e) {
                let t = tt(e);
                return new z(t.seconds,t.nanos)
            }(e))
        }
        function ry(e, t) {
            return rw(e, t).canonicalString()
        }
        function rw(e, t) {
            let n = new $(["projects", e.projectId, "databases", e.database]).child("documents");
            return void 0 === t ? n : n.child(t)
        }
        function rv(e) {
            let t = $.fromString(e);
            return rO(t) || S(),
            t
        }
        function r_(e, t) {
            return ry(e.databaseId, t.path)
        }
        function rI(e, t) {
            let n = rv(t);
            if (n.get(1) !== e.databaseId.projectId)
                throw new C(D.INVALID_ARGUMENT,"Tried to deserialize key from different project: " + n.get(1) + " vs " + e.databaseId.projectId);
            if (n.get(3) !== e.databaseId.database)
                throw new C(D.INVALID_ARGUMENT,"Tried to deserialize key from different database: " + n.get(3) + " vs " + e.databaseId.database);
            return new W(rS(n))
        }
        function rb(e, t) {
            return ry(e.databaseId, t)
        }
        function rT(e) {
            let t = rv(e);
            return 4 === t.length ? $.emptyPath() : rS(t)
        }
        function rE(e) {
            return new $(["projects", e.databaseId.projectId, "databases", e.databaseId.database]).canonicalString()
        }
        function rS(e) {
            return e.length > 4 && "documents" === e.get(4) || S(),
            e.popFirst(5)
        }
        function rx(e, t, n) {
            return {
                name: r_(e, t),
                fields: n.value.mapValue.fields
            }
        }
        function rD(e, t, n) {
            let r = rI(e, t.name)
              , i = rp(t.updateTime)
              , s = t.createTime ? rp(t.createTime) : K.min()
              , a = new tk({
                mapValue: {
                    fields: t.fields
                }
            })
              , o = tA.newFoundDocument(r, i, s, a);
            return n && o.setHasCommittedMutations(),
            n ? o.setHasCommittedMutations() : o
        }
        function rC(e, t) {
            var n;
            let r;
            if (t instanceof nK)
                r = {
                    update: rx(e, t.key, t.value)
                };
            else if (t instanceof nW)
                r = {
                    delete: r_(e, t.key)
                };
            else if (t instanceof nG)
                r = {
                    update: rx(e, t.key, t.data),
                    updateMask: function(e) {
                        let t = [];
                        return e.fields.forEach(e => t.push(e.canonicalString())),
                        {
                            fieldPaths: t
                        }
                    }(t.fieldMask)
                };
            else {
                if (!(t instanceof nJ))
                    return S();
                r = {
                    verify: r_(e, t.key)
                }
            }
            return t.fieldTransforms.length > 0 && (r.updateTransforms = t.fieldTransforms.map(e => (function(e, t) {
                let n = t.transform;
                if (n instanceof nD)
                    return {
                        fieldPath: t.field.canonicalString(),
                        setToServerValue: "REQUEST_TIME"
                    };
                if (n instanceof nC)
                    return {
                        fieldPath: t.field.canonicalString(),
                        appendMissingElements: {
                            values: n.elements
                        }
                    };
                if (n instanceof nk)
                    return {
                        fieldPath: t.field.canonicalString(),
                        removeAllFromArray: {
                            values: n.elements
                        }
                    };
                if (n instanceof nR)
                    return {
                        fieldPath: t.field.canonicalString(),
                        increment: n.Pe
                    };
                throw S()
            }
            )(0, e))),
            t.precondition.isNone || (r.currentDocument = void 0 !== (n = t.precondition).updateTime ? {
                updateTime: rm(e, n.updateTime.toTimestamp())
            } : void 0 !== n.exists ? {
                exists: n.exists
            } : S()),
            r
        }
        function rN(e, t) {
            var n;
            let r = t.currentDocument ? void 0 !== (n = t.currentDocument).updateTime ? nL.updateTime(rp(n.updateTime)) : void 0 !== n.exists ? nL.exists(n.exists) : nL.none() : nL.none()
              , i = t.updateTransforms ? t.updateTransforms.map(t => {
                let n;
                return n = null,
                "setToServerValue"in t ? ("REQUEST_TIME" === t.setToServerValue || S(),
                n = new nD) : "appendMissingElements"in t ? n = new nC(t.appendMissingElements.values || []) : "removeAllFromArray"in t ? n = new nk(t.removeAllFromArray.values || []) : "increment"in t ? n = new nR(e,t.increment) : S(),
                new nM(j.fromServerFormat(t.fieldPath),n)
            }
            ) : [];
            if (t.update) {
                t.update.name;
                let n = rI(e, t.update.name)
                  , s = new tk({
                    mapValue: {
                        fields: t.update.fields
                    }
                });
                return t.updateMask ? new nG(n,s,new e3((t.updateMask.fieldPaths || []).map(e => j.fromServerFormat(e))),r,i) : new nK(n,s,r,i)
            }
            return t.delete ? new nW(rI(e, t.delete),r) : t.verify ? new nJ(rI(e, t.verify),r) : S()
        }
        function rk(e, t) {
            return {
                documents: [rb(e, t.path)]
            }
        }
        function rA(e, t) {
            var n, r;
            let i;
            let s = {
                structuredQuery: {}
            }
              , a = t.path;
            null !== t.collectionGroup ? (i = a,
            s.structuredQuery.from = [{
                collectionId: t.collectionGroup,
                allDescendants: !0
            }]) : (i = a.popLast(),
            s.structuredQuery.from = [{
                collectionId: a.lastSegment()
            }]),
            s.parent = rb(e, i);
            let o = function(e) {
                if (0 !== e.length)
                    return function e(t) {
                        return t instanceof tL ? function(e) {
                            if ("==" === e.op) {
                                if (tb(e.value))
                                    return {
                                        unaryFilter: {
                                            field: rV(e.field),
                                            op: "IS_NAN"
                                        }
                                    };
                                if (tI(e.value))
                                    return {
                                        unaryFilter: {
                                            field: rV(e.field),
                                            op: "IS_NULL"
                                        }
                                    }
                            } else if ("!=" === e.op) {
                                if (tb(e.value))
                                    return {
                                        unaryFilter: {
                                            field: rV(e.field),
                                            op: "IS_NOT_NAN"
                                        }
                                    };
                                if (tI(e.value))
                                    return {
                                        unaryFilter: {
                                            field: rV(e.field),
                                            op: "IS_NOT_NULL"
                                        }
                                    }
                            }
                            return {
                                fieldFilter: {
                                    field: rV(e.field),
                                    op: rc[e.op],
                                    value: e.value
                                }
                            }
                        }(t) : t instanceof tP ? function(t) {
                            let n = t.getFilters().map(t => e(t));
                            return 1 === n.length ? n[0] : {
                                compositeFilter: {
                                    op: rh[t.op],
                                    filters: n
                                }
                            }
                        }(t) : S()
                    }(tP.create(e, "and"))
            }(t.filters);
            o && (s.structuredQuery.where = o);
            let l = function(e) {
                if (0 !== e.length)
                    return e.map(e => ({
                        field: rV(e.field),
                        direction: ru[e.dir]
                    }))
            }(t.orderBy);
            l && (s.structuredQuery.orderBy = l);
            let u = rf(e, t.limit);
            return null !== u && (s.structuredQuery.limit = u),
            t.startAt && (s.structuredQuery.startAt = {
                before: (n = t.startAt).inclusive,
                values: n.position
            }),
            t.endAt && (s.structuredQuery.endAt = {
                before: !(r = t.endAt).inclusive,
                values: r.position
            }),
            {
                _t: s,
                parent: i
            }
        }
        function rR(e, t, n, r) {
            let {_t: i, parent: s} = rA(e, t)
              , a = {}
              , o = []
              , l = 0;
            return n.forEach(e => {
                let t = r ? e.alias : "aggregate_" + l++;
                a[t] = e.alias,
                "count" === e.aggregateType ? o.push({
                    alias: t,
                    count: {}
                }) : "avg" === e.aggregateType ? o.push({
                    alias: t,
                    avg: {
                        field: rV(e.fieldPath)
                    }
                }) : "sum" === e.aggregateType && o.push({
                    alias: t,
                    sum: {
                        field: rV(e.fieldPath)
                    }
                })
            }
            ),
            {
                request: {
                    structuredAggregationQuery: {
                        aggregations: o,
                        structuredQuery: i.structuredQuery
                    },
                    parent: i.parent
                },
                ut: a,
                parent: s
            }
        }
        function rF(e) {
            var t;
            let n, r = rT(e.parent), i = e.structuredQuery, s = i.from ? i.from.length : 0, a = null;
            if (s > 0) {
                1 === s || S();
                let e = i.from[0];
                e.allDescendants ? a = e.collectionId : r = r.child(e.collectionId)
            }
            let o = [];
            i.where && (o = function(e) {
                let t = function e(t) {
                    return void 0 !== t.unaryFilter ? function(e) {
                        switch (e.unaryFilter.op) {
                        case "IS_NAN":
                            let t = rM(e.unaryFilter.field);
                            return tL.create(t, "==", {
                                doubleValue: NaN
                            });
                        case "IS_NULL":
                            let n = rM(e.unaryFilter.field);
                            return tL.create(n, "==", {
                                nullValue: "NULL_VALUE"
                            });
                        case "IS_NOT_NAN":
                            let r = rM(e.unaryFilter.field);
                            return tL.create(r, "!=", {
                                doubleValue: NaN
                            });
                        case "IS_NOT_NULL":
                            let i = rM(e.unaryFilter.field);
                            return tL.create(i, "!=", {
                                nullValue: "NULL_VALUE"
                            });
                        default:
                            return S()
                        }
                    }(t) : void 0 !== t.fieldFilter ? tL.create(rM(t.fieldFilter.field), function(e) {
                        switch (e) {
                        case "EQUAL":
                            return "==";
                        case "NOT_EQUAL":
                            return "!=";
                        case "GREATER_THAN":
                            return ">";
                        case "GREATER_THAN_OR_EQUAL":
                            return ">=";
                        case "LESS_THAN":
                            return "<";
                        case "LESS_THAN_OR_EQUAL":
                            return "<=";
                        case "ARRAY_CONTAINS":
                            return "array-contains";
                        case "IN":
                            return "in";
                        case "NOT_IN":
                            return "not-in";
                        case "ARRAY_CONTAINS_ANY":
                            return "array-contains-any";
                        default:
                            return S()
                        }
                    }(t.fieldFilter.op), t.fieldFilter.value) : void 0 !== t.compositeFilter ? tP.create(t.compositeFilter.filters.map(t => e(t)), function(e) {
                        switch (e) {
                        case "AND":
                            return "and";
                        case "OR":
                            return "or";
                        default:
                            return S()
                        }
                    }(t.compositeFilter.op)) : S()
                }(e);
                return t instanceof tP && tB(t) ? t.getFilters() : [t]
            }(i.where));
            let l = [];
            i.orderBy && (l = i.orderBy.map(e => new tM(rM(e.field),function(e) {
                switch (e) {
                case "ASCENDING":
                    return "asc";
                case "DESCENDING":
                    return "desc";
                default:
                    return
                }
            }(e.direction))));
            let u = null;
            i.limit && (u = eb(n = "object" == typeof (t = i.limit) ? t.value : t) ? null : n);
            let c = null;
            i.startAt && (c = function(e) {
                let t = !!e.before;
                return new tR(e.values || [],t)
            }(i.startAt));
            let h = null;
            return i.endAt && (h = function(e) {
                let t = !e.before;
                return new tR(e.values || [],t)
            }(i.endAt)),
            new t3(r,a,l,o,u,"F",c,h)
        }
        function rV(e) {
            return {
                fieldPath: e.canonicalString()
            }
        }
        function rM(e) {
            return j.fromServerFormat(e.fieldPath)
        }
        function rO(e) {
            return e.length >= 4 && "projects" === e.get(0) && "databases" === e.get(2)
        }
        class rL {
            constructor(e, t, n, r, i=K.min(), s=K.min(), a=e7.EMPTY_BYTE_STRING, o=null) {
                this.target = e,
                this.targetId = t,
                this.purpose = n,
                this.sequenceNumber = r,
                this.snapshotVersion = i,
                this.lastLimboFreeSnapshotVersion = s,
                this.resumeToken = a,
                this.expectedCount = o
            }
            withSequenceNumber(e) {
                return new rL(this.target,this.targetId,this.purpose,e,this.snapshotVersion,this.lastLimboFreeSnapshotVersion,this.resumeToken,this.expectedCount)
            }
            withResumeToken(e, t) {
                return new rL(this.target,this.targetId,this.purpose,this.sequenceNumber,t,this.lastLimboFreeSnapshotVersion,e,null)
            }
            withExpectedCount(e) {
                return new rL(this.target,this.targetId,this.purpose,this.sequenceNumber,this.snapshotVersion,this.lastLimboFreeSnapshotVersion,this.resumeToken,e)
            }
            withLastLimboFreeSnapshotVersion(e) {
                return new rL(this.target,this.targetId,this.purpose,this.sequenceNumber,this.snapshotVersion,e,this.resumeToken,this.expectedCount)
            }
        }
        class rP {
            constructor(e) {
                this.ct = e
            }
        }
        function rq(e, t) {
            let n = t.key
              , r = {
                prefixPath: n.getCollectionPath().popLast().toArray(),
                collectionGroup: n.collectionGroup,
                documentId: n.path.lastSegment(),
                readTime: rU(t.readTime),
                hasCommittedMutations: t.hasCommittedMutations
            };
            if (t.isFoundDocument()) {
                var i;
                r.document = {
                    name: r_(i = e.ct, t.key),
                    fields: t.data.value.mapValue.fields,
                    updateTime: rm(i, t.version.toTimestamp()),
                    createTime: rm(i, t.createTime.toTimestamp())
                }
            } else if (t.isNoDocument())
                r.noDocument = {
                    path: n.path.toArray(),
                    readTime: rB(t.version)
                };
            else {
                if (!t.isUnknownDocument())
                    return S();
                r.unknownDocument = {
                    path: n.path.toArray(),
                    version: rB(t.version)
                }
            }
            return r
        }
        function rU(e) {
            let t = e.toTimestamp();
            return [t.seconds, t.nanoseconds]
        }
        function rB(e) {
            let t = e.toTimestamp();
            return {
                seconds: t.seconds,
                nanoseconds: t.nanoseconds
            }
        }
        function rz(e) {
            let t = new z(e.seconds,e.nanoseconds);
            return K.fromTimestamp(t)
        }
        function rK(e, t) {
            let n = (t.baseMutations || []).map(t => rN(e.ct, t));
            for (let e = 0; e < t.mutations.length - 1; ++e) {
                let n = t.mutations[e];
                if (e + 1 < t.mutations.length && void 0 !== t.mutations[e + 1].transform) {
                    let r = t.mutations[e + 1];
                    n.updateTransforms = r.transform.fieldTransforms,
                    t.mutations.splice(e + 1, 1),
                    ++e
                }
            }
            let r = t.mutations.map(t => rN(e.ct, t))
              , i = z.fromMillis(t.localWriteTimeMs);
            return new nH(t.batchId,i,n,r)
        }
        function rG(e) {
            var t;
            let n = rz(e.readTime)
              , r = void 0 !== e.lastLimboFreeSnapshotVersion ? rz(e.lastLimboFreeSnapshotVersion) : K.min();
            return new rL(void 0 !== e.query.documents ? (1 === (t = e.query).documents.length || S(),
            nt(t6(rT(t.documents[0])))) : nt(rF(e.query)),e.targetId,"TargetPurposeListen",e.lastListenSequenceNumber,n,r,e7.fromBase64String(e.resumeToken))
        }
        function r$(e, t) {
            let n;
            let r = rB(t.snapshotVersion)
              , i = rB(t.lastLimboFreeSnapshotVersion);
            n = t2(t.target) ? rk(e.ct, t.target) : rA(e.ct, t.target)._t;
            let s = t.resumeToken.toBase64();
            return {
                targetId: t.targetId,
                canonicalId: t0(t.target),
                readTime: r,
                resumeToken: s,
                lastListenSequenceNumber: t.sequenceNumber,
                lastLimboFreeSnapshotVersion: i,
                query: n
            }
        }
        function rQ(e) {
            let t = rF({
                parent: e.parent,
                structuredQuery: e.structuredQuery
            });
            return "LAST" === e.limitType ? ns(t, t.limit, "L") : t
        }
        function rj(e, t) {
            return new nX(t.largestBatchId,rN(e.ct, t.overlayMutation))
        }
        function rW(e, t) {
            let n = t.path.lastSegment();
            return [e, eS(t.path.popLast()), n]
        }
        function rJ(e, t, n, r) {
            return {
                indexId: e,
                uid: t,
                sequenceNumber: n,
                readTime: rB(r.readTime),
                documentKey: eS(r.documentKey.path),
                largestBatchId: r.largestBatchId
            }
        }
        class rH {
            getBundleMetadata(e, t) {
                return rY(e).get(t).next(e => {
                    if (e)
                        return {
                            id: e.bundleId,
                            createTime: rz(e.createTime),
                            version: e.version
                        }
                }
                )
            }
            saveBundleMetadata(e, t) {
                return rY(e).put({
                    bundleId: t.id,
                    createTime: rB(rp(t.createTime)),
                    version: t.version
                })
            }
            getNamedQuery(e, t) {
                return rX(e).get(t).next(e => {
                    if (e)
                        return {
                            name: e.name,
                            query: rQ(e.bundledQuery),
                            readTime: rz(e.readTime)
                        }
                }
                )
            }
            saveNamedQuery(e, t) {
                return rX(e).put({
                    name: t.name,
                    readTime: rB(rp(t.readTime)),
                    bundledQuery: t.bundledQuery
                })
            }
        }
        function rY(e) {
            return eJ(e, "bundles")
        }
        function rX(e) {
            return eJ(e, "namedQueries")
        }
        class rZ {
            constructor(e, t) {
                this.serializer = e,
                this.userId = t
            }
            static lt(e, t) {
                return new rZ(e,t.uid || "")
            }
            getOverlay(e, t) {
                return r0(e).get(rW(this.userId, t)).next(e => e ? rj(this.serializer, e) : null)
            }
            getOverlays(e, t) {
                let n = ny();
                return el.forEach(t, t => this.getOverlay(e, t).next(e => {
                    null !== e && n.set(t, e)
                }
                )).next( () => n)
            }
            saveOverlays(e, t, n) {
                let r = [];
                return n.forEach( (n, i) => {
                    let s = new nX(t,i);
                    r.push(this.ht(e, s))
                }
                ),
                el.waitFor(r)
            }
            removeOverlaysForBatchId(e, t, n) {
                let r = new Set;
                t.forEach(e => r.add(eS(e.getCollectionPath())));
                let i = [];
                return r.forEach(t => {
                    let r = IDBKeyRange.bound([this.userId, t, n], [this.userId, t, n + 1], !1, !0);
                    i.push(r0(e).j("collectionPathOverlayIndex", r))
                }
                ),
                el.waitFor(i)
            }
            getOverlaysForCollection(e, t, n) {
                let r = ny()
                  , i = eS(t)
                  , s = IDBKeyRange.bound([this.userId, i, n], [this.userId, i, Number.POSITIVE_INFINITY], !0);
                return r0(e).U("collectionPathOverlayIndex", s).next(e => {
                    for (let t of e) {
                        let e = rj(this.serializer, t);
                        r.set(e.getKey(), e)
                    }
                    return r
                }
                )
            }
            getOverlaysForCollectionGroup(e, t, n, r) {
                let i;
                let s = ny()
                  , a = IDBKeyRange.bound([this.userId, t, n], [this.userId, t, Number.POSITIVE_INFINITY], !0);
                return r0(e).J({
                    index: "collectionGroupOverlayIndex",
                    range: a
                }, (e, t, n) => {
                    let a = rj(this.serializer, t);
                    s.size() < r || a.largestBatchId === i ? (s.set(a.getKey(), a),
                    i = a.largestBatchId) : n.done()
                }
                ).next( () => s)
            }
            ht(e, t) {
                return r0(e).put(function(e, t, n) {
                    let[r,i,s] = rW(t, n.mutation.key);
                    return {
                        userId: t,
                        collectionPath: i,
                        documentId: s,
                        collectionGroup: n.mutation.key.getCollectionGroup(),
                        largestBatchId: n.largestBatchId,
                        overlayMutation: rC(e.ct, n.mutation)
                    }
                }(this.serializer, this.userId, t))
            }
        }
        function r0(e) {
            return eJ(e, "documentOverlays")
        }
        class r1 {
            Pt(e) {
                return eJ(e, "globals")
            }
            getSessionToken(e) {
                return this.Pt(e).get("sessionToken").next(e => {
                    let t = null == e ? void 0 : e.value;
                    return t ? e7.fromUint8Array(t) : e7.EMPTY_BYTE_STRING
                }
                )
            }
            setSessionToken(e, t) {
                return this.Pt(e).put({
                    name: "sessionToken",
                    value: t.toUint8Array()
                })
            }
        }
        class r2 {
            constructor() {}
            It(e, t) {
                this.Tt(e, t),
                t.Et()
            }
            Tt(e, t) {
                if ("nullValue"in e)
                    this.dt(t, 5);
                else if ("booleanValue"in e)
                    this.dt(t, 10),
                    t.At(e.booleanValue ? 1 : 0);
                else if ("integerValue"in e)
                    this.dt(t, 15),
                    t.At(tn(e.integerValue));
                else if ("doubleValue"in e) {
                    let n = tn(e.doubleValue);
                    isNaN(n) ? this.dt(t, 13) : (this.dt(t, 15),
                    eT(n) ? t.At(0) : t.At(n))
                } else if ("timestampValue"in e) {
                    let n = e.timestampValue;
                    this.dt(t, 20),
                    "string" == typeof n && (n = tt(n)),
                    t.Rt(`${n.seconds || ""}`),
                    t.At(n.nanos || 0)
                } else if ("stringValue"in e)
                    this.Vt(e.stringValue, t),
                    this.ft(t);
                else if ("bytesValue"in e)
                    this.dt(t, 30),
                    t.gt(tr(e.bytesValue)),
                    this.ft(t);
                else if ("referenceValue"in e)
                    this.yt(e.referenceValue, t);
                else if ("geoPointValue"in e) {
                    let n = e.geoPointValue;
                    this.dt(t, 45),
                    t.At(n.latitude || 0),
                    t.At(n.longitude || 0)
                } else
                    "mapValue"in e ? tx(e) ? this.dt(t, Number.MAX_SAFE_INTEGER) : tE(e) ? this.wt(e.mapValue, t) : (this.St(e.mapValue, t),
                    this.ft(t)) : "arrayValue"in e ? (this.bt(e.arrayValue, t),
                    this.ft(t)) : S()
            }
            Vt(e, t) {
                this.dt(t, 25),
                this.Dt(e, t)
            }
            Dt(e, t) {
                t.Rt(e)
            }
            St(e, t) {
                let n = e.fields || {};
                for (let e of (this.dt(t, 55),
                Object.keys(n)))
                    this.Vt(e, t),
                    this.Tt(n[e], t)
            }
            wt(e, t) {
                var n, r;
                let i = e.fields || {};
                this.dt(t, 53);
                let s = "value"
                  , a = (null === (r = null === (n = i[s].arrayValue) || void 0 === n ? void 0 : n.values) || void 0 === r ? void 0 : r.length) || 0;
                this.dt(t, 15),
                t.At(tn(a)),
                this.Vt(s, t),
                this.Tt(i[s], t)
            }
            bt(e, t) {
                let n = e.values || [];
                for (let e of (this.dt(t, 50),
                n))
                    this.Tt(e, t)
            }
            yt(e, t) {
                this.dt(t, 37),
                W.fromName(e).path.forEach(e => {
                    this.dt(t, 60),
                    this.Dt(e, t)
                }
                )
            }
            dt(e, t) {
                e.At(t)
            }
            ft(e) {
                e.At(2)
            }
        }
        function r5(e) {
            return Math.ceil((64 - function(e) {
                let t = 0;
                for (let n = 0; n < 8; ++n) {
                    let r = function(e) {
                        if (0 === e)
                            return 8;
                        let t = 0;
                        return e >> 4 == 0 && (t += 4,
                        e <<= 4),
                        e >> 6 == 0 && (t += 2,
                        e <<= 2),
                        e >> 7 == 0 && (t += 1),
                        t
                    }(255 & e[n]);
                    if (t += r,
                    8 !== r)
                        break
                }
                return t
            }(e)) / 8)
        }
        r2.vt = new r2;
        class r4 {
            constructor() {
                this.buffer = new Uint8Array(1024),
                this.position = 0
            }
            Ct(e) {
                let t = e[Symbol.iterator]()
                  , n = t.next();
                for (; !n.done; )
                    this.Ft(n.value),
                    n = t.next();
                this.Mt()
            }
            xt(e) {
                let t = e[Symbol.iterator]()
                  , n = t.next();
                for (; !n.done; )
                    this.Ot(n.value),
                    n = t.next();
                this.Nt()
            }
            Lt(e) {
                for (let t of e) {
                    let e = t.charCodeAt(0);
                    if (e < 128)
                        this.Ft(e);
                    else if (e < 2048)
                        this.Ft(960 | e >>> 6),
                        this.Ft(128 | 63 & e);
                    else if (t < "\ud800" || "\udbff" < t)
                        this.Ft(480 | e >>> 12),
                        this.Ft(128 | 63 & e >>> 6),
                        this.Ft(128 | 63 & e);
                    else {
                        let e = t.codePointAt(0);
                        this.Ft(240 | e >>> 18),
                        this.Ft(128 | 63 & e >>> 12),
                        this.Ft(128 | 63 & e >>> 6),
                        this.Ft(128 | 63 & e)
                    }
                }
                this.Mt()
            }
            Bt(e) {
                for (let t of e) {
                    let e = t.charCodeAt(0);
                    if (e < 128)
                        this.Ot(e);
                    else if (e < 2048)
                        this.Ot(960 | e >>> 6),
                        this.Ot(128 | 63 & e);
                    else if (t < "\ud800" || "\udbff" < t)
                        this.Ot(480 | e >>> 12),
                        this.Ot(128 | 63 & e >>> 6),
                        this.Ot(128 | 63 & e);
                    else {
                        let e = t.codePointAt(0);
                        this.Ot(240 | e >>> 18),
                        this.Ot(128 | 63 & e >>> 12),
                        this.Ot(128 | 63 & e >>> 6),
                        this.Ot(128 | 63 & e)
                    }
                }
                this.Nt()
            }
            kt(e) {
                let t = this.qt(e)
                  , n = r5(t);
                this.Qt(1 + n),
                this.buffer[this.position++] = 255 & n;
                for (let e = t.length - n; e < t.length; ++e)
                    this.buffer[this.position++] = 255 & t[e]
            }
            Kt(e) {
                let t = this.qt(e)
                  , n = r5(t);
                this.Qt(1 + n),
                this.buffer[this.position++] = ~(255 & n);
                for (let e = t.length - n; e < t.length; ++e)
                    this.buffer[this.position++] = ~(255 & t[e])
            }
            $t() {
                this.Ut(255),
                this.Ut(255)
            }
            Wt() {
                this.Gt(255),
                this.Gt(255)
            }
            reset() {
                this.position = 0
            }
            seed(e) {
                this.Qt(e.length),
                this.buffer.set(e, this.position),
                this.position += e.length
            }
            zt() {
                return this.buffer.slice(0, this.position)
            }
            qt(e) {
                let t = function(e) {
                    let t = new DataView(new ArrayBuffer(8));
                    return t.setFloat64(0, e, !1),
                    new Uint8Array(t.buffer)
                }(e)
                  , n = 0 != (128 & t[0]);
                t[0] ^= n ? 255 : 128;
                for (let e = 1; e < t.length; ++e)
                    t[e] ^= n ? 255 : 0;
                return t
            }
            Ft(e) {
                let t = 255 & e;
                0 === t ? (this.Ut(0),
                this.Ut(255)) : 255 === t ? (this.Ut(255),
                this.Ut(0)) : this.Ut(t)
            }
            Ot(e) {
                let t = 255 & e;
                0 === t ? (this.Gt(0),
                this.Gt(255)) : 255 === t ? (this.Gt(255),
                this.Gt(0)) : this.Gt(e)
            }
            Mt() {
                this.Ut(0),
                this.Ut(1)
            }
            Nt() {
                this.Gt(0),
                this.Gt(1)
            }
            Ut(e) {
                this.Qt(1),
                this.buffer[this.position++] = e
            }
            Gt(e) {
                this.Qt(1),
                this.buffer[this.position++] = ~e
            }
            Qt(e) {
                let t = e + this.position;
                if (t <= this.buffer.length)
                    return;
                let n = 2 * this.buffer.length;
                n < t && (n = t);
                let r = new Uint8Array(n);
                r.set(this.buffer),
                this.buffer = r
            }
        }
        class r8 {
            constructor(e) {
                this.jt = e
            }
            gt(e) {
                this.jt.Ct(e)
            }
            Rt(e) {
                this.jt.Lt(e)
            }
            At(e) {
                this.jt.kt(e)
            }
            Et() {
                this.jt.$t()
            }
        }
        class r3 {
            constructor(e) {
                this.jt = e
            }
            gt(e) {
                this.jt.xt(e)
            }
            Rt(e) {
                this.jt.Bt(e)
            }
            At(e) {
                this.jt.Kt(e)
            }
            Et() {
                this.jt.Wt()
            }
        }
        class r6 {
            constructor() {
                this.jt = new r4,
                this.Ht = new r8(this.jt),
                this.Jt = new r3(this.jt)
            }
            seed(e) {
                this.jt.seed(e)
            }
            Yt(e) {
                return 0 === e ? this.Ht : this.Jt
            }
            zt() {
                return this.jt.zt()
            }
            reset() {
                this.jt.reset()
            }
        }
        class r9 {
            constructor(e, t, n, r) {
                this.indexId = e,
                this.documentKey = t,
                this.arrayValue = n,
                this.directionalValue = r
            }
            Zt() {
                let e = this.directionalValue.length
                  , t = 0 === e || 255 === this.directionalValue[e - 1] ? e + 1 : e
                  , n = new Uint8Array(t);
                return n.set(this.directionalValue, 0),
                t !== e ? n.set([0], this.directionalValue.length) : ++n[n.length - 1],
                new r9(this.indexId,this.documentKey,this.arrayValue,n)
            }
        }
        function r7(e, t) {
            let n = e.indexId - t.indexId;
            return 0 !== n ? n : 0 !== (n = ie(e.arrayValue, t.arrayValue)) ? n : 0 !== (n = ie(e.directionalValue, t.directionalValue)) ? n : W.comparator(e.documentKey, t.documentKey)
        }
        function ie(e, t) {
            for (let n = 0; n < e.length && n < t.length; ++n) {
                let r = e[n] - t[n];
                if (0 !== r)
                    return r
            }
            return e.length - t.length
        }
        class it {
            constructor(e) {
                for (let t of (this.Xt = new e5( (e, t) => j.comparator(e.field, t.field)),
                this.collectionId = null != e.collectionGroup ? e.collectionGroup : e.path.lastSegment(),
                this.en = e.orderBy,
                this.tn = [],
                e.filters))
                    t.isInequality() ? this.Xt = this.Xt.add(t) : this.tn.push(t)
            }
            get nn() {
                return this.Xt.size > 1
            }
            rn(e) {
                if (e.collectionGroup === this.collectionId || S(),
                this.nn)
                    return !1;
                let t = H(e);
                if (void 0 !== t && !this.sn(t))
                    return !1;
                let n = Y(e)
                  , r = new Set
                  , i = 0
                  , s = 0;
                for (; i < n.length && this.sn(n[i]); ++i)
                    r = r.add(n[i].fieldPath.canonicalString());
                if (i === n.length)
                    return !0;
                if (this.Xt.size > 0) {
                    let e = this.Xt.getIterator().getNext();
                    if (!r.has(e.field.canonicalString())) {
                        let t = n[i];
                        if (!this.on(e, t) || !this._n(this.en[s++], t))
                            return !1
                    }
                    ++i
                }
                for (; i < n.length; ++i) {
                    let e = n[i];
                    if (s >= this.en.length || !this._n(this.en[s++], e))
                        return !1
                }
                return !0
            }
            an() {
                if (this.nn)
                    return null;
                let e = new e5(j.comparator)
                  , t = [];
                for (let n of this.tn)
                    if (!n.field.isKeyField()) {
                        if ("array-contains" === n.op || "array-contains-any" === n.op)
                            t.push(new Z(n.field,2));
                        else {
                            if (e.has(n.field))
                                continue;
                            e = e.add(n.field),
                            t.push(new Z(n.field,0))
                        }
                    }
                for (let n of this.en)
                    n.field.isKeyField() || e.has(n.field) || (e = e.add(n.field),
                    t.push(new Z(n.field,"asc" === n.dir ? 0 : 1)));
                return new J(J.UNKNOWN_ID,this.collectionId,t,ee.empty())
            }
            sn(e) {
                for (let t of this.tn)
                    if (this.on(t, e))
                        return !0;
                return !1
            }
            on(e, t) {
                if (void 0 === e || !e.field.isEqual(t.fieldPath))
                    return !1;
                let n = "array-contains" === e.op || "array-contains-any" === e.op;
                return 2 === t.kind === n
            }
            _n(e, t) {
                return !!e.field.isEqual(t.fieldPath) && (0 === t.kind && "asc" === e.dir || 1 === t.kind && "desc" === e.dir)
            }
        }
        function ir(e) {
            return e instanceof tL
        }
        function ii(e) {
            return e instanceof tP && tB(e)
        }
        function is(e) {
            return ir(e) || ii(e) || function(e) {
                if (e instanceof tP && tU(e)) {
                    for (let t of e.getFilters())
                        if (!ir(t) && !ii(t))
                            return !1;
                    return !0
                }
                return !1
            }(e)
        }
        function ia(e, t) {
            return e instanceof tL || e instanceof tP || S(),
            t instanceof tL || t instanceof tP || S(),
            il(e instanceof tL ? t instanceof tL ? tP.create([e, t], "and") : io(e, t) : t instanceof tL ? io(t, e) : function(e, t) {
                if (e.filters.length > 0 && t.filters.length > 0 || S(),
                tq(e) && tq(t))
                    return tK(e, t.getFilters());
                let n = tU(e) ? e : t
                  , r = tU(e) ? t : e
                  , i = n.filters.map(e => ia(e, r));
                return tP.create(i, "or")
            }(e, t))
        }
        function io(e, t) {
            if (tq(t))
                return tK(t, e.getFilters());
            {
                let n = t.filters.map(t => ia(e, t));
                return tP.create(n, "or")
            }
        }
        function il(e) {
            if (e instanceof tL || e instanceof tP || S(),
            e instanceof tL)
                return e;
            let t = e.getFilters();
            if (1 === t.length)
                return il(t[0]);
            if (tz(e))
                return e;
            let n = t.map(e => il(e))
              , r = [];
            return n.forEach(t => {
                t instanceof tL ? r.push(t) : t instanceof tP && (t.op === e.op ? r.push(...t.filters) : r.push(t))
            }
            ),
            1 === r.length ? r[0] : tP.create(r, e.op)
        }
        class iu {
            constructor() {
                this.un = new ic
            }
            addToCollectionParentIndex(e, t) {
                return this.un.add(t),
                el.resolve()
            }
            getCollectionParents(e, t) {
                return el.resolve(this.un.getEntries(t))
            }
            addFieldIndex(e, t) {
                return el.resolve()
            }
            deleteFieldIndex(e, t) {
                return el.resolve()
            }
            deleteAllFieldIndexes(e) {
                return el.resolve()
            }
            createTargetIndexes(e, t) {
                return el.resolve()
            }
            getDocumentsMatchingTarget(e, t) {
                return el.resolve(null)
            }
            getIndexType(e, t) {
                return el.resolve(0)
            }
            getFieldIndexes(e, t) {
                return el.resolve([])
            }
            getNextCollectionGroupToUpdate(e) {
                return el.resolve(null)
            }
            getMinOffset(e, t) {
                return el.resolve(er.min())
            }
            getMinOffsetFromCollectionGroup(e, t) {
                return el.resolve(er.min())
            }
            updateCollectionGroup(e, t, n) {
                return el.resolve()
            }
            updateIndexEntries(e, t) {
                return el.resolve()
            }
        }
        class ic {
            constructor() {
                this.index = {}
            }
            add(e) {
                let t = e.lastSegment()
                  , n = e.popLast()
                  , r = this.index[t] || new e5($.comparator)
                  , i = !r.has(n);
                return this.index[t] = r.add(n),
                i
            }
            has(e) {
                let t = e.lastSegment()
                  , n = e.popLast()
                  , r = this.index[t];
                return r && r.has(n)
            }
            getEntries(e) {
                return (this.index[e] || new e5($.comparator)).toArray()
            }
        }
        let ih = new Uint8Array(0);
        class id {
            constructor(e, t) {
                this.databaseId = t,
                this.cn = new ic,
                this.ln = new nd(e => t0(e), (e, t) => t1(e, t)),
                this.uid = e.uid || ""
            }
            addToCollectionParentIndex(e, t) {
                if (!this.cn.has(t)) {
                    let n = t.lastSegment()
                      , r = t.popLast();
                    e.addOnCommittedListener( () => {
                        this.cn.add(t)
                    }
                    );
                    let i = {
                        collectionId: n,
                        parent: eS(r)
                    };
                    return im(e).put(i)
                }
                return el.resolve()
            }
            getCollectionParents(e, t) {
                let n = []
                  , r = IDBKeyRange.bound([t, ""], [t + "\0", ""], !1, !0);
                return im(e).U(r).next(e => {
                    for (let r of e) {
                        if (r.collectionId !== t)
                            break;
                        n.push(ex(r.parent))
                    }
                    return n
                }
                )
            }
            addFieldIndex(e, t) {
                let n = ip(e)
                  , r = {
                    indexId: t.indexId,
                    collectionGroup: t.collectionGroup,
                    fields: t.fields.map(e => [e.fieldPath.canonicalString(), e.kind])
                };
                delete r.indexId;
                let i = n.add(r);
                if (t.indexState) {
                    let n = iy(e);
                    return i.next(e => {
                        n.put(rJ(e, this.uid, t.indexState.sequenceNumber, t.indexState.offset))
                    }
                    )
                }
                return i.next()
            }
            deleteFieldIndex(e, t) {
                let n = ip(e)
                  , r = iy(e)
                  , i = ig(e);
                return n.delete(t.indexId).next( () => r.delete(IDBKeyRange.bound([t.indexId], [t.indexId + 1], !1, !0))).next( () => i.delete(IDBKeyRange.bound([t.indexId], [t.indexId + 1], !1, !0)))
            }
            deleteAllFieldIndexes(e) {
                let t = ip(e)
                  , n = ig(e)
                  , r = iy(e);
                return t.j().next( () => n.j()).next( () => r.j())
            }
            createTargetIndexes(e, t) {
                return el.forEach(this.hn(t), t => this.getIndexType(e, t).next(n => {
                    if (0 === n || 1 === n) {
                        let n = new it(t).an();
                        if (null != n)
                            return this.addFieldIndex(e, n)
                    }
                }
                ))
            }
            getDocumentsMatchingTarget(e, t) {
                let n = ig(e)
                  , r = !0
                  , i = new Map;
                return el.forEach(this.hn(t), t => this.Pn(e, t).next(e => {
                    r && (r = !!e),
                    i.set(t, e)
                }
                )).next( () => {
                    if (r) {
                        let e = n_()
                          , r = [];
                        return el.forEach(i, (i, s) => {
                            I("IndexedDbIndexManager", `Using index id=${i.indexId}|cg=${i.collectionGroup}|f=${i.fields.map(e => `${e.fieldPath}:${e.kind}`).join(",")} to execute ${t0(t)}`);
                            let a = function(e, t) {
                                let n = H(t);
                                if (void 0 === n)
                                    return null;
                                for (let t of t5(e, n.fieldPath))
                                    switch (t.op) {
                                    case "array-contains-any":
                                        return t.value.arrayValue.values || [];
                                    case "array-contains":
                                        return [t.value]
                                    }
                                return null
                            }(s, i)
                              , o = function(e, t) {
                                let n = new Map;
                                for (let r of Y(t))
                                    for (let t of t5(e, r.fieldPath))
                                        switch (t.op) {
                                        case "==":
                                        case "in":
                                            n.set(r.fieldPath.canonicalString(), t.value);
                                            break;
                                        case "not-in":
                                        case "!=":
                                            return n.set(r.fieldPath.canonicalString(), t.value),
                                            Array.from(n.values())
                                        }
                                return null
                            }(s, i)
                              , l = function(e, t) {
                                let n = []
                                  , r = !0;
                                for (let i of Y(t)) {
                                    let t = 0 === i.kind ? t4(e, i.fieldPath, e.startAt) : t8(e, i.fieldPath, e.startAt);
                                    n.push(t.value),
                                    r && (r = t.inclusive)
                                }
                                return new tR(n,r)
                            }(s, i)
                              , u = function(e, t) {
                                let n = []
                                  , r = !0;
                                for (let i of Y(t)) {
                                    let t = 0 === i.kind ? t8(e, i.fieldPath, e.endAt) : t4(e, i.fieldPath, e.endAt);
                                    n.push(t.value),
                                    r && (r = t.inclusive)
                                }
                                return new tR(n,r)
                            }(s, i)
                              , c = this.In(i, s, l)
                              , h = this.In(i, s, u)
                              , d = this.Tn(i, s, o)
                              , f = this.En(i.indexId, a, c, l.inclusive, h, u.inclusive, d);
                            return el.forEach(f, i => n.G(i, t.limit).next(t => {
                                t.forEach(t => {
                                    let n = W.fromSegments(t.documentKey);
                                    e.has(n) || (e = e.add(n),
                                    r.push(n))
                                }
                                )
                            }
                            ))
                        }
                        ).next( () => r)
                    }
                    return el.resolve(null)
                }
                )
            }
            hn(e) {
                let t = this.ln.get(e);
                return t || (t = 0 === e.filters.length ? [e] : (function(e) {
                    if (0 === e.getFilters().length)
                        return [];
                    let t = function e(t) {
                        if (t instanceof tL || t instanceof tP || S(),
                        t instanceof tL)
                            return t;
                        if (1 === t.filters.length)
                            return e(t.filters[0]);
                        let n = t.filters.map(t => e(t))
                          , r = tP.create(n, t.op);
                        return is(r = il(r)) ? r : (r instanceof tP || S(),
                        tq(r) || S(),
                        r.filters.length > 1 || S(),
                        r.filters.reduce( (e, t) => ia(e, t)))
                    }(function e(t) {
                        var n, r;
                        if (t instanceof tL || t instanceof tP || S(),
                        t instanceof tL) {
                            if (t instanceof tJ) {
                                let e = (null === (r = null === (n = t.value.arrayValue) || void 0 === n ? void 0 : n.values) || void 0 === r ? void 0 : r.map(e => tL.create(t.field, "==", e))) || [];
                                return tP.create(e, "or")
                            }
                            return t
                        }
                        let i = t.filters.map(t => e(t));
                        return tP.create(i, t.op)
                    }(e));
                    return is(t) || S(),
                    ir(t) || ii(t) ? [t] : t.getFilters()
                }
                )(tP.create(e.filters, "and")).map(t => tZ(e.path, e.collectionGroup, e.orderBy, t.getFilters(), e.limit, e.startAt, e.endAt)),
                this.ln.set(e, t)),
                t
            }
            En(e, t, n, r, i, s, a) {
                let o = (null != t ? t.length : 1) * Math.max(n.length, i.length)
                  , l = o / (null != t ? t.length : 1)
                  , u = [];
                for (let c = 0; c < o; ++c) {
                    let o = t ? this.dn(t[c / l]) : ih
                      , h = this.An(e, o, n[c % l], r)
                      , d = this.Rn(e, o, i[c % l], s)
                      , f = a.map(t => this.An(e, o, t, !0));
                    u.push(...this.createRange(h, d, f))
                }
                return u
            }
            An(e, t, n, r) {
                let i = new r9(e,W.empty(),t,n);
                return r ? i : i.Zt()
            }
            Rn(e, t, n, r) {
                let i = new r9(e,W.empty(),t,n);
                return r ? i.Zt() : i
            }
            Pn(e, t) {
                let n = new it(t)
                  , r = null != t.collectionGroup ? t.collectionGroup : t.path.lastSegment();
                return this.getFieldIndexes(e, r).next(e => {
                    let t = null;
                    for (let r of e)
                        n.rn(r) && (!t || r.fields.length > t.fields.length) && (t = r);
                    return t
                }
                )
            }
            getIndexType(e, t) {
                let n = 2
                  , r = this.hn(t);
                return el.forEach(r, t => this.Pn(e, t).next(e => {
                    e ? 0 !== n && e.fields.length < function(e) {
                        let t = new e5(j.comparator)
                          , n = !1;
                        for (let r of e.filters)
                            for (let e of r.getFlattenedFilters())
                                e.field.isKeyField() || ("array-contains" === e.op || "array-contains-any" === e.op ? n = !0 : t = t.add(e.field));
                        for (let n of e.orderBy)
                            n.field.isKeyField() || (t = t.add(n.field));
                        return t.size + (n ? 1 : 0)
                    }(t) && (n = 1) : n = 0
                }
                )).next( () => null !== t.limit && r.length > 1 && 2 === n ? 1 : n)
            }
            Vn(e, t) {
                let n = new r6;
                for (let r of Y(e)) {
                    let e = t.data.field(r.fieldPath);
                    if (null == e)
                        return null;
                    let i = n.Yt(r.kind);
                    r2.vt.It(e, i)
                }
                return n.zt()
            }
            dn(e) {
                let t = new r6;
                return r2.vt.It(e, t.Yt(0)),
                t.zt()
            }
            mn(e, t) {
                let n = new r6;
                return r2.vt.It(tw(this.databaseId, t), n.Yt(function(e) {
                    let t = Y(e);
                    return 0 === t.length ? 0 : t[t.length - 1].kind
                }(e))),
                n.zt()
            }
            Tn(e, t, n) {
                if (null === n)
                    return [];
                let r = [];
                r.push(new r6);
                let i = 0;
                for (let s of Y(e)) {
                    let e = n[i++];
                    for (let n of r)
                        if (this.fn(t, s.fieldPath) && t_(e))
                            r = this.gn(r, s, e);
                        else {
                            let t = n.Yt(s.kind);
                            r2.vt.It(e, t)
                        }
                }
                return this.pn(r)
            }
            In(e, t, n) {
                return this.Tn(e, t, n.position)
            }
            pn(e) {
                let t = [];
                for (let n = 0; n < e.length; ++n)
                    t[n] = e[n].zt();
                return t
            }
            gn(e, t, n) {
                let r = [...e]
                  , i = [];
                for (let e of n.arrayValue.values || [])
                    for (let n of r) {
                        let r = new r6;
                        r.seed(n.zt()),
                        r2.vt.It(e, r.Yt(t.kind)),
                        i.push(r)
                    }
                return i
            }
            fn(e, t) {
                return !!e.filters.find(e => e instanceof tL && e.field.isEqual(t) && ("in" === e.op || "not-in" === e.op))
            }
            getFieldIndexes(e, t) {
                let n = ip(e)
                  , r = iy(e);
                return (t ? n.U("collectionGroupIndex", IDBKeyRange.bound(t, t)) : n.U()).next(e => {
                    let t = [];
                    return el.forEach(e, e => r.get([e.indexId, this.uid]).next(n => {
                        t.push(function(e, t) {
                            let n = t ? new ee(t.sequenceNumber,new er(rz(t.readTime),new W(ex(t.documentKey)),t.largestBatchId)) : ee.empty()
                              , r = e.fields.map( ([e,t]) => new Z(j.fromServerFormat(e),t));
                            return new J(e.indexId,e.collectionGroup,r,n)
                        }(e, n))
                    }
                    )).next( () => t)
                }
                )
            }
            getNextCollectionGroupToUpdate(e) {
                return this.getFieldIndexes(e).next(e => 0 === e.length ? null : (e.sort( (e, t) => {
                    let n = e.indexState.sequenceNumber - t.indexState.sequenceNumber;
                    return 0 !== n ? n : U(e.collectionGroup, t.collectionGroup)
                }
                ),
                e[0].collectionGroup))
            }
            updateCollectionGroup(e, t, n) {
                let r = ip(e)
                  , i = iy(e);
                return this.yn(e).next(e => r.U("collectionGroupIndex", IDBKeyRange.bound(t, t)).next(t => el.forEach(t, t => i.put(rJ(t.indexId, this.uid, e, n)))))
            }
            updateIndexEntries(e, t) {
                let n = new Map;
                return el.forEach(t, (t, r) => {
                    let i = n.get(t.collectionGroup);
                    return (i ? el.resolve(i) : this.getFieldIndexes(e, t.collectionGroup)).next(i => (n.set(t.collectionGroup, i),
                    el.forEach(i, n => this.wn(e, t, n).next(t => {
                        let i = this.Sn(r, n);
                        return t.isEqual(i) ? el.resolve() : this.bn(e, r, n, t, i)
                    }
                    ))))
                }
                )
            }
            Dn(e, t, n, r) {
                return ig(e).put({
                    indexId: r.indexId,
                    uid: this.uid,
                    arrayValue: r.arrayValue,
                    directionalValue: r.directionalValue,
                    orderedDocumentKey: this.mn(n, t.key),
                    documentKey: t.key.path.toArray()
                })
            }
            vn(e, t, n, r) {
                return ig(e).delete([r.indexId, this.uid, r.arrayValue, r.directionalValue, this.mn(n, t.key), t.key.path.toArray()])
            }
            wn(e, t, n) {
                let r = ig(e)
                  , i = new e5(r7);
                return r.J({
                    index: "documentKeyIndex",
                    range: IDBKeyRange.only([n.indexId, this.uid, this.mn(n, t)])
                }, (e, r) => {
                    i = i.add(new r9(n.indexId,t,r.arrayValue,r.directionalValue))
                }
                ).next( () => i)
            }
            Sn(e, t) {
                let n = new e5(r7)
                  , r = this.Vn(t, e);
                if (null == r)
                    return n;
                let i = H(t);
                if (null != i) {
                    let s = e.data.field(i.fieldPath);
                    if (t_(s))
                        for (let i of s.arrayValue.values || [])
                            n = n.add(new r9(t.indexId,e.key,this.dn(i),r))
                } else
                    n = n.add(new r9(t.indexId,e.key,ih,r));
                return n
            }
            bn(e, t, n, r, i) {
                I("IndexedDbIndexManager", "Updating index entries for document '%s'", t.key);
                let s = [];
                return function(e, t, n, r, i) {
                    let s = e.getIterator()
                      , a = t.getIterator()
                      , o = e8(s)
                      , l = e8(a);
                    for (; o || l; ) {
                        let e = !1
                          , t = !1;
                        if (o && l) {
                            let r = n(o, l);
                            r < 0 ? t = !0 : r > 0 && (e = !0)
                        } else
                            null != o ? t = !0 : e = !0;
                        e ? (r(l),
                        l = e8(a)) : t ? (i(o),
                        o = e8(s)) : (o = e8(s),
                        l = e8(a))
                    }
                }(r, i, r7, r => {
                    s.push(this.Dn(e, t, n, r))
                }
                , r => {
                    s.push(this.vn(e, t, n, r))
                }
                ),
                el.waitFor(s)
            }
            yn(e) {
                let t = 1;
                return iy(e).J({
                    index: "sequenceNumberIndex",
                    reverse: !0,
                    range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER])
                }, (e, n, r) => {
                    r.done(),
                    t = n.sequenceNumber + 1
                }
                ).next( () => t)
            }
            createRange(e, t, n) {
                n = n.sort( (e, t) => r7(e, t)).filter( (e, t, n) => !t || 0 !== r7(e, n[t - 1]));
                let r = [];
                for (let i of (r.push(e),
                n)) {
                    let n = r7(i, e)
                      , s = r7(i, t);
                    if (0 === n)
                        r[0] = e.Zt();
                    else if (n > 0 && s < 0)
                        r.push(i),
                        r.push(i.Zt());
                    else if (s > 0)
                        break
                }
                r.push(t);
                let i = [];
                for (let e = 0; e < r.length; e += 2) {
                    if (this.Cn(r[e], r[e + 1]))
                        return [];
                    let t = [r[e].indexId, this.uid, r[e].arrayValue, r[e].directionalValue, ih, []]
                      , n = [r[e + 1].indexId, this.uid, r[e + 1].arrayValue, r[e + 1].directionalValue, ih, []];
                    i.push(IDBKeyRange.bound(t, n))
                }
                return i
            }
            Cn(e, t) {
                return r7(e, t) > 0
            }
            getMinOffsetFromCollectionGroup(e, t) {
                return this.getFieldIndexes(e, t).next(iw)
            }
            getMinOffset(e, t) {
                return el.mapArray(this.hn(t), t => this.Pn(e, t).next(e => e || S())).next(iw)
            }
        }
        function im(e) {
            return eJ(e, "collectionParents")
        }
        function ig(e) {
            return eJ(e, "indexEntries")
        }
        function ip(e) {
            return eJ(e, "indexConfiguration")
        }
        function iy(e) {
            return eJ(e, "indexState")
        }
        function iw(e) {
            0 !== e.length || S();
            let t = e[0].indexState.offset
              , n = t.largestBatchId;
            for (let r = 1; r < e.length; r++) {
                let i = e[r].indexState.offset;
                0 > ei(i, t) && (t = i),
                n < i.largestBatchId && (n = i.largestBatchId)
            }
            return new er(t.readTime,t.documentKey,n)
        }
        let iv = {
            didRun: !1,
            sequenceNumbersCollected: 0,
            targetsRemoved: 0,
            documentsRemoved: 0
        };
        class i_ {
            constructor(e, t, n) {
                this.cacheSizeCollectionThreshold = e,
                this.percentileToCollect = t,
                this.maximumSequenceNumbersToCollect = n
            }
            static withCacheSize(e) {
                return new i_(e,i_.DEFAULT_COLLECTION_PERCENTILE,i_.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT)
            }
        }
        function iI(e, t, n) {
            let r = e.store("mutations")
              , i = e.store("documentMutations")
              , s = []
              , a = IDBKeyRange.only(n.batchId)
              , o = 0
              , l = r.J({
                range: a
            }, (e, t, n) => (o++,
            n.delete()));
            s.push(l.next( () => {
                1 === o || S()
            }
            ));
            let u = [];
            for (let e of n.mutations) {
                var c, h;
                let r = (c = e.key.path,
                h = n.batchId,
                [t, eS(c), h]);
                s.push(i.delete(r)),
                u.push(e.key)
            }
            return el.waitFor(s).next( () => u)
        }
        function ib(e) {
            let t;
            if (!e)
                return 0;
            if (e.document)
                t = e.document;
            else if (e.unknownDocument)
                t = e.unknownDocument;
            else {
                if (!e.noDocument)
                    throw S();
                t = e.noDocument
            }
            return JSON.stringify(t).length
        }
        i_.DEFAULT_COLLECTION_PERCENTILE = 10,
        i_.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3,
        i_.DEFAULT = new i_(41943040,i_.DEFAULT_COLLECTION_PERCENTILE,i_.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT),
        i_.DISABLED = new i_(-1,0,0);
        class iT {
            constructor(e, t, n, r) {
                this.userId = e,
                this.serializer = t,
                this.indexManager = n,
                this.referenceDelegate = r,
                this.Fn = {}
            }
            static lt(e, t, n, r) {
                return "" !== e.uid || S(),
                new iT(e.isAuthenticated() ? e.uid : "",t,n,r)
            }
            checkEmpty(e) {
                let t = !0
                  , n = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
                return iS(e).J({
                    index: "userMutationsIndex",
                    range: n
                }, (e, n, r) => {
                    t = !1,
                    r.done()
                }
                ).next( () => t)
            }
            addMutationBatch(e, t, n, r) {
                let i = ix(e)
                  , s = iS(e);
                return s.add({}).next(a => {
                    "number" == typeof a || S();
                    let o = new nH(a,t,n,r)
                      , l = function(e, t, n) {
                        let r = n.baseMutations.map(t => rC(e.ct, t))
                          , i = n.mutations.map(t => rC(e.ct, t));
                        return {
                            userId: t,
                            batchId: n.batchId,
                            localWriteTimeMs: n.localWriteTime.toMillis(),
                            baseMutations: r,
                            mutations: i
                        }
                    }(this.serializer, this.userId, o)
                      , u = []
                      , c = new e5( (e, t) => U(e.canonicalString(), t.canonicalString()));
                    for (let e of r) {
                        let t = [this.userId, eS(e.key.path), a];
                        c = c.add(e.key.path.popLast()),
                        u.push(s.put(l)),
                        u.push(i.put(t, eC))
                    }
                    return c.forEach(t => {
                        u.push(this.indexManager.addToCollectionParentIndex(e, t))
                    }
                    ),
                    e.addOnCommittedListener( () => {
                        this.Fn[a] = o.keys()
                    }
                    ),
                    el.waitFor(u).next( () => o)
                }
                )
            }
            lookupMutationBatch(e, t) {
                return iS(e).get(t).next(e => e ? (e.userId === this.userId || S(),
                rK(this.serializer, e)) : null)
            }
            Mn(e, t) {
                return this.Fn[t] ? el.resolve(this.Fn[t]) : this.lookupMutationBatch(e, t).next(e => {
                    if (e) {
                        let n = e.keys();
                        return this.Fn[t] = n,
                        n
                    }
                    return null
                }
                )
            }
            getNextMutationBatchAfterBatchId(e, t) {
                let n = t + 1
                  , r = IDBKeyRange.lowerBound([this.userId, n])
                  , i = null;
                return iS(e).J({
                    index: "userMutationsIndex",
                    range: r
                }, (e, t, r) => {
                    t.userId === this.userId && (t.batchId >= n || S(),
                    i = rK(this.serializer, t)),
                    r.done()
                }
                ).next( () => i)
            }
            getHighestUnacknowledgedBatchId(e) {
                let t = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY])
                  , n = -1;
                return iS(e).J({
                    index: "userMutationsIndex",
                    range: t,
                    reverse: !0
                }, (e, t, r) => {
                    n = t.batchId,
                    r.done()
                }
                ).next( () => n)
            }
            getAllMutationBatches(e) {
                let t = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);
                return iS(e).U("userMutationsIndex", t).next(e => e.map(e => rK(this.serializer, e)))
            }
            getAllMutationBatchesAffectingDocumentKey(e, t) {
                let n = [this.userId, eS(t.path)]
                  , r = IDBKeyRange.lowerBound(n)
                  , i = [];
                return ix(e).J({
                    range: r
                }, (n, r, s) => {
                    let[a,o,l] = n
                      , u = ex(o);
                    if (a === this.userId && t.path.isEqual(u))
                        return iS(e).get(l).next(e => {
                            if (!e)
                                throw S();
                            e.userId === this.userId || S(),
                            i.push(rK(this.serializer, e))
                        }
                        );
                    s.done()
                }
                ).next( () => i)
            }
            getAllMutationBatchesAffectingDocumentKeys(e, t) {
                let n = new e5(U)
                  , r = [];
                return t.forEach(t => {
                    let i = [this.userId, eS(t.path)]
                      , s = IDBKeyRange.lowerBound(i)
                      , a = ix(e).J({
                        range: s
                    }, (e, r, i) => {
                        let[s,a,o] = e
                          , l = ex(a);
                        s === this.userId && t.path.isEqual(l) ? n = n.add(o) : i.done()
                    }
                    );
                    r.push(a)
                }
                ),
                el.waitFor(r).next( () => this.xn(e, n))
            }
            getAllMutationBatchesAffectingQuery(e, t) {
                let n = t.path
                  , r = n.length + 1
                  , i = [this.userId, eS(n)]
                  , s = IDBKeyRange.lowerBound(i)
                  , a = new e5(U);
                return ix(e).J({
                    range: s
                }, (e, t, i) => {
                    let[s,o,l] = e
                      , u = ex(o);
                    s === this.userId && n.isPrefixOf(u) ? u.length === r && (a = a.add(l)) : i.done()
                }
                ).next( () => this.xn(e, a))
            }
            xn(e, t) {
                let n = []
                  , r = [];
                return t.forEach(t => {
                    r.push(iS(e).get(t).next(e => {
                        if (null === e)
                            throw S();
                        e.userId === this.userId || S(),
                        n.push(rK(this.serializer, e))
                    }
                    ))
                }
                ),
                el.waitFor(r).next( () => n)
            }
            removeMutationBatch(e, t) {
                return iI(e._e, this.userId, t).next(n => (e.addOnCommittedListener( () => {
                    this.On(t.batchId)
                }
                ),
                el.forEach(n, t => this.referenceDelegate.markPotentiallyOrphaned(e, t))))
            }
            On(e) {
                delete this.Fn[e]
            }
            performConsistencyCheck(e) {
                return this.checkEmpty(e).next(t => {
                    if (!t)
                        return el.resolve();
                    let n = IDBKeyRange.lowerBound([this.userId])
                      , r = [];
                    return ix(e).J({
                        range: n
                    }, (e, t, n) => {
                        if (e[0] === this.userId) {
                            let t = ex(e[1]);
                            r.push(t)
                        } else
                            n.done()
                    }
                    ).next( () => {
                        0 === r.length || S()
                    }
                    )
                }
                )
            }
            containsKey(e, t) {
                return iE(e, this.userId, t)
            }
            Nn(e) {
                return iD(e).get(this.userId).next(e => e || {
                    userId: this.userId,
                    lastAcknowledgedBatchId: -1,
                    lastStreamToken: ""
                })
            }
        }
        function iE(e, t, n) {
            let r = [t, eS(n.path)]
              , i = r[1]
              , s = IDBKeyRange.lowerBound(r)
              , a = !1;
            return ix(e).J({
                range: s,
                H: !0
            }, (e, n, r) => {
                let[s,o,l] = e;
                s === t && o === i && (a = !0),
                r.done()
            }
            ).next( () => a)
        }
        function iS(e) {
            return eJ(e, "mutations")
        }
        function ix(e) {
            return eJ(e, "documentMutations")
        }
        function iD(e) {
            return eJ(e, "mutationQueues")
        }
        class iC {
            constructor(e) {
                this.Ln = e
            }
            next() {
                return this.Ln += 2,
                this.Ln
            }
            static Bn() {
                return new iC(0)
            }
            static kn() {
                return new iC(-1)
            }
        }
        class iN {
            constructor(e, t) {
                this.referenceDelegate = e,
                this.serializer = t
            }
            allocateTargetId(e) {
                return this.qn(e).next(t => {
                    let n = new iC(t.highestTargetId);
                    return t.highestTargetId = n.next(),
                    this.Qn(e, t).next( () => t.highestTargetId)
                }
                )
            }
            getLastRemoteSnapshotVersion(e) {
                return this.qn(e).next(e => K.fromTimestamp(new z(e.lastRemoteSnapshotVersion.seconds,e.lastRemoteSnapshotVersion.nanoseconds)))
            }
            getHighestSequenceNumber(e) {
                return this.qn(e).next(e => e.highestListenSequenceNumber)
            }
            setTargetsMetadata(e, t, n) {
                return this.qn(e).next(r => (r.highestListenSequenceNumber = t,
                n && (r.lastRemoteSnapshotVersion = n.toTimestamp()),
                t > r.highestListenSequenceNumber && (r.highestListenSequenceNumber = t),
                this.Qn(e, r)))
            }
            addTargetData(e, t) {
                return this.Kn(e, t).next( () => this.qn(e).next(n => (n.targetCount += 1,
                this.$n(t, n),
                this.Qn(e, n))))
            }
            updateTargetData(e, t) {
                return this.Kn(e, t)
            }
            removeTargetData(e, t) {
                return this.removeMatchingKeysForTargetId(e, t.targetId).next( () => ik(e).delete(t.targetId)).next( () => this.qn(e)).next(t => (t.targetCount > 0 || S(),
                t.targetCount -= 1,
                this.Qn(e, t)))
            }
            removeTargets(e, t, n) {
                let r = 0
                  , i = [];
                return ik(e).J( (s, a) => {
                    let o = rG(a);
                    o.sequenceNumber <= t && null === n.get(o.targetId) && (r++,
                    i.push(this.removeTargetData(e, o)))
                }
                ).next( () => el.waitFor(i)).next( () => r)
            }
            forEachTarget(e, t) {
                return ik(e).J( (e, n) => {
                    t(rG(n))
                }
                )
            }
            qn(e) {
                return iA(e).get("targetGlobalKey").next(e => (null !== e || S(),
                e))
            }
            Qn(e, t) {
                return iA(e).put("targetGlobalKey", t)
            }
            Kn(e, t) {
                return ik(e).put(r$(this.serializer, t))
            }
            $n(e, t) {
                let n = !1;
                return e.targetId > t.highestTargetId && (t.highestTargetId = e.targetId,
                n = !0),
                e.sequenceNumber > t.highestListenSequenceNumber && (t.highestListenSequenceNumber = e.sequenceNumber,
                n = !0),
                n
            }
            getTargetCount(e) {
                return this.qn(e).next(e => e.targetCount)
            }
            getTargetData(e, t) {
                let n = t0(t)
                  , r = IDBKeyRange.bound([n, Number.NEGATIVE_INFINITY], [n, Number.POSITIVE_INFINITY])
                  , i = null;
                return ik(e).J({
                    range: r,
                    index: "queryTargetsIndex"
                }, (e, n, r) => {
                    let s = rG(n);
                    t1(t, s.target) && (i = s,
                    r.done())
                }
                ).next( () => i)
            }
            addMatchingKeys(e, t, n) {
                let r = []
                  , i = iR(e);
                return t.forEach(t => {
                    let s = eS(t.path);
                    r.push(i.put({
                        targetId: n,
                        path: s
                    })),
                    r.push(this.referenceDelegate.addReference(e, n, t))
                }
                ),
                el.waitFor(r)
            }
            removeMatchingKeys(e, t, n) {
                let r = iR(e);
                return el.forEach(t, t => {
                    let i = eS(t.path);
                    return el.waitFor([r.delete([n, i]), this.referenceDelegate.removeReference(e, n, t)])
                }
                )
            }
            removeMatchingKeysForTargetId(e, t) {
                let n = iR(e)
                  , r = IDBKeyRange.bound([t], [t + 1], !1, !0);
                return n.delete(r)
            }
            getMatchingKeysForTargetId(e, t) {
                let n = IDBKeyRange.bound([t], [t + 1], !1, !0)
                  , r = iR(e)
                  , i = n_();
                return r.J({
                    range: n,
                    H: !0
                }, (e, t, n) => {
                    let r = new W(ex(e[1]));
                    i = i.add(r)
                }
                ).next( () => i)
            }
            containsKey(e, t) {
                let n = eS(t.path)
                  , r = IDBKeyRange.bound([n], [n + "\0"], !1, !0)
                  , i = 0;
                return iR(e).J({
                    index: "documentTargetsIndex",
                    H: !0,
                    range: r
                }, ([e,t], n, r) => {
                    0 !== e && (i++,
                    r.done())
                }
                ).next( () => i > 0)
            }
            ot(e, t) {
                return ik(e).get(t).next(e => e ? rG(e) : null)
            }
        }
        function ik(e) {
            return eJ(e, "targets")
        }
        function iA(e) {
            return eJ(e, "targetGlobal")
        }
        function iR(e) {
            return eJ(e, "targetDocuments")
        }
        function iF([e,t], [n,r]) {
            let i = U(e, n);
            return 0 === i ? U(t, r) : i
        }
        class iV {
            constructor(e) {
                this.Un = e,
                this.buffer = new e5(iF),
                this.Wn = 0
            }
            Gn() {
                return ++this.Wn
            }
            zn(e) {
                let t = [e, this.Gn()];
                if (this.buffer.size < this.Un)
                    this.buffer = this.buffer.add(t);
                else {
                    let e = this.buffer.last();
                    0 > iF(t, e) && (this.buffer = this.buffer.delete(e).add(t))
                }
            }
            get maxValue() {
                return this.buffer.last()[0]
            }
        }
        class iM {
            constructor(e, t, n) {
                this.garbageCollector = e,
                this.asyncQueue = t,
                this.localStore = n,
                this.jn = null
            }
            start() {
                -1 !== this.garbageCollector.params.cacheSizeCollectionThreshold && this.Hn(6e4)
            }
            stop() {
                this.jn && (this.jn.cancel(),
                this.jn = null)
            }
            get started() {
                return null !== this.jn
            }
            Hn(e) {
                I("LruGarbageCollector", `Garbage collection scheduled in ${e}ms`),
                this.jn = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", e, async () => {
                    this.jn = null;
                    try {
                        await this.localStore.collectGarbage(this.garbageCollector)
                    } catch (e) {
                        em(e) ? I("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", e) : await eo(e)
                    }
                    await this.Hn(3e5)
                }
                )
            }
        }
        class iO {
            constructor(e, t) {
                this.Jn = e,
                this.params = t
            }
            calculateTargetCount(e, t) {
                return this.Jn.Yn(e).next(e => Math.floor(t / 100 * e))
            }
            nthSequenceNumber(e, t) {
                if (0 === t)
                    return el.resolve(eI.oe);
                let n = new iV(t);
                return this.Jn.forEachTarget(e, e => n.zn(e.sequenceNumber)).next( () => this.Jn.Zn(e, e => n.zn(e))).next( () => n.maxValue)
            }
            removeTargets(e, t, n) {
                return this.Jn.removeTargets(e, t, n)
            }
            removeOrphanedDocuments(e, t) {
                return this.Jn.removeOrphanedDocuments(e, t)
            }
            collect(e, t) {
                return -1 === this.params.cacheSizeCollectionThreshold ? (I("LruGarbageCollector", "Garbage collection skipped; disabled"),
                el.resolve(iv)) : this.getCacheSize(e).next(n => n < this.params.cacheSizeCollectionThreshold ? (I("LruGarbageCollector", `Garbage collection skipped; Cache size ${n} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`),
                iv) : this.Xn(e, t))
            }
            getCacheSize(e) {
                return this.Jn.getCacheSize(e)
            }
            Xn(e, t) {
                let n, r, i, s, a, o, l;
                let c = Date.now();
                return this.calculateTargetCount(e, this.params.percentileToCollect).next(t => (t > this.params.maximumSequenceNumbersToCollect ? (I("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${t}`),
                r = this.params.maximumSequenceNumbersToCollect) : r = t,
                s = Date.now(),
                this.nthSequenceNumber(e, r))).next(r => (n = r,
                a = Date.now(),
                this.removeTargets(e, n, t))).next(t => (i = t,
                o = Date.now(),
                this.removeOrphanedDocuments(e, n))).next(e => (l = Date.now(),
                v() <= u.in.DEBUG && I("LruGarbageCollector", `LRU Garbage Collection
	Counted targets in ${s - c}ms
	Determined least recently used ${r} in ` + (a - s) + "ms\n" + `	Removed ${i} targets in ` + (o - a) + "ms\n" + `	Removed ${e} documents in ` + (l - o) + "ms\n" + `Total Duration: ${l - c}ms`),
                el.resolve({
                    didRun: !0,
                    sequenceNumbersCollected: r,
                    targetsRemoved: i,
                    documentsRemoved: e
                })))
            }
        }
        class iL {
            constructor(e, t) {
                this.db = e,
                this.garbageCollector = new iO(this,t)
            }
            Yn(e) {
                let t = this.er(e);
                return this.db.getTargetCache().getTargetCount(e).next(e => t.next(t => e + t))
            }
            er(e) {
                let t = 0;
                return this.Zn(e, e => {
                    t++
                }
                ).next( () => t)
            }
            forEachTarget(e, t) {
                return this.db.getTargetCache().forEachTarget(e, t)
            }
            Zn(e, t) {
                return this.tr(e, (e, n) => t(n))
            }
            addReference(e, t, n) {
                return iP(e, n)
            }
            removeReference(e, t, n) {
                return iP(e, n)
            }
            removeTargets(e, t, n) {
                return this.db.getTargetCache().removeTargets(e, t, n)
            }
            markPotentiallyOrphaned(e, t) {
                return iP(e, t)
            }
            nr(e, t) {
                let n;
                return n = !1,
                iD(e).Y(r => iE(e, r, t).next(e => (e && (n = !0),
                el.resolve(!e)))).next( () => n)
            }
            removeOrphanedDocuments(e, t) {
                let n = this.db.getRemoteDocumentCache().newChangeBuffer()
                  , r = []
                  , i = 0;
                return this.tr(e, (s, a) => {
                    if (a <= t) {
                        let t = this.nr(e, s).next(t => {
                            if (!t)
                                return i++,
                                n.getEntry(e, s).next( () => (n.removeEntry(s, K.min()),
                                iR(e).delete([0, eS(s.path)])))
                        }
                        );
                        r.push(t)
                    }
                }
                ).next( () => el.waitFor(r)).next( () => n.apply(e)).next( () => i)
            }
            removeTarget(e, t) {
                let n = t.withSequenceNumber(e.currentSequenceNumber);
                return this.db.getTargetCache().updateTargetData(e, n)
            }
            updateLimboDocument(e, t) {
                return iP(e, t)
            }
            tr(e, t) {
                let n = iR(e), r, i = eI.oe;
                return n.J({
                    index: "documentTargetsIndex"
                }, ([e,n], {path: s, sequenceNumber: a}) => {
                    0 === e ? (i !== eI.oe && t(new W(ex(r)), i),
                    i = a,
                    r = s) : i = eI.oe
                }
                ).next( () => {
                    i !== eI.oe && t(new W(ex(r)), i)
                }
                )
            }
            getCacheSize(e) {
                return this.db.getRemoteDocumentCache().getSize(e)
            }
        }
        function iP(e, t) {
            var n;
            return iR(e).put((n = e.currentSequenceNumber,
            {
                targetId: 0,
                path: eS(t.path),
                sequenceNumber: n
            }))
        }
        class iq {
            constructor() {
                this.changes = new nd(e => e.toString(), (e, t) => e.isEqual(t)),
                this.changesApplied = !1
            }
            addEntry(e) {
                this.assertNotApplied(),
                this.changes.set(e.key, e)
            }
            removeEntry(e, t) {
                this.assertNotApplied(),
                this.changes.set(e, tA.newInvalidDocument(e).setReadTime(t))
            }
            getEntry(e, t) {
                this.assertNotApplied();
                let n = this.changes.get(t);
                return void 0 !== n ? el.resolve(n) : this.getFromCache(e, t)
            }
            getEntries(e, t) {
                return this.getAllFromCache(e, t)
            }
            apply(e) {
                return this.assertNotApplied(),
                this.changesApplied = !0,
                this.applyChanges(e)
            }
            assertNotApplied() {}
        }
        class iU {
            constructor(e) {
                this.serializer = e
            }
            setIndexManager(e) {
                this.indexManager = e
            }
            addEntry(e, t, n) {
                return iK(e).put(n)
            }
            removeEntry(e, t, n) {
                return iK(e).delete(function(e, t) {
                    let n = e.path.toArray();
                    return [n.slice(0, n.length - 2), n[n.length - 2], rU(t), n[n.length - 1]]
                }(t, n))
            }
            updateMetadata(e, t) {
                return this.getMetadata(e).next(n => (n.byteSize += t,
                this.rr(e, n)))
            }
            getEntry(e, t) {
                let n = tA.newInvalidDocument(t);
                return iK(e).J({
                    index: "documentKeyIndex",
                    range: IDBKeyRange.only(iG(t))
                }, (e, r) => {
                    n = this.ir(t, r)
                }
                ).next( () => n)
            }
            sr(e, t) {
                let n = {
                    size: 0,
                    document: tA.newInvalidDocument(t)
                };
                return iK(e).J({
                    index: "documentKeyIndex",
                    range: IDBKeyRange.only(iG(t))
                }, (e, r) => {
                    n = {
                        document: this.ir(t, r),
                        size: ib(r)
                    }
                }
                ).next( () => n)
            }
            getEntries(e, t) {
                let n = nf;
                return this._r(e, t, (e, t) => {
                    let r = this.ir(e, t);
                    n = n.insert(e, r)
                }
                ).next( () => n)
            }
            ar(e, t) {
                let n = nf
                  , r = new e0(W.comparator);
                return this._r(e, t, (e, t) => {
                    let i = this.ir(e, t);
                    n = n.insert(e, i),
                    r = r.insert(e, ib(t))
                }
                ).next( () => ({
                    documents: n,
                    ur: r
                }))
            }
            _r(e, t, n) {
                if (t.isEmpty())
                    return el.resolve();
                let r = new e5(iQ);
                t.forEach(e => r = r.add(e));
                let i = IDBKeyRange.bound(iG(r.first()), iG(r.last()))
                  , s = r.getIterator()
                  , a = s.getNext();
                return iK(e).J({
                    index: "documentKeyIndex",
                    range: i
                }, (e, t, r) => {
                    let i = W.fromSegments([...t.prefixPath, t.collectionGroup, t.documentId]);
                    for (; a && 0 > iQ(a, i); )
                        n(a, null),
                        a = s.getNext();
                    a && a.isEqual(i) && (n(a, t),
                    a = s.hasNext() ? s.getNext() : null),
                    a ? r.$(iG(a)) : r.done()
                }
                ).next( () => {
                    for (; a; )
                        n(a, null),
                        a = s.hasNext() ? s.getNext() : null
                }
                )
            }
            getDocumentsMatchingQuery(e, t, n, r, i) {
                let s = t.path
                  , a = [s.popLast().toArray(), s.lastSegment(), rU(n.readTime), n.documentKey.path.isEmpty() ? "" : n.documentKey.path.lastSegment()]
                  , o = [s.popLast().toArray(), s.lastSegment(), [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], ""];
                return iK(e).U(IDBKeyRange.bound(a, o, !0)).next(e => {
                    null == i || i.incrementDocumentReadCount(e.length);
                    let n = nf;
                    for (let i of e) {
                        let e = this.ir(W.fromSegments(i.prefixPath.concat(i.collectionGroup, i.documentId)), i);
                        e.isFoundDocument() && (nu(t, e) || r.has(e.key)) && (n = n.insert(e.key, e))
                    }
                    return n
                }
                )
            }
            getAllFromCollectionGroup(e, t, n, r) {
                let i = nf
                  , s = i$(t, n)
                  , a = i$(t, er.max());
                return iK(e).J({
                    index: "collectionGroupIndex",
                    range: IDBKeyRange.bound(s, a, !0)
                }, (e, t, n) => {
                    let s = this.ir(W.fromSegments(t.prefixPath.concat(t.collectionGroup, t.documentId)), t);
                    (i = i.insert(s.key, s)).size === r && n.done()
                }
                ).next( () => i)
            }
            newChangeBuffer(e) {
                return new iB(this,!!e && e.trackRemovals)
            }
            getSize(e) {
                return this.getMetadata(e).next(e => e.byteSize)
            }
            getMetadata(e) {
                return iz(e).get("remoteDocumentGlobalKey").next(e => (e || S(),
                e))
            }
            rr(e, t) {
                return iz(e).put("remoteDocumentGlobalKey", t)
            }
            ir(e, t) {
                if (t) {
                    let e = function(e, t) {
                        let n;
                        if (t.document)
                            n = rD(e.ct, t.document, !!t.hasCommittedMutations);
                        else if (t.noDocument) {
                            let e = W.fromSegments(t.noDocument.path)
                              , r = rz(t.noDocument.readTime);
                            n = tA.newNoDocument(e, r),
                            t.hasCommittedMutations && n.setHasCommittedMutations()
                        } else {
                            if (!t.unknownDocument)
                                return S();
                            {
                                let e = W.fromSegments(t.unknownDocument.path)
                                  , r = rz(t.unknownDocument.version);
                                n = tA.newUnknownDocument(e, r)
                            }
                        }
                        return t.readTime && n.setReadTime(function(e) {
                            let t = new z(e[0],e[1]);
                            return K.fromTimestamp(t)
                        }(t.readTime)),
                        n
                    }(this.serializer, t);
                    if (!(e.isNoDocument() && e.version.isEqual(K.min())))
                        return e
                }
                return tA.newInvalidDocument(e)
            }
        }
        class iB extends iq {
            constructor(e, t) {
                super(),
                this.cr = e,
                this.trackRemovals = t,
                this.lr = new nd(e => e.toString(), (e, t) => e.isEqual(t))
            }
            applyChanges(e) {
                let t = []
                  , n = 0
                  , r = new e5( (e, t) => U(e.canonicalString(), t.canonicalString()));
                return this.changes.forEach( (i, s) => {
                    let a = this.lr.get(i);
                    if (t.push(this.cr.removeEntry(e, i, a.readTime)),
                    s.isValidDocument()) {
                        let o = rq(this.cr.serializer, s);
                        r = r.add(i.path.popLast());
                        let l = ib(o);
                        n += l - a.size,
                        t.push(this.cr.addEntry(e, i, o))
                    } else if (n -= a.size,
                    this.trackRemovals) {
                        let n = rq(this.cr.serializer, s.convertToNoDocument(K.min()));
                        t.push(this.cr.addEntry(e, i, n))
                    }
                }
                ),
                r.forEach(n => {
                    t.push(this.cr.indexManager.addToCollectionParentIndex(e, n))
                }
                ),
                t.push(this.cr.updateMetadata(e, n)),
                el.waitFor(t)
            }
            getFromCache(e, t) {
                return this.cr.sr(e, t).next(e => (this.lr.set(t, {
                    size: e.size,
                    readTime: e.document.readTime
                }),
                e.document))
            }
            getAllFromCache(e, t) {
                return this.cr.ar(e, t).next( ({documents: e, ur: t}) => (t.forEach( (t, n) => {
                    this.lr.set(t, {
                        size: n,
                        readTime: e.get(t).readTime
                    })
                }
                ),
                e))
            }
        }
        function iz(e) {
            return eJ(e, "remoteDocumentGlobal")
        }
        function iK(e) {
            return eJ(e, "remoteDocumentsV14")
        }
        function iG(e) {
            let t = e.path.toArray();
            return [t.slice(0, t.length - 2), t[t.length - 2], t[t.length - 1]]
        }
        function i$(e, t) {
            let n = t.documentKey.path.toArray();
            return [e, rU(t.readTime), n.slice(0, n.length - 2), n.length > 0 ? n[n.length - 1] : ""]
        }
        function iQ(e, t) {
            let n = e.path.toArray()
              , r = t.path.toArray()
              , i = 0;
            for (let e = 0; e < n.length - 2 && e < r.length - 2; ++e)
                if (i = U(n[e], r[e]))
                    return i;
            return (i = U(n.length, r.length)) || (i = U(n[n.length - 2], r[r.length - 2])) || U(n[n.length - 1], r[r.length - 1])
        }
        class ij {
            constructor(e, t) {
                this.overlayedDocument = e,
                this.mutatedFields = t
            }
        }
        class iW {
            constructor(e, t, n, r) {
                this.remoteDocumentCache = e,
                this.mutationQueue = t,
                this.documentOverlayCache = n,
                this.indexManager = r
            }
            getDocument(e, t) {
                let n = null;
                return this.documentOverlayCache.getOverlay(e, t).next(r => (n = r,
                this.remoteDocumentCache.getEntry(e, t))).next(e => (null !== n && nB(n.mutation, e, e3.empty(), z.now()),
                e))
            }
            getDocuments(e, t) {
                return this.remoteDocumentCache.getEntries(e, t).next(t => this.getLocalViewOfDocuments(e, t, n_()).next( () => t))
            }
            getLocalViewOfDocuments(e, t, n=n_()) {
                let r = ny();
                return this.populateOverlays(e, r, t).next( () => this.computeViews(e, t, r, n).next(e => {
                    let t = ng();
                    return e.forEach( (e, n) => {
                        t = t.insert(e, n.overlayedDocument)
                    }
                    ),
                    t
                }
                ))
            }
            getOverlayedDocuments(e, t) {
                let n = ny();
                return this.populateOverlays(e, n, t).next( () => this.computeViews(e, t, n, n_()))
            }
            populateOverlays(e, t, n) {
                let r = [];
                return n.forEach(e => {
                    t.has(e) || r.push(e)
                }
                ),
                this.documentOverlayCache.getOverlays(e, r).next(e => {
                    e.forEach( (e, n) => {
                        t.set(e, n)
                    }
                    )
                }
                )
            }
            computeViews(e, t, n, r) {
                let i = nf
                  , s = ny()
                  , a = ny();
                return t.forEach( (e, t) => {
                    let a = n.get(t.key);
                    r.has(t.key) && (void 0 === a || a.mutation instanceof nG) ? i = i.insert(t.key, t) : void 0 !== a ? (s.set(t.key, a.mutation.getFieldMask()),
                    nB(a.mutation, t, a.mutation.getFieldMask(), z.now())) : s.set(t.key, e3.empty())
                }
                ),
                this.recalculateAndSaveOverlays(e, i).next(e => (e.forEach( (e, t) => s.set(e, t)),
                t.forEach( (e, t) => {
                    var n;
                    return a.set(e, new ij(t,null !== (n = s.get(e)) && void 0 !== n ? n : null))
                }
                ),
                a))
            }
            recalculateAndSaveOverlays(e, t) {
                let n = ny()
                  , r = new e0( (e, t) => e - t)
                  , i = n_();
                return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(e, t).next(e => {
                    for (let i of e)
                        i.keys().forEach(e => {
                            let s = t.get(e);
                            if (null === s)
                                return;
                            let a = n.get(e) || e3.empty();
                            a = i.applyToLocalView(s, a),
                            n.set(e, a);
                            let o = (r.get(i.batchId) || n_()).add(e);
                            r = r.insert(i.batchId, o)
                        }
                        )
                }
                ).next( () => {
                    let s = []
                      , a = r.getReverseIterator();
                    for (; a.hasNext(); ) {
                        let r = a.getNext()
                          , o = r.key
                          , l = r.value
                          , u = ny();
                        l.forEach(e => {
                            if (!i.has(e)) {
                                let r = nU(t.get(e), n.get(e));
                                null !== r && u.set(e, r),
                                i = i.add(e)
                            }
                        }
                        ),
                        s.push(this.documentOverlayCache.saveOverlays(e, o, u))
                    }
                    return el.waitFor(s)
                }
                ).next( () => n)
            }
            recalculateAndSaveOverlaysForDocumentKeys(e, t) {
                return this.remoteDocumentCache.getEntries(e, t).next(t => this.recalculateAndSaveOverlays(e, t))
            }
            getDocumentsMatchingQuery(e, t, n, r) {
                return W.isDocumentKey(t.path) && null === t.collectionGroup && 0 === t.filters.length ? this.getDocumentsMatchingDocumentQuery(e, t.path) : t7(t) ? this.getDocumentsMatchingCollectionGroupQuery(e, t, n, r) : this.getDocumentsMatchingCollectionQuery(e, t, n, r)
            }
            getNextDocuments(e, t, n, r) {
                return this.remoteDocumentCache.getAllFromCollectionGroup(e, t, n, r).next(i => {
                    let s = r - i.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(e, t, n.largestBatchId, r - i.size) : el.resolve(ny())
                      , a = -1
                      , o = i;
                    return s.next(t => el.forEach(t, (t, n) => (a < n.largestBatchId && (a = n.largestBatchId),
                    i.get(t) ? el.resolve() : this.remoteDocumentCache.getEntry(e, t).next(e => {
                        o = o.insert(t, e)
                    }
                    ))).next( () => this.populateOverlays(e, t, i)).next( () => this.computeViews(e, o, t, n_())).next(e => ({
                        batchId: a,
                        changes: np(e)
                    })))
                }
                )
            }
            getDocumentsMatchingDocumentQuery(e, t) {
                return this.getDocument(e, new W(t)).next(e => {
                    let t = ng();
                    return e.isFoundDocument() && (t = t.insert(e.key, e)),
                    t
                }
                )
            }
            getDocumentsMatchingCollectionGroupQuery(e, t, n, r) {
                let i = t.collectionGroup
                  , s = ng();
                return this.indexManager.getCollectionParents(e, i).next(a => el.forEach(a, a => {
                    let o = new t3(a.child(i),null,t.explicitOrderBy.slice(),t.filters.slice(),t.limit,t.limitType,t.startAt,t.endAt);
                    return this.getDocumentsMatchingCollectionQuery(e, o, n, r).next(e => {
                        e.forEach( (e, t) => {
                            s = s.insert(e, t)
                        }
                        )
                    }
                    )
                }
                ).next( () => s))
            }
            getDocumentsMatchingCollectionQuery(e, t, n, r) {
                let i;
                return this.documentOverlayCache.getOverlaysForCollection(e, t.path, n.largestBatchId).next(s => (i = s,
                this.remoteDocumentCache.getDocumentsMatchingQuery(e, t, n, i, r))).next(e => {
                    i.forEach( (t, n) => {
                        let r = n.getKey();
                        null === e.get(r) && (e = e.insert(r, tA.newInvalidDocument(r)))
                    }
                    );
                    let n = ng();
                    return e.forEach( (e, r) => {
                        let s = i.get(e);
                        void 0 !== s && nB(s.mutation, r, e3.empty(), z.now()),
                        nu(t, r) && (n = n.insert(e, r))
                    }
                    ),
                    n
                }
                )
            }
        }
        class iJ {
            constructor(e) {
                this.serializer = e,
                this.hr = new Map,
                this.Pr = new Map
            }
            getBundleMetadata(e, t) {
                return el.resolve(this.hr.get(t))
            }
            saveBundleMetadata(e, t) {
                return this.hr.set(t.id, {
                    id: t.id,
                    version: t.version,
                    createTime: rp(t.createTime)
                }),
                el.resolve()
            }
            getNamedQuery(e, t) {
                return el.resolve(this.Pr.get(t))
            }
            saveNamedQuery(e, t) {
                return this.Pr.set(t.name, {
                    name: t.name,
                    query: rQ(t.bundledQuery),
                    readTime: rp(t.readTime)
                }),
                el.resolve()
            }
        }
        class iH {
            constructor() {
                this.overlays = new e0(W.comparator),
                this.Ir = new Map
            }
            getOverlay(e, t) {
                return el.resolve(this.overlays.get(t))
            }
            getOverlays(e, t) {
                let n = ny();
                return el.forEach(t, t => this.getOverlay(e, t).next(e => {
                    null !== e && n.set(t, e)
                }
                )).next( () => n)
            }
            saveOverlays(e, t, n) {
                return n.forEach( (n, r) => {
                    this.ht(e, t, r)
                }
                ),
                el.resolve()
            }
            removeOverlaysForBatchId(e, t, n) {
                let r = this.Ir.get(n);
                return void 0 !== r && (r.forEach(e => this.overlays = this.overlays.remove(e)),
                this.Ir.delete(n)),
                el.resolve()
            }
            getOverlaysForCollection(e, t, n) {
                let r = ny()
                  , i = t.length + 1
                  , s = new W(t.child(""))
                  , a = this.overlays.getIteratorFrom(s);
                for (; a.hasNext(); ) {
                    let e = a.getNext().value
                      , s = e.getKey();
                    if (!t.isPrefixOf(s.path))
                        break;
                    s.path.length === i && e.largestBatchId > n && r.set(e.getKey(), e)
                }
                return el.resolve(r)
            }
            getOverlaysForCollectionGroup(e, t, n, r) {
                let i = new e0( (e, t) => e - t)
                  , s = this.overlays.getIterator();
                for (; s.hasNext(); ) {
                    let e = s.getNext().value;
                    if (e.getKey().getCollectionGroup() === t && e.largestBatchId > n) {
                        let t = i.get(e.largestBatchId);
                        null === t && (t = ny(),
                        i = i.insert(e.largestBatchId, t)),
                        t.set(e.getKey(), e)
                    }
                }
                let a = ny()
                  , o = i.getIterator();
                for (; o.hasNext() && (o.getNext().value.forEach( (e, t) => a.set(e, t)),
                !(a.size() >= r)); )
                    ;
                return el.resolve(a)
            }
            ht(e, t, n) {
                let r = this.overlays.get(n.key);
                if (null !== r) {
                    let e = this.Ir.get(r.largestBatchId).delete(n.key);
                    this.Ir.set(r.largestBatchId, e)
                }
                this.overlays = this.overlays.insert(n.key, new nX(t,n));
                let i = this.Ir.get(t);
                void 0 === i && (i = n_(),
                this.Ir.set(t, i)),
                this.Ir.set(t, i.add(n.key))
            }
        }
        class iY {
            constructor() {
                this.sessionToken = e7.EMPTY_BYTE_STRING
            }
            getSessionToken(e) {
                return el.resolve(this.sessionToken)
            }
            setSessionToken(e, t) {
                return this.sessionToken = t,
                el.resolve()
            }
        }
        class iX {
            constructor() {
                this.Tr = new e5(iZ.Er),
                this.dr = new e5(iZ.Ar)
            }
            isEmpty() {
                return this.Tr.isEmpty()
            }
            addReference(e, t) {
                let n = new iZ(e,t);
                this.Tr = this.Tr.add(n),
                this.dr = this.dr.add(n)
            }
            Rr(e, t) {
                e.forEach(e => this.addReference(e, t))
            }
            removeReference(e, t) {
                this.Vr(new iZ(e,t))
            }
            mr(e, t) {
                e.forEach(e => this.removeReference(e, t))
            }
            gr(e) {
                let t = new W(new $([]))
                  , n = new iZ(t,e)
                  , r = new iZ(t,e + 1)
                  , i = [];
                return this.dr.forEachInRange([n, r], e => {
                    this.Vr(e),
                    i.push(e.key)
                }
                ),
                i
            }
            pr() {
                this.Tr.forEach(e => this.Vr(e))
            }
            Vr(e) {
                this.Tr = this.Tr.delete(e),
                this.dr = this.dr.delete(e)
            }
            yr(e) {
                let t = new W(new $([]))
                  , n = new iZ(t,e)
                  , r = new iZ(t,e + 1)
                  , i = n_();
                return this.dr.forEachInRange([n, r], e => {
                    i = i.add(e.key)
                }
                ),
                i
            }
            containsKey(e) {
                let t = new iZ(e,0)
                  , n = this.Tr.firstAfterOrEqual(t);
                return null !== n && e.isEqual(n.key)
            }
        }
        class iZ {
            constructor(e, t) {
                this.key = e,
                this.wr = t
            }
            static Er(e, t) {
                return W.comparator(e.key, t.key) || U(e.wr, t.wr)
            }
            static Ar(e, t) {
                return U(e.wr, t.wr) || W.comparator(e.key, t.key)
            }
        }
        class i0 {
            constructor(e, t) {
                this.indexManager = e,
                this.referenceDelegate = t,
                this.mutationQueue = [],
                this.Sr = 1,
                this.br = new e5(iZ.Er)
            }
            checkEmpty(e) {
                return el.resolve(0 === this.mutationQueue.length)
            }
            addMutationBatch(e, t, n, r) {
                let i = this.Sr;
                this.Sr++,
                this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1];
                let s = new nH(i,t,n,r);
                for (let t of (this.mutationQueue.push(s),
                r))
                    this.br = this.br.add(new iZ(t.key,i)),
                    this.indexManager.addToCollectionParentIndex(e, t.key.path.popLast());
                return el.resolve(s)
            }
            lookupMutationBatch(e, t) {
                return el.resolve(this.Dr(t))
            }
            getNextMutationBatchAfterBatchId(e, t) {
                let n = this.vr(t + 1)
                  , r = n < 0 ? 0 : n;
                return el.resolve(this.mutationQueue.length > r ? this.mutationQueue[r] : null)
            }
            getHighestUnacknowledgedBatchId() {
                return el.resolve(0 === this.mutationQueue.length ? -1 : this.Sr - 1)
            }
            getAllMutationBatches(e) {
                return el.resolve(this.mutationQueue.slice())
            }
            getAllMutationBatchesAffectingDocumentKey(e, t) {
                let n = new iZ(t,0)
                  , r = new iZ(t,Number.POSITIVE_INFINITY)
                  , i = [];
                return this.br.forEachInRange([n, r], e => {
                    let t = this.Dr(e.wr);
                    i.push(t)
                }
                ),
                el.resolve(i)
            }
            getAllMutationBatchesAffectingDocumentKeys(e, t) {
                let n = new e5(U);
                return t.forEach(e => {
                    let t = new iZ(e,0)
                      , r = new iZ(e,Number.POSITIVE_INFINITY);
                    this.br.forEachInRange([t, r], e => {
                        n = n.add(e.wr)
                    }
                    )
                }
                ),
                el.resolve(this.Cr(n))
            }
            getAllMutationBatchesAffectingQuery(e, t) {
                let n = t.path
                  , r = n.length + 1
                  , i = n;
                W.isDocumentKey(i) || (i = i.child(""));
                let s = new iZ(new W(i),0)
                  , a = new e5(U);
                return this.br.forEachWhile(e => {
                    let t = e.key.path;
                    return !!n.isPrefixOf(t) && (t.length === r && (a = a.add(e.wr)),
                    !0)
                }
                , s),
                el.resolve(this.Cr(a))
            }
            Cr(e) {
                let t = [];
                return e.forEach(e => {
                    let n = this.Dr(e);
                    null !== n && t.push(n)
                }
                ),
                t
            }
            removeMutationBatch(e, t) {
                0 === this.Fr(t.batchId, "removed") || S(),
                this.mutationQueue.shift();
                let n = this.br;
                return el.forEach(t.mutations, r => {
                    let i = new iZ(r.key,t.batchId);
                    return n = n.delete(i),
                    this.referenceDelegate.markPotentiallyOrphaned(e, r.key)
                }
                ).next( () => {
                    this.br = n
                }
                )
            }
            On(e) {}
            containsKey(e, t) {
                let n = new iZ(t,0)
                  , r = this.br.firstAfterOrEqual(n);
                return el.resolve(t.isEqual(r && r.key))
            }
            performConsistencyCheck(e) {
                return this.mutationQueue.length,
                el.resolve()
            }
            Fr(e, t) {
                return this.vr(e)
            }
            vr(e) {
                return 0 === this.mutationQueue.length ? 0 : e - this.mutationQueue[0].batchId
            }
            Dr(e) {
                let t = this.vr(e);
                return t < 0 || t >= this.mutationQueue.length ? null : this.mutationQueue[t]
            }
        }
        class i1 {
            constructor(e) {
                this.Mr = e,
                this.docs = new e0(W.comparator),
                this.size = 0
            }
            setIndexManager(e) {
                this.indexManager = e
            }
            addEntry(e, t) {
                let n = t.key
                  , r = this.docs.get(n)
                  , i = r ? r.size : 0
                  , s = this.Mr(t);
                return this.docs = this.docs.insert(n, {
                    document: t.mutableCopy(),
                    size: s
                }),
                this.size += s - i,
                this.indexManager.addToCollectionParentIndex(e, n.path.popLast())
            }
            removeEntry(e) {
                let t = this.docs.get(e);
                t && (this.docs = this.docs.remove(e),
                this.size -= t.size)
            }
            getEntry(e, t) {
                let n = this.docs.get(t);
                return el.resolve(n ? n.document.mutableCopy() : tA.newInvalidDocument(t))
            }
            getEntries(e, t) {
                let n = nf;
                return t.forEach(e => {
                    let t = this.docs.get(e);
                    n = n.insert(e, t ? t.document.mutableCopy() : tA.newInvalidDocument(e))
                }
                ),
                el.resolve(n)
            }
            getDocumentsMatchingQuery(e, t, n, r) {
                let i = nf
                  , s = t.path
                  , a = new W(s.child(""))
                  , o = this.docs.getIteratorFrom(a);
                for (; o.hasNext(); ) {
                    let {key: e, value: {document: a}} = o.getNext();
                    if (!s.isPrefixOf(e.path))
                        break;
                    e.path.length > s.length + 1 || 0 >= ei(en(a), n) || (r.has(a.key) || nu(t, a)) && (i = i.insert(a.key, a.mutableCopy()))
                }
                return el.resolve(i)
            }
            getAllFromCollectionGroup(e, t, n, r) {
                S()
            }
            Or(e, t) {
                return el.forEach(this.docs, e => t(e))
            }
            newChangeBuffer(e) {
                return new i2(this)
            }
            getSize(e) {
                return el.resolve(this.size)
            }
        }
        class i2 extends iq {
            constructor(e) {
                super(),
                this.cr = e
            }
            applyChanges(e) {
                let t = [];
                return this.changes.forEach( (n, r) => {
                    r.isValidDocument() ? t.push(this.cr.addEntry(e, r)) : this.cr.removeEntry(n)
                }
                ),
                el.waitFor(t)
            }
            getFromCache(e, t) {
                return this.cr.getEntry(e, t)
            }
            getAllFromCache(e, t) {
                return this.cr.getEntries(e, t)
            }
        }
        class i5 {
            constructor(e) {
                this.persistence = e,
                this.Nr = new nd(e => t0(e),t1),
                this.lastRemoteSnapshotVersion = K.min(),
                this.highestTargetId = 0,
                this.Lr = 0,
                this.Br = new iX,
                this.targetCount = 0,
                this.kr = iC.Bn()
            }
            forEachTarget(e, t) {
                return this.Nr.forEach( (e, n) => t(n)),
                el.resolve()
            }
            getLastRemoteSnapshotVersion(e) {
                return el.resolve(this.lastRemoteSnapshotVersion)
            }
            getHighestSequenceNumber(e) {
                return el.resolve(this.Lr)
            }
            allocateTargetId(e) {
                return this.highestTargetId = this.kr.next(),
                el.resolve(this.highestTargetId)
            }
            setTargetsMetadata(e, t, n) {
                return n && (this.lastRemoteSnapshotVersion = n),
                t > this.Lr && (this.Lr = t),
                el.resolve()
            }
            Kn(e) {
                this.Nr.set(e.target, e);
                let t = e.targetId;
                t > this.highestTargetId && (this.kr = new iC(t),
                this.highestTargetId = t),
                e.sequenceNumber > this.Lr && (this.Lr = e.sequenceNumber)
            }
            addTargetData(e, t) {
                return this.Kn(t),
                this.targetCount += 1,
                el.resolve()
            }
            updateTargetData(e, t) {
                return this.Kn(t),
                el.resolve()
            }
            removeTargetData(e, t) {
                return this.Nr.delete(t.target),
                this.Br.gr(t.targetId),
                this.targetCount -= 1,
                el.resolve()
            }
            removeTargets(e, t, n) {
                let r = 0
                  , i = [];
                return this.Nr.forEach( (s, a) => {
                    a.sequenceNumber <= t && null === n.get(a.targetId) && (this.Nr.delete(s),
                    i.push(this.removeMatchingKeysForTargetId(e, a.targetId)),
                    r++)
                }
                ),
                el.waitFor(i).next( () => r)
            }
            getTargetCount(e) {
                return el.resolve(this.targetCount)
            }
            getTargetData(e, t) {
                let n = this.Nr.get(t) || null;
                return el.resolve(n)
            }
            addMatchingKeys(e, t, n) {
                return this.Br.Rr(t, n),
                el.resolve()
            }
            removeMatchingKeys(e, t, n) {
                this.Br.mr(t, n);
                let r = this.persistence.referenceDelegate
                  , i = [];
                return r && t.forEach(t => {
                    i.push(r.markPotentiallyOrphaned(e, t))
                }
                ),
                el.waitFor(i)
            }
            removeMatchingKeysForTargetId(e, t) {
                return this.Br.gr(t),
                el.resolve()
            }
            getMatchingKeysForTargetId(e, t) {
                let n = this.Br.yr(t);
                return el.resolve(n)
            }
            containsKey(e, t) {
                return el.resolve(this.Br.containsKey(t))
            }
        }
        class i4 {
            constructor(e, t) {
                this.qr = {},
                this.overlays = {},
                this.Qr = new eI(0),
                this.Kr = !1,
                this.Kr = !0,
                this.$r = new iY,
                this.referenceDelegate = e(this),
                this.Ur = new i5(this),
                this.indexManager = new iu,
                this.remoteDocumentCache = new i1(e => this.referenceDelegate.Wr(e)),
                this.serializer = new rP(t),
                this.Gr = new iJ(this.serializer)
            }
            start() {
                return Promise.resolve()
            }
            shutdown() {
                return this.Kr = !1,
                Promise.resolve()
            }
            get started() {
                return this.Kr
            }
            setDatabaseDeletedListener() {}
            setNetworkEnabled() {}
            getIndexManager(e) {
                return this.indexManager
            }
            getDocumentOverlayCache(e) {
                let t = this.overlays[e.toKey()];
                return t || (t = new iH,
                this.overlays[e.toKey()] = t),
                t
            }
            getMutationQueue(e, t) {
                let n = this.qr[e.toKey()];
                return n || (n = new i0(t,this.referenceDelegate),
                this.qr[e.toKey()] = n),
                n
            }
            getGlobalsCache() {
                return this.$r
            }
            getTargetCache() {
                return this.Ur
            }
            getRemoteDocumentCache() {
                return this.remoteDocumentCache
            }
            getBundleCache() {
                return this.Gr
            }
            runTransaction(e, t, n) {
                I("MemoryPersistence", "Starting transaction:", e);
                let r = new i8(this.Qr.next());
                return this.referenceDelegate.zr(),
                n(r).next(e => this.referenceDelegate.jr(r).next( () => e)).toPromise().then(e => (r.raiseOnCommittedEvent(),
                e))
            }
            Hr(e, t) {
                return el.or(Object.values(this.qr).map(n => () => n.containsKey(e, t)))
            }
        }
        class i8 extends ea {
            constructor(e) {
                super(),
                this.currentSequenceNumber = e
            }
        }
        class i3 {
            constructor(e) {
                this.persistence = e,
                this.Jr = new iX,
                this.Yr = null
            }
            static Zr(e) {
                return new i3(e)
            }
            get Xr() {
                if (this.Yr)
                    return this.Yr;
                throw S()
            }
            addReference(e, t, n) {
                return this.Jr.addReference(n, t),
                this.Xr.delete(n.toString()),
                el.resolve()
            }
            removeReference(e, t, n) {
                return this.Jr.removeReference(n, t),
                this.Xr.add(n.toString()),
                el.resolve()
            }
            markPotentiallyOrphaned(e, t) {
                return this.Xr.add(t.toString()),
                el.resolve()
            }
            removeTarget(e, t) {
                this.Jr.gr(t.targetId).forEach(e => this.Xr.add(e.toString()));
                let n = this.persistence.getTargetCache();
                return n.getMatchingKeysForTargetId(e, t.targetId).next(e => {
                    e.forEach(e => this.Xr.add(e.toString()))
                }
                ).next( () => n.removeTargetData(e, t))
            }
            zr() {
                this.Yr = new Set
            }
            jr(e) {
                let t = this.persistence.getRemoteDocumentCache().newChangeBuffer();
                return el.forEach(this.Xr, n => {
                    let r = W.fromPath(n);
                    return this.ei(e, r).next(e => {
                        e || t.removeEntry(r, K.min())
                    }
                    )
                }
                ).next( () => (this.Yr = null,
                t.apply(e)))
            }
            updateLimboDocument(e, t) {
                return this.ei(e, t).next(e => {
                    e ? this.Xr.delete(t.toString()) : this.Xr.add(t.toString())
                }
                )
            }
            Wr(e) {
                return 0
            }
            ei(e, t) {
                return el.or([ () => el.resolve(this.Jr.containsKey(t)), () => this.persistence.getTargetCache().containsKey(e, t), () => this.persistence.Hr(e, t)])
            }
        }
        class i6 {
            constructor(e, t) {
                this.persistence = e,
                this.ti = new nd(e => eS(e.path), (e, t) => e.isEqual(t)),
                this.garbageCollector = new iO(this,t)
            }
            static Zr(e, t) {
                return new i6(e,t)
            }
            zr() {}
            jr(e) {
                return el.resolve()
            }
            forEachTarget(e, t) {
                return this.persistence.getTargetCache().forEachTarget(e, t)
            }
            Yn(e) {
                let t = this.er(e);
                return this.persistence.getTargetCache().getTargetCount(e).next(e => t.next(t => e + t))
            }
            er(e) {
                let t = 0;
                return this.Zn(e, e => {
                    t++
                }
                ).next( () => t)
            }
            Zn(e, t) {
                return el.forEach(this.ti, (n, r) => this.nr(e, n, r).next(e => e ? el.resolve() : t(r)))
            }
            removeTargets(e, t, n) {
                return this.persistence.getTargetCache().removeTargets(e, t, n)
            }
            removeOrphanedDocuments(e, t) {
                let n = 0
                  , r = this.persistence.getRemoteDocumentCache()
                  , i = r.newChangeBuffer();
                return r.Or(e, r => this.nr(e, r, t).next(e => {
                    e || (n++,
                    i.removeEntry(r, K.min()))
                }
                )).next( () => i.apply(e)).next( () => n)
            }
            markPotentiallyOrphaned(e, t) {
                return this.ti.set(t, e.currentSequenceNumber),
                el.resolve()
            }
            removeTarget(e, t) {
                let n = t.withSequenceNumber(e.currentSequenceNumber);
                return this.persistence.getTargetCache().updateTargetData(e, n)
            }
            addReference(e, t, n) {
                return this.ti.set(n, e.currentSequenceNumber),
                el.resolve()
            }
            removeReference(e, t, n) {
                return this.ti.set(n, e.currentSequenceNumber),
                el.resolve()
            }
            updateLimboDocument(e, t) {
                return this.ti.set(t, e.currentSequenceNumber),
                el.resolve()
            }
            Wr(e) {
                let t = e.key.toString().length;
                return e.isFoundDocument() && (t += function e(t) {
                    switch (th(t)) {
                    case 0:
                    case 1:
                        return 4;
                    case 2:
                        return 8;
                    case 3:
                    case 8:
                        return 16;
                    case 4:
                        let n = ts(t);
                        return n ? 16 + e(n) : 16;
                    case 5:
                        return 2 * t.stringValue.length;
                    case 6:
                        return tr(t.bytesValue).approximateByteSize();
                    case 7:
                        return t.referenceValue.length;
                    case 9:
                        return (t.arrayValue.values || []).reduce( (t, n) => t + e(n), 0);
                    case 10:
                    case 11:
                        var r;
                        let i;
                        return r = t.mapValue,
                        i = 0,
                        eY(r.fields, (t, n) => {
                            i += t.length + e(n)
                        }
                        ),
                        i;
                    default:
                        throw S()
                    }
                }(e.data.value)),
                t
            }
            nr(e, t, n) {
                return el.or([ () => this.persistence.Hr(e, t), () => this.persistence.getTargetCache().containsKey(e, t), () => {
                    let e = this.ti.get(t);
                    return el.resolve(void 0 !== e && e > n)
                }
                ])
            }
            getCacheSize(e) {
                return this.persistence.getRemoteDocumentCache().getSize(e)
            }
        }
        class i9 {
            constructor(e) {
                this.serializer = e
            }
            O(e, t, n, r) {
                let i = new eu("createOrUpgrade",t);
                n < 1 && r >= 1 && (!function(e) {
                    e.createObjectStore("owner")
                }(e),
                e.createObjectStore("mutationQueues", {
                    keyPath: "userId"
                }),
                e.createObjectStore("mutations", {
                    keyPath: "batchId",
                    autoIncrement: !0
                }).createIndex("userMutationsIndex", eD, {
                    unique: !0
                }),
                e.createObjectStore("documentMutations"),
                i7(e),
                function(e) {
                    e.createObjectStore("remoteDocuments")
                }(e));
                let s = el.resolve();
                return n < 3 && r >= 3 && (0 !== n && (e.deleteObjectStore("targetDocuments"),
                e.deleteObjectStore("targets"),
                e.deleteObjectStore("targetGlobal"),
                i7(e)),
                s = s.next( () => (function(e) {
                    let t = e.store("targetGlobal")
                      , n = {
                        highestTargetId: 0,
                        highestListenSequenceNumber: 0,
                        lastRemoteSnapshotVersion: K.min().toTimestamp(),
                        targetCount: 0
                    };
                    return t.put("targetGlobalKey", n)
                }
                )(i))),
                n < 4 && r >= 4 && (0 !== n && (s = s.next( () => i.store("mutations").U().next(t => {
                    e.deleteObjectStore("mutations"),
                    e.createObjectStore("mutations", {
                        keyPath: "batchId",
                        autoIncrement: !0
                    }).createIndex("userMutationsIndex", eD, {
                        unique: !0
                    });
                    let n = i.store("mutations")
                      , r = t.map(e => n.put(e));
                    return el.waitFor(r)
                }
                ))),
                s = s.next( () => {
                    !function(e) {
                        e.createObjectStore("clientMetadata", {
                            keyPath: "clientId"
                        })
                    }(e)
                }
                )),
                n < 5 && r >= 5 && (s = s.next( () => this.ni(i))),
                n < 6 && r >= 6 && (s = s.next( () => ((function(e) {
                    e.createObjectStore("remoteDocumentGlobal")
                }
                )(e),
                this.ri(i)))),
                n < 7 && r >= 7 && (s = s.next( () => this.ii(i))),
                n < 8 && r >= 8 && (s = s.next( () => this.si(e, i))),
                n < 9 && r >= 9 && (s = s.next( () => {
                    e.objectStoreNames.contains("remoteDocumentChanges") && e.deleteObjectStore("remoteDocumentChanges")
                }
                )),
                n < 10 && r >= 10 && (s = s.next( () => this.oi(i))),
                n < 11 && r >= 11 && (s = s.next( () => {
                    (function(e) {
                        e.createObjectStore("bundles", {
                            keyPath: "bundleId"
                        })
                    }
                    )(e),
                    function(e) {
                        e.createObjectStore("namedQueries", {
                            keyPath: "name"
                        })
                    }(e)
                }
                )),
                n < 12 && r >= 12 && (s = s.next( () => {
                    !function(e) {
                        let t = e.createObjectStore("documentOverlays", {
                            keyPath: eU
                        });
                        t.createIndex("collectionPathOverlayIndex", eB, {
                            unique: !1
                        }),
                        t.createIndex("collectionGroupOverlayIndex", ez, {
                            unique: !1
                        })
                    }(e)
                }
                )),
                n < 13 && r >= 13 && (s = s.next( () => (function(e) {
                    let t = e.createObjectStore("remoteDocumentsV14", {
                        keyPath: eN
                    });
                    t.createIndex("documentKeyIndex", ek),
                    t.createIndex("collectionGroupIndex", eA)
                }
                )(e)).next( () => this._i(e, i)).next( () => e.deleteObjectStore("remoteDocuments"))),
                n < 14 && r >= 14 && (s = s.next( () => this.ai(e, i))),
                n < 15 && r >= 15 && (s = s.next( () => {
                    e.createObjectStore("indexConfiguration", {
                        keyPath: "indexId",
                        autoIncrement: !0
                    }).createIndex("collectionGroupIndex", "collectionGroup", {
                        unique: !1
                    }),
                    e.createObjectStore("indexState", {
                        keyPath: eO
                    }).createIndex("sequenceNumberIndex", eL, {
                        unique: !1
                    }),
                    e.createObjectStore("indexEntries", {
                        keyPath: eP
                    }).createIndex("documentKeyIndex", eq, {
                        unique: !1
                    })
                }
                )),
                n < 16 && r >= 16 && (s = s.next( () => {
                    t.objectStore("indexState").clear()
                }
                ).next( () => {
                    t.objectStore("indexEntries").clear()
                }
                )),
                n < 17 && r >= 17 && (s = s.next( () => {
                    !function(e) {
                        e.createObjectStore("globals", {
                            keyPath: "name"
                        })
                    }(e)
                }
                )),
                s
            }
            ri(e) {
                let t = 0;
                return e.store("remoteDocuments").J( (e, n) => {
                    t += ib(n)
                }
                ).next( () => {
                    let n = {
                        byteSize: t
                    };
                    return e.store("remoteDocumentGlobal").put("remoteDocumentGlobalKey", n)
                }
                )
            }
            ni(e) {
                let t = e.store("mutationQueues")
                  , n = e.store("mutations");
                return t.U().next(t => el.forEach(t, t => {
                    let r = IDBKeyRange.bound([t.userId, -1], [t.userId, t.lastAcknowledgedBatchId]);
                    return n.U("userMutationsIndex", r).next(n => el.forEach(n, n => {
                        n.userId === t.userId || S();
                        let r = rK(this.serializer, n);
                        return iI(e, t.userId, r).next( () => {}
                        )
                    }
                    ))
                }
                ))
            }
            ii(e) {
                let t = e.store("targetDocuments")
                  , n = e.store("remoteDocuments");
                return e.store("targetGlobal").get("targetGlobalKey").next(e => {
                    let r = [];
                    return n.J( (n, i) => {
                        let s = new $(n)
                          , a = [0, eS(s)];
                        r.push(t.get(a).next(n => n ? el.resolve() : t.put({
                            targetId: 0,
                            path: eS(s),
                            sequenceNumber: e.highestListenSequenceNumber
                        })))
                    }
                    ).next( () => el.waitFor(r))
                }
                )
            }
            si(e, t) {
                e.createObjectStore("collectionParents", {
                    keyPath: eM
                });
                let n = t.store("collectionParents")
                  , r = new ic
                  , i = e => {
                    if (r.add(e)) {
                        let t = e.lastSegment()
                          , r = e.popLast();
                        return n.put({
                            collectionId: t,
                            parent: eS(r)
                        })
                    }
                }
                ;
                return t.store("remoteDocuments").J({
                    H: !0
                }, (e, t) => i(new $(e).popLast())).next( () => t.store("documentMutations").J({
                    H: !0
                }, ([e,t,n], r) => i(ex(t).popLast())))
            }
            oi(e) {
                let t = e.store("targets");
                return t.J( (e, n) => {
                    let r = rG(n)
                      , i = r$(this.serializer, r);
                    return t.put(i)
                }
                )
            }
            _i(e, t) {
                let n = t.store("remoteDocuments")
                  , r = [];
                return n.J( (e, n) => {
                    let i = t.store("remoteDocumentsV14")
                      , s = (n.document ? new W($.fromString(n.document.name).popFirst(5)) : n.noDocument ? W.fromSegments(n.noDocument.path) : n.unknownDocument ? W.fromSegments(n.unknownDocument.path) : S()).path.toArray()
                      , a = {
                        prefixPath: s.slice(0, s.length - 2),
                        collectionGroup: s[s.length - 2],
                        documentId: s[s.length - 1],
                        readTime: n.readTime || [0, 0],
                        unknownDocument: n.unknownDocument,
                        noDocument: n.noDocument,
                        document: n.document,
                        hasCommittedMutations: !!n.hasCommittedMutations
                    };
                    r.push(i.put(a))
                }
                ).next( () => el.waitFor(r))
            }
            ai(e, t) {
                let n = t.store("mutations")
                  , r = new iU(this.serializer)
                  , i = new i4(i3.Zr,this.serializer.ct);
                return n.U().next(e => {
                    let n = new Map;
                    return e.forEach(e => {
                        var t;
                        let r = null !== (t = n.get(e.userId)) && void 0 !== t ? t : n_();
                        rK(this.serializer, e).keys().forEach(e => r = r.add(e)),
                        n.set(e.userId, r)
                    }
                    ),
                    el.forEach(n, (e, n) => {
                        let s = new p(n)
                          , a = rZ.lt(this.serializer, s)
                          , o = i.getIndexManager(s);
                        return new iW(r,iT.lt(s, this.serializer, o, i.referenceDelegate),a,o).recalculateAndSaveOverlaysForDocumentKeys(new eW(t,eI.oe), e).next()
                    }
                    )
                }
                )
            }
        }
        function i7(e) {
            e.createObjectStore("targetDocuments", {
                keyPath: eF
            }).createIndex("documentTargetsIndex", eV, {
                unique: !0
            }),
            e.createObjectStore("targets", {
                keyPath: "targetId"
            }).createIndex("queryTargetsIndex", eR, {
                unique: !0
            }),
            e.createObjectStore("targetGlobal")
        }
        let se = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.";
        class st {
            constructor(e, t, n, r, i, s, a, o, l, u, c=17) {
                if (this.allowTabSynchronization = e,
                this.persistenceKey = t,
                this.clientId = n,
                this.ui = i,
                this.window = s,
                this.document = a,
                this.ci = l,
                this.li = u,
                this.hi = c,
                this.Qr = null,
                this.Kr = !1,
                this.isPrimary = !1,
                this.networkEnabled = !0,
                this.Pi = null,
                this.inForeground = !1,
                this.Ii = null,
                this.Ti = null,
                this.Ei = Number.NEGATIVE_INFINITY,
                this.di = e => Promise.resolve(),
                !st.D())
                    throw new C(D.UNIMPLEMENTED,"This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.");
                this.referenceDelegate = new iL(this,r),
                this.Ai = t + "main",
                this.serializer = new rP(o),
                this.Ri = new ec(this.Ai,this.hi,new i9(this.serializer)),
                this.$r = new r1,
                this.Ur = new iN(this.referenceDelegate,this.serializer),
                this.remoteDocumentCache = new iU(this.serializer),
                this.Gr = new rH,
                this.window && this.window.localStorage ? this.Vi = this.window.localStorage : (this.Vi = null,
                !1 === u && b("IndexedDbPersistence", "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page."))
            }
            start() {
                return this.mi().then( () => {
                    if (!this.isPrimary && !this.allowTabSynchronization)
                        throw new C(D.FAILED_PRECONDITION,se);
                    return this.fi(),
                    this.gi(),
                    this.pi(),
                    this.runTransaction("getHighestListenSequenceNumber", "readonly", e => this.Ur.getHighestSequenceNumber(e))
                }
                ).then(e => {
                    this.Qr = new eI(e,this.ci)
                }
                ).then( () => {
                    this.Kr = !0
                }
                ).catch(e => (this.Ri && this.Ri.close(),
                Promise.reject(e)))
            }
            yi(e) {
                return this.di = async t => {
                    if (this.started)
                        return e(t)
                }
                ,
                e(this.isPrimary)
            }
            setDatabaseDeletedListener(e) {
                this.Ri.L(async t => {
                    null === t.newVersion && await e()
                }
                )
            }
            setNetworkEnabled(e) {
                this.networkEnabled !== e && (this.networkEnabled = e,
                this.ui.enqueueAndForget(async () => {
                    this.started && await this.mi()
                }
                ))
            }
            mi() {
                return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", e => sr(e).put({
                    clientId: this.clientId,
                    updateTimeMs: Date.now(),
                    networkEnabled: this.networkEnabled,
                    inForeground: this.inForeground
                }).next( () => {
                    if (this.isPrimary)
                        return this.wi(e).next(e => {
                            e || (this.isPrimary = !1,
                            this.ui.enqueueRetryable( () => this.di(!1)))
                        }
                        )
                }
                ).next( () => this.Si(e)).next(t => this.isPrimary && !t ? this.bi(e).next( () => !1) : !!t && this.Di(e).next( () => !0))).catch(e => {
                    if (em(e))
                        return I("IndexedDbPersistence", "Failed to extend owner lease: ", e),
                        this.isPrimary;
                    if (!this.allowTabSynchronization)
                        throw e;
                    return I("IndexedDbPersistence", "Releasing owner lease after error during lease refresh", e),
                    !1
                }
                ).then(e => {
                    this.isPrimary !== e && this.ui.enqueueRetryable( () => this.di(e)),
                    this.isPrimary = e
                }
                )
            }
            wi(e) {
                return sn(e).get("owner").next(e => el.resolve(this.vi(e)))
            }
            Ci(e) {
                return sr(e).delete(this.clientId)
            }
            async Fi() {
                if (this.isPrimary && !this.Mi(this.Ei, 18e5)) {
                    this.Ei = Date.now();
                    let e = await this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", e => {
                        let t = eJ(e, "clientMetadata");
                        return t.U().next(e => {
                            let n = this.xi(e, 18e5)
                              , r = e.filter(e => -1 === n.indexOf(e));
                            return el.forEach(r, e => t.delete(e.clientId)).next( () => r)
                        }
                        )
                    }
                    ).catch( () => []);
                    if (this.Vi)
                        for (let t of e)
                            this.Vi.removeItem(this.Oi(t.clientId))
                }
            }
            pi() {
                this.Ti = this.ui.enqueueAfterDelay("client_metadata_refresh", 4e3, () => this.mi().then( () => this.Fi()).then( () => this.pi()))
            }
            vi(e) {
                return !!e && e.ownerId === this.clientId
            }
            Si(e) {
                return this.li ? el.resolve(!0) : sn(e).get("owner").next(t => {
                    if (null !== t && this.Mi(t.leaseTimestampMs, 5e3) && !this.Ni(t.ownerId)) {
                        if (this.vi(t) && this.networkEnabled)
                            return !0;
                        if (!this.vi(t)) {
                            if (!t.allowTabSynchronization)
                                throw new C(D.FAILED_PRECONDITION,se);
                            return !1
                        }
                    }
                    return !(!this.networkEnabled || !this.inForeground) || sr(e).U().next(e => void 0 === this.xi(e, 5e3).find(e => {
                        if (this.clientId !== e.clientId) {
                            let t = !this.networkEnabled && e.networkEnabled
                              , n = !this.inForeground && e.inForeground
                              , r = this.networkEnabled === e.networkEnabled;
                            if (t || n && r)
                                return !0
                        }
                        return !1
                    }
                    ))
                }
                ).next(e => (this.isPrimary !== e && I("IndexedDbPersistence", `Client ${e ? "is" : "is not"} eligible for a primary lease.`),
                e))
            }
            async shutdown() {
                this.Kr = !1,
                this.Li(),
                this.Ti && (this.Ti.cancel(),
                this.Ti = null),
                this.Bi(),
                this.ki(),
                await this.Ri.runTransaction("shutdown", "readwrite", ["owner", "clientMetadata"], e => {
                    let t = new eW(e,eI.oe);
                    return this.bi(t).next( () => this.Ci(t))
                }
                ),
                this.Ri.close(),
                this.qi()
            }
            xi(e, t) {
                return e.filter(e => this.Mi(e.updateTimeMs, t) && !this.Ni(e.clientId))
            }
            Qi() {
                return this.runTransaction("getActiveClients", "readonly", e => sr(e).U().next(e => this.xi(e, 18e5).map(e => e.clientId)))
            }
            get started() {
                return this.Kr
            }
            getGlobalsCache() {
                return this.$r
            }
            getMutationQueue(e, t) {
                return iT.lt(e, this.serializer, t, this.referenceDelegate)
            }
            getTargetCache() {
                return this.Ur
            }
            getRemoteDocumentCache() {
                return this.remoteDocumentCache
            }
            getIndexManager(e) {
                return new id(e,this.serializer.ct.databaseId)
            }
            getDocumentOverlayCache(e) {
                return rZ.lt(this.serializer, e)
            }
            getBundleCache() {
                return this.Gr
            }
            runTransaction(e, t, n) {
                var r;
                let i;
                I("IndexedDbPersistence", "Starting transaction:", e);
                let s = 17 === (r = this.hi) ? ej : 16 === r ? eQ : 15 === r ? eQ : 14 === r ? e$ : 13 === r ? e$ : 12 === r ? eG : 11 === r ? eK : void S();
                return this.Ri.runTransaction(e, "readonly" === t ? "readonly" : "readwrite", s, r => (i = new eW(r,this.Qr ? this.Qr.next() : eI.oe),
                "readwrite-primary" === t ? this.wi(i).next(e => !!e || this.Si(i)).next(t => {
                    if (!t)
                        throw b(`Failed to obtain primary lease for action '${e}'.`),
                        this.isPrimary = !1,
                        this.ui.enqueueRetryable( () => this.di(!1)),
                        new C(D.FAILED_PRECONDITION,es);
                    return n(i)
                }
                ).next(e => this.Di(i).next( () => e)) : this.Ki(i).next( () => n(i)))).then(e => (i.raiseOnCommittedEvent(),
                e))
            }
            Ki(e) {
                return sn(e).get("owner").next(e => {
                    if (null !== e && this.Mi(e.leaseTimestampMs, 5e3) && !this.Ni(e.ownerId) && !this.vi(e) && !(this.li || this.allowTabSynchronization && e.allowTabSynchronization))
                        throw new C(D.FAILED_PRECONDITION,se)
                }
                )
            }
            Di(e) {
                let t = {
                    ownerId: this.clientId,
                    allowTabSynchronization: this.allowTabSynchronization,
                    leaseTimestampMs: Date.now()
                };
                return sn(e).put("owner", t)
            }
            static D() {
                return ec.D()
            }
            bi(e) {
                let t = sn(e);
                return t.get("owner").next(e => this.vi(e) ? (I("IndexedDbPersistence", "Releasing primary lease."),
                t.delete("owner")) : el.resolve())
            }
            Mi(e, t) {
                let n = Date.now();
                return !(e < n - t) && (!(e > n) || (b(`Detected an update time that is in the future: ${e} > ${n}`),
                !1))
            }
            fi() {
                null !== this.document && "function" == typeof this.document.addEventListener && (this.Ii = () => {
                    this.ui.enqueueAndForget( () => (this.inForeground = "visible" === this.document.visibilityState,
                    this.mi()))
                }
                ,
                this.document.addEventListener("visibilitychange", this.Ii),
                this.inForeground = "visible" === this.document.visibilityState)
            }
            Bi() {
                this.Ii && (this.document.removeEventListener("visibilitychange", this.Ii),
                this.Ii = null)
            }
            gi() {
                var e;
                "function" == typeof (null === (e = this.window) || void 0 === e ? void 0 : e.addEventListener) && (this.Pi = () => {
                    this.Li();
                    let e = /(?:Version|Mobile)\/1[456]/;
                    (0,
                    c.G6)() && (navigator.appVersion.match(e) || navigator.userAgent.match(e)) && this.ui.enterRestrictedMode(!0),
                    this.ui.enqueueAndForget( () => this.shutdown())
                }
                ,
                this.window.addEventListener("pagehide", this.Pi))
            }
            ki() {
                this.Pi && (this.window.removeEventListener("pagehide", this.Pi),
                this.Pi = null)
            }
            Ni(e) {
                var t;
                try {
                    let n = null !== (null === (t = this.Vi) || void 0 === t ? void 0 : t.getItem(this.Oi(e)));
                    return I("IndexedDbPersistence", `Client '${e}' ${n ? "is" : "is not"} zombied in LocalStorage`),
                    n
                } catch (e) {
                    return b("IndexedDbPersistence", "Failed to get zombied client id.", e),
                    !1
                }
            }
            Li() {
                if (this.Vi)
                    try {
                        this.Vi.setItem(this.Oi(this.clientId), String(Date.now()))
                    } catch (e) {
                        b("Failed to set zombie client id.", e)
                    }
            }
            qi() {
                if (this.Vi)
                    try {
                        this.Vi.removeItem(this.Oi(this.clientId))
                    } catch (e) {}
            }
            Oi(e) {
                return `firestore_zombie_${this.persistenceKey}_${e}`
            }
        }
        function sn(e) {
            return eJ(e, "owner")
        }
        function sr(e) {
            return eJ(e, "clientMetadata")
        }
        function si(e, t) {
            let n = e.projectId;
            return e.isDefaultDatabase || (n += "." + e.database),
            "firestore/" + t + "/" + n + "/"
        }
        class ss {
            constructor(e, t, n, r) {
                this.targetId = e,
                this.fromCache = t,
                this.$i = n,
                this.Ui = r
            }
            static Wi(e, t) {
                let n = n_()
                  , r = n_();
                for (let e of t.docChanges)
                    switch (e.type) {
                    case 0:
                        n = n.add(e.doc.key);
                        break;
                    case 1:
                        r = r.add(e.doc.key)
                    }
                return new ss(e,t.fromCache,n,r)
            }
        }
        class sa {
            constructor() {
                this._documentReadCount = 0
            }
            get documentReadCount() {
                return this._documentReadCount
            }
            incrementDocumentReadCount(e) {
                this._documentReadCount += e
            }
        }
        class so {
            constructor() {
                this.Gi = !1,
                this.zi = !1,
                this.ji = 100,
                this.Hi = (0,
                c.G6)() ? 8 : eh((0,
                c.z$)()) > 0 ? 6 : 4
            }
            initialize(e, t) {
                this.Ji = e,
                this.indexManager = t,
                this.Gi = !0
            }
            getDocumentsMatchingQuery(e, t, n, r) {
                let i = {
                    result: null
                };
                return this.Yi(e, t).next(e => {
                    i.result = e
                }
                ).next( () => {
                    if (!i.result)
                        return this.Zi(e, t, r, n).next(e => {
                            i.result = e
                        }
                        )
                }
                ).next( () => {
                    if (i.result)
                        return;
                    let n = new sa;
                    return this.Xi(e, t, n).next(r => {
                        if (i.result = r,
                        this.zi)
                            return this.es(e, t, n, r.size)
                    }
                    )
                }
                ).next( () => i.result)
            }
            es(e, t, n, r) {
                return n.documentReadCount < this.ji ? (v() <= u.in.DEBUG && I("QueryEngine", "SDK will not create cache indexes for query:", nl(t), "since it only creates cache indexes for collection contains", "more than or equal to", this.ji, "documents"),
                el.resolve()) : (v() <= u.in.DEBUG && I("QueryEngine", "Query:", nl(t), "scans", n.documentReadCount, "local documents and returns", r, "documents as results."),
                n.documentReadCount > this.Hi * r ? (v() <= u.in.DEBUG && I("QueryEngine", "The SDK decides to create cache indexes for query:", nl(t), "as using cache indexes may help improve performance."),
                this.indexManager.createTargetIndexes(e, nt(t))) : el.resolve())
            }
            Yi(e, t) {
                if (t9(t))
                    return el.resolve(null);
                let n = nt(t);
                return this.indexManager.getIndexType(e, n).next(r => 0 === r ? null : (null !== t.limit && 1 === r && (n = nt(t = ns(t, null, "F"))),
                this.indexManager.getDocumentsMatchingTarget(e, n).next(r => {
                    let i = n_(...r);
                    return this.Ji.getDocuments(e, i).next(r => this.indexManager.getMinOffset(e, n).next(n => {
                        let s = this.ts(t, r);
                        return this.ns(t, s, i, n.readTime) ? this.Yi(e, ns(t, null, "F")) : this.rs(e, s, t, n)
                    }
                    ))
                }
                )))
            }
            Zi(e, t, n, r) {
                return t9(t) || r.isEqual(K.min()) ? el.resolve(null) : this.Ji.getDocuments(e, n).next(i => {
                    let s = this.ts(t, i);
                    return this.ns(t, s, n, r) ? el.resolve(null) : (v() <= u.in.DEBUG && I("QueryEngine", "Re-using previous result from %s to execute query: %s", r.toString(), nl(t)),
                    this.rs(e, s, t, et(r, -1)).next(e => e))
                }
                )
            }
            ts(e, t) {
                let n = new e5(nh(e));
                return t.forEach( (t, r) => {
                    nu(e, r) && (n = n.add(r))
                }
                ),
                n
            }
            ns(e, t, n, r) {
                if (null === e.limit)
                    return !1;
                if (n.size !== t.size)
                    return !0;
                let i = "F" === e.limitType ? t.last() : t.first();
                return !!i && (i.hasPendingWrites || i.version.compareTo(r) > 0)
            }
            Xi(e, t, n) {
                return v() <= u.in.DEBUG && I("QueryEngine", "Using full collection scan to execute query:", nl(t)),
                this.Ji.getDocumentsMatchingQuery(e, t, er.min(), n)
            }
            rs(e, t, n, r) {
                return this.Ji.getDocumentsMatchingQuery(e, n, r).next(e => (t.forEach(t => {
                    e = e.insert(t.key, t)
                }
                ),
                e))
            }
        }
        class sl {
            constructor(e, t, n, r) {
                this.persistence = e,
                this.ss = t,
                this.serializer = r,
                this.os = new e0(U),
                this._s = new nd(e => t0(e),t1),
                this.us = new Map,
                this.cs = e.getRemoteDocumentCache(),
                this.Ur = e.getTargetCache(),
                this.Gr = e.getBundleCache(),
                this.ls(n)
            }
            ls(e) {
                this.documentOverlayCache = this.persistence.getDocumentOverlayCache(e),
                this.indexManager = this.persistence.getIndexManager(e),
                this.mutationQueue = this.persistence.getMutationQueue(e, this.indexManager),
                this.localDocuments = new iW(this.cs,this.mutationQueue,this.documentOverlayCache,this.indexManager),
                this.cs.setIndexManager(this.indexManager),
                this.ss.initialize(this.localDocuments, this.indexManager)
            }
            collectGarbage(e) {
                return this.persistence.runTransaction("Collect garbage", "readwrite-primary", t => e.collect(t, this.os))
            }
        }
        async function su(e, t) {
            return await e.persistence.runTransaction("Handle user change", "readonly", n => {
                let r;
                return e.mutationQueue.getAllMutationBatches(n).next(i => (r = i,
                e.ls(t),
                e.mutationQueue.getAllMutationBatches(n))).next(t => {
                    let i = []
                      , s = []
                      , a = n_();
                    for (let e of r)
                        for (let t of (i.push(e.batchId),
                        e.mutations))
                            a = a.add(t.key);
                    for (let e of t)
                        for (let t of (s.push(e.batchId),
                        e.mutations))
                            a = a.add(t.key);
                    return e.localDocuments.getDocuments(n, a).next(e => ({
                        hs: e,
                        removedBatchIds: i,
                        addedBatchIds: s
                    }))
                }
                )
            }
            )
        }
        function sc(e) {
            return e.persistence.runTransaction("Get last remote snapshot version", "readonly", t => e.Ur.getLastRemoteSnapshotVersion(t))
        }
        function sh(e, t, n) {
            let r = n_()
              , i = n_();
            return n.forEach(e => r = r.add(e)),
            t.getEntries(e, r).next(e => {
                let r = nf;
                return n.forEach( (n, s) => {
                    let a = e.get(n);
                    s.isFoundDocument() !== a.isFoundDocument() && (i = i.add(n)),
                    s.isNoDocument() && s.version.isEqual(K.min()) ? (t.removeEntry(n, s.readTime),
                    r = r.insert(n, s)) : !a.isValidDocument() || s.version.compareTo(a.version) > 0 || 0 === s.version.compareTo(a.version) && a.hasPendingWrites ? (t.addEntry(s),
                    r = r.insert(n, s)) : I("LocalStore", "Ignoring outdated watch update for ", n, ". Current version:", a.version, " Watch version:", s.version)
                }
                ),
                {
                    Ps: r,
                    Is: i
                }
            }
            )
        }
        function sd(e, t) {
            return e.persistence.runTransaction("Allocate target", "readwrite", n => {
                let r;
                return e.Ur.getTargetData(n, t).next(i => i ? (r = i,
                el.resolve(r)) : e.Ur.allocateTargetId(n).next(i => (r = new rL(t,i,"TargetPurposeListen",n.currentSequenceNumber),
                e.Ur.addTargetData(n, r).next( () => r))))
            }
            ).then(n => {
                let r = e.os.get(n.targetId);
                return (null === r || n.snapshotVersion.compareTo(r.snapshotVersion) > 0) && (e.os = e.os.insert(n.targetId, n),
                e._s.set(t, n.targetId)),
                n
            }
            )
        }
        async function sf(e, t, n) {
            let r = e.os.get(t);
            try {
                n || await e.persistence.runTransaction("Release target", n ? "readwrite" : "readwrite-primary", t => e.persistence.referenceDelegate.removeTarget(t, r))
            } catch (e) {
                if (!em(e))
                    throw e;
                I("LocalStore", `Failed to update sequence numbers for target ${t}: ${e}`)
            }
            e.os = e.os.remove(t),
            e._s.delete(r.target)
        }
        function sm(e, t, n) {
            let r = K.min()
              , i = n_();
            return e.persistence.runTransaction("Execute query", "readwrite", s => (function(e, t, n) {
                let r = e._s.get(n);
                return void 0 !== r ? el.resolve(e.os.get(r)) : e.Ur.getTargetData(t, n)
            }
            )(e, s, nt(t)).next(t => {
                if (t)
                    return r = t.lastLimboFreeSnapshotVersion,
                    e.Ur.getMatchingKeysForTargetId(s, t.targetId).next(e => {
                        i = e
                    }
                    )
            }
            ).next( () => e.ss.getDocumentsMatchingQuery(s, t, n ? r : K.min(), n ? i : n_())).next(n => (sy(e, nc(t), n),
            {
                documents: n,
                Ts: i
            })))
        }
        function sg(e, t) {
            let n = e.Ur
              , r = e.os.get(t);
            return r ? Promise.resolve(r.target) : e.persistence.runTransaction("Get target data", "readonly", e => n.ot(e, t).next(e => e ? e.target : null))
        }
        function sp(e, t) {
            let n = e.us.get(t) || K.min();
            return e.persistence.runTransaction("Get new document changes", "readonly", r => e.cs.getAllFromCollectionGroup(r, t, et(n, -1), Number.MAX_SAFE_INTEGER)).then(n => (sy(e, t, n),
            n))
        }
        function sy(e, t, n) {
            let r = e.us.get(t) || K.min();
            n.forEach( (e, t) => {
                t.readTime.compareTo(r) > 0 && (r = t.readTime)
            }
            ),
            e.us.set(t, r)
        }
        async function sw(e, t, n, r) {
            let i = n_()
              , s = nf;
            for (let e of n) {
                let n = t.Es(e.metadata.name);
                e.document && (i = i.add(n));
                let r = t.ds(e);
                r.setReadTime(t.As(e.metadata.readTime)),
                s = s.insert(n, r)
            }
            let a = e.cs.newChangeBuffer({
                trackRemovals: !0
            })
              , o = await sd(e, nt(t6($.fromString(`__bundle__/docs/${r}`))));
            return e.persistence.runTransaction("Apply bundle documents", "readwrite", t => sh(t, a, s).next(e => (a.apply(t),
            e)).next(n => e.Ur.removeMatchingKeysForTargetId(t, o.targetId).next( () => e.Ur.addMatchingKeys(t, i, o.targetId)).next( () => e.localDocuments.getLocalViewOfDocuments(t, n.Ps, n.Is)).next( () => n.Ps)))
        }
        async function sv(e, t, n=n_()) {
            let r = await sd(e, nt(rQ(t.bundledQuery)));
            return e.persistence.runTransaction("Save named query", "readwrite", i => {
                let s = rp(t.readTime);
                if (r.snapshotVersion.compareTo(s) >= 0)
                    return e.Gr.saveNamedQuery(i, t);
                let a = r.withResumeToken(e7.EMPTY_BYTE_STRING, s);
                return e.os = e.os.insert(a.targetId, a),
                e.Ur.updateTargetData(i, a).next( () => e.Ur.removeMatchingKeysForTargetId(i, r.targetId)).next( () => e.Ur.addMatchingKeys(i, n, r.targetId)).next( () => e.Gr.saveNamedQuery(i, t))
            }
            )
        }
        function s_(e, t) {
            return `firestore_clients_${e}_${t}`
        }
        function sI(e, t, n) {
            let r = `firestore_mutations_${e}_${n}`;
            return t.isAuthenticated() && (r += `_${t.uid}`),
            r
        }
        function sb(e, t) {
            return `firestore_targets_${e}_${t}`
        }
        class sT {
            constructor(e, t, n, r) {
                this.user = e,
                this.batchId = t,
                this.state = n,
                this.error = r
            }
            static Rs(e, t, n) {
                let r = JSON.parse(n), i, s = "object" == typeof r && -1 !== ["pending", "acknowledged", "rejected"].indexOf(r.state) && (void 0 === r.error || "object" == typeof r.error);
                return s && r.error && (s = "string" == typeof r.error.message && "string" == typeof r.error.code) && (i = new C(r.error.code,r.error.message)),
                s ? new sT(e,t,r.state,i) : (b("SharedClientState", `Failed to parse mutation state for ID '${t}': ${n}`),
                null)
            }
            Vs() {
                let e = {
                    state: this.state,
                    updateTimeMs: Date.now()
                };
                return this.error && (e.error = {
                    code: this.error.code,
                    message: this.error.message
                }),
                JSON.stringify(e)
            }
        }
        class sE {
            constructor(e, t, n) {
                this.targetId = e,
                this.state = t,
                this.error = n
            }
            static Rs(e, t) {
                let n = JSON.parse(t), r, i = "object" == typeof n && -1 !== ["not-current", "current", "rejected"].indexOf(n.state) && (void 0 === n.error || "object" == typeof n.error);
                return i && n.error && (i = "string" == typeof n.error.message && "string" == typeof n.error.code) && (r = new C(n.error.code,n.error.message)),
                i ? new sE(e,n.state,r) : (b("SharedClientState", `Failed to parse target state for ID '${e}': ${t}`),
                null)
            }
            Vs() {
                let e = {
                    state: this.state,
                    updateTimeMs: Date.now()
                };
                return this.error && (e.error = {
                    code: this.error.code,
                    message: this.error.message
                }),
                JSON.stringify(e)
            }
        }
        class sS {
            constructor(e, t) {
                this.clientId = e,
                this.activeTargetIds = t
            }
            static Rs(e, t) {
                let n = JSON.parse(t)
                  , r = "object" == typeof n && n.activeTargetIds instanceof Array
                  , i = nI;
                for (let e = 0; r && e < n.activeTargetIds.length; ++e)
                    r = eE(n.activeTargetIds[e]),
                    i = i.add(n.activeTargetIds[e]);
                return r ? new sS(e,i) : (b("SharedClientState", `Failed to parse client data for instance '${e}': ${t}`),
                null)
            }
        }
        class sx {
            constructor(e, t) {
                this.clientId = e,
                this.onlineState = t
            }
            static Rs(e) {
                let t = JSON.parse(e);
                return "object" == typeof t && -1 !== ["Unknown", "Online", "Offline"].indexOf(t.onlineState) && "string" == typeof t.clientId ? new sx(t.clientId,t.onlineState) : (b("SharedClientState", `Failed to parse online state: ${e}`),
                null)
            }
        }
        class sD {
            constructor() {
                this.activeTargetIds = nI
            }
            fs(e) {
                this.activeTargetIds = this.activeTargetIds.add(e)
            }
            gs(e) {
                this.activeTargetIds = this.activeTargetIds.delete(e)
            }
            Vs() {
                return JSON.stringify({
                    activeTargetIds: this.activeTargetIds.toArray(),
                    updateTimeMs: Date.now()
                })
            }
        }
        class sC {
            constructor(e, t, n, r, i) {
                var s, a, o;
                this.window = e,
                this.ui = t,
                this.persistenceKey = n,
                this.ps = r,
                this.syncEngine = null,
                this.onlineStateHandler = null,
                this.sequenceNumberHandler = null,
                this.ys = this.ws.bind(this),
                this.Ss = new e0(U),
                this.started = !1,
                this.bs = [];
                let l = n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
                this.storage = this.window.localStorage,
                this.currentUser = i,
                this.Ds = s_(this.persistenceKey, this.ps),
                this.vs = (s = this.persistenceKey,
                `firestore_sequence_number_${s}`),
                this.Ss = this.Ss.insert(this.ps, new sD),
                this.Cs = RegExp(`^firestore_clients_${l}_([^_]*)$`),
                this.Fs = RegExp(`^firestore_mutations_${l}_(\\d+)(?:_(.*))?$`),
                this.Ms = RegExp(`^firestore_targets_${l}_(\\d+)$`),
                this.xs = (a = this.persistenceKey,
                `firestore_online_state_${a}`),
                this.Os = (o = this.persistenceKey,
                `firestore_bundle_loaded_v2_${o}`),
                this.window.addEventListener("storage", this.ys)
            }
            static D(e) {
                return !(!e || !e.localStorage)
            }
            async start() {
                for (let e of (await this.syncEngine.Qi())) {
                    if (e === this.ps)
                        continue;
                    let t = this.getItem(s_(this.persistenceKey, e));
                    if (t) {
                        let n = sS.Rs(e, t);
                        n && (this.Ss = this.Ss.insert(n.clientId, n))
                    }
                }
                this.Ns();
                let e = this.storage.getItem(this.xs);
                if (e) {
                    let t = this.Ls(e);
                    t && this.Bs(t)
                }
                for (let e of this.bs)
                    this.ws(e);
                this.bs = [],
                this.window.addEventListener("pagehide", () => this.shutdown()),
                this.started = !0
            }
            writeSequenceNumber(e) {
                this.setItem(this.vs, JSON.stringify(e))
            }
            getAllActiveQueryTargets() {
                return this.ks(this.Ss)
            }
            isActiveQueryTarget(e) {
                let t = !1;
                return this.Ss.forEach( (n, r) => {
                    r.activeTargetIds.has(e) && (t = !0)
                }
                ),
                t
            }
            addPendingMutation(e) {
                this.qs(e, "pending")
            }
            updateMutationState(e, t, n) {
                this.qs(e, t, n),
                this.Qs(e)
            }
            addLocalQueryTarget(e, t=!0) {
                let n = "not-current";
                if (this.isActiveQueryTarget(e)) {
                    let t = this.storage.getItem(sb(this.persistenceKey, e));
                    if (t) {
                        let r = sE.Rs(e, t);
                        r && (n = r.state)
                    }
                }
                return t && this.Ks.fs(e),
                this.Ns(),
                n
            }
            removeLocalQueryTarget(e) {
                this.Ks.gs(e),
                this.Ns()
            }
            isLocalQueryTarget(e) {
                return this.Ks.activeTargetIds.has(e)
            }
            clearQueryState(e) {
                this.removeItem(sb(this.persistenceKey, e))
            }
            updateQueryState(e, t, n) {
                this.$s(e, t, n)
            }
            handleUserChange(e, t, n) {
                t.forEach(e => {
                    this.Qs(e)
                }
                ),
                this.currentUser = e,
                n.forEach(e => {
                    this.addPendingMutation(e)
                }
                )
            }
            setOnlineState(e) {
                this.Us(e)
            }
            notifyBundleLoaded(e) {
                this.Ws(e)
            }
            shutdown() {
                this.started && (this.window.removeEventListener("storage", this.ys),
                this.removeItem(this.Ds),
                this.started = !1)
            }
            getItem(e) {
                let t = this.storage.getItem(e);
                return I("SharedClientState", "READ", e, t),
                t
            }
            setItem(e, t) {
                I("SharedClientState", "SET", e, t),
                this.storage.setItem(e, t)
            }
            removeItem(e) {
                I("SharedClientState", "REMOVE", e),
                this.storage.removeItem(e)
            }
            ws(e) {
                if (e.storageArea === this.storage) {
                    if (I("SharedClientState", "EVENT", e.key, e.newValue),
                    e.key === this.Ds)
                        return void b("Received WebStorage notification for local change. Another client might have garbage-collected our state");
                    this.ui.enqueueRetryable(async () => {
                        if (this.started) {
                            if (null !== e.key) {
                                if (this.Cs.test(e.key)) {
                                    if (null == e.newValue) {
                                        let t = this.Gs(e.key);
                                        return this.zs(t, null)
                                    }
                                    {
                                        let t = this.js(e.key, e.newValue);
                                        if (t)
                                            return this.zs(t.clientId, t)
                                    }
                                } else if (this.Fs.test(e.key)) {
                                    if (null !== e.newValue) {
                                        let t = this.Hs(e.key, e.newValue);
                                        if (t)
                                            return this.Js(t)
                                    }
                                } else if (this.Ms.test(e.key)) {
                                    if (null !== e.newValue) {
                                        let t = this.Ys(e.key, e.newValue);
                                        if (t)
                                            return this.Zs(t)
                                    }
                                } else if (e.key === this.xs) {
                                    if (null !== e.newValue) {
                                        let t = this.Ls(e.newValue);
                                        if (t)
                                            return this.Bs(t)
                                    }
                                } else if (e.key === this.vs) {
                                    let t = function(e) {
                                        let t = eI.oe;
                                        if (null != e)
                                            try {
                                                let n = JSON.parse(e);
                                                "number" == typeof n || S(),
                                                t = n
                                            } catch (e) {
                                                b("SharedClientState", "Failed to read sequence number from WebStorage", e)
                                            }
                                        return t
                                    }(e.newValue);
                                    t !== eI.oe && this.sequenceNumberHandler(t)
                                } else if (e.key === this.Os) {
                                    let t = this.Xs(e.newValue);
                                    await Promise.all(t.map(e => this.syncEngine.eo(e)))
                                }
                            }
                        } else
                            this.bs.push(e)
                    }
                    )
                }
            }
            get Ks() {
                return this.Ss.get(this.ps)
            }
            Ns() {
                this.setItem(this.Ds, this.Ks.Vs())
            }
            qs(e, t, n) {
                let r = new sT(this.currentUser,e,t,n)
                  , i = sI(this.persistenceKey, this.currentUser, e);
                this.setItem(i, r.Vs())
            }
            Qs(e) {
                let t = sI(this.persistenceKey, this.currentUser, e);
                this.removeItem(t)
            }
            Us(e) {
                let t = {
                    clientId: this.ps,
                    onlineState: e
                };
                this.storage.setItem(this.xs, JSON.stringify(t))
            }
            $s(e, t, n) {
                let r = sb(this.persistenceKey, e)
                  , i = new sE(e,t,n);
                this.setItem(r, i.Vs())
            }
            Ws(e) {
                let t = JSON.stringify(Array.from(e));
                this.setItem(this.Os, t)
            }
            Gs(e) {
                let t = this.Cs.exec(e);
                return t ? t[1] : null
            }
            js(e, t) {
                let n = this.Gs(e);
                return sS.Rs(n, t)
            }
            Hs(e, t) {
                let n = this.Fs.exec(e)
                  , r = Number(n[1])
                  , i = void 0 !== n[2] ? n[2] : null;
                return sT.Rs(new p(i), r, t)
            }
            Ys(e, t) {
                let n = Number(this.Ms.exec(e)[1]);
                return sE.Rs(n, t)
            }
            Ls(e) {
                return sx.Rs(e)
            }
            Xs(e) {
                return JSON.parse(e)
            }
            async Js(e) {
                if (e.user.uid === this.currentUser.uid)
                    return this.syncEngine.no(e.batchId, e.state, e.error);
                I("SharedClientState", `Ignoring mutation for non-active user ${e.user.uid}`)
            }
            Zs(e) {
                return this.syncEngine.ro(e.targetId, e.state, e.error)
            }
            zs(e, t) {
                let n = t ? this.Ss.insert(e, t) : this.Ss.remove(e)
                  , r = this.ks(this.Ss)
                  , i = this.ks(n)
                  , s = []
                  , a = [];
                return i.forEach(e => {
                    r.has(e) || s.push(e)
                }
                ),
                r.forEach(e => {
                    i.has(e) || a.push(e)
                }
                ),
                this.syncEngine.io(s, a).then( () => {
                    this.Ss = n
                }
                )
            }
            Bs(e) {
                this.Ss.get(e.clientId) && this.onlineStateHandler(e.onlineState)
            }
            ks(e) {
                let t = nI;
                return e.forEach( (e, n) => {
                    t = t.unionWith(n.activeTargetIds)
                }
                ),
                t
            }
        }
        class sN {
            constructor() {
                this.so = new sD,
                this.oo = {},
                this.onlineStateHandler = null,
                this.sequenceNumberHandler = null
            }
            addPendingMutation(e) {}
            updateMutationState(e, t, n) {}
            addLocalQueryTarget(e, t=!0) {
                return t && this.so.fs(e),
                this.oo[e] || "not-current"
            }
            updateQueryState(e, t, n) {
                this.oo[e] = t
            }
            removeLocalQueryTarget(e) {
                this.so.gs(e)
            }
            isLocalQueryTarget(e) {
                return this.so.activeTargetIds.has(e)
            }
            clearQueryState(e) {
                delete this.oo[e]
            }
            getAllActiveQueryTargets() {
                return this.so.activeTargetIds
            }
            isActiveQueryTarget(e) {
                return this.so.activeTargetIds.has(e)
            }
            start() {
                return this.so = new sD,
                Promise.resolve()
            }
            handleUserChange(e, t, n) {}
            setOnlineState(e) {}
            shutdown() {}
            writeSequenceNumber(e) {}
            notifyBundleLoaded(e) {}
        }
        class sk {
            _o(e) {}
            shutdown() {}
        }
        class sA {
            constructor() {
                this.ao = () => this.uo(),
                this.co = () => this.lo(),
                this.ho = [],
                this.Po()
            }
            _o(e) {
                this.ho.push(e)
            }
            shutdown() {
                window.removeEventListener("online", this.ao),
                window.removeEventListener("offline", this.co)
            }
            Po() {
                window.addEventListener("online", this.ao),
                window.addEventListener("offline", this.co)
            }
            uo() {
                for (let e of (I("ConnectivityMonitor", "Network connectivity changed: AVAILABLE"),
                this.ho))
                    e(0)
            }
            lo() {
                for (let e of (I("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE"),
                this.ho))
                    e(1)
            }
            static D() {
                return "undefined" != typeof window && void 0 !== window.addEventListener && void 0 !== window.removeEventListener
            }
        }
        let sR = null;
        function sF() {
            return null === sR ? sR = 268435456 + Math.round(2147483648 * Math.random()) : sR++,
            "0x" + sR.toString(16)
        }
        let sV = {
            BatchGetDocuments: "batchGet",
            Commit: "commit",
            RunQuery: "runQuery",
            RunAggregationQuery: "runAggregationQuery"
        };
        class sM {
            constructor(e) {
                this.Io = e.Io,
                this.To = e.To
            }
            Eo(e) {
                this.Ao = e
            }
            Ro(e) {
                this.Vo = e
            }
            mo(e) {
                this.fo = e
            }
            onMessage(e) {
                this.po = e
            }
            close() {
                this.To()
            }
            send(e) {
                this.Io(e)
            }
            yo() {
                this.Ao()
            }
            wo() {
                this.Vo()
            }
            So(e) {
                this.fo(e)
            }
            bo(e) {
                this.po(e)
            }
        }
        let sO = "WebChannelConnection";
        class sL extends class {
            constructor(e) {
                this.databaseInfo = e,
                this.databaseId = e.databaseId;
                let t = e.ssl ? "https" : "http"
                  , n = encodeURIComponent(this.databaseId.projectId)
                  , r = encodeURIComponent(this.databaseId.database);
                this.Do = t + "://" + e.host,
                this.vo = `projects/${n}/databases/${r}`,
                this.Co = "(default)" === this.databaseId.database ? `project_id=${n}` : `project_id=${n}&database_id=${r}`
            }
            get Fo() {
                return !1
            }
            Mo(e, t, n, r, i) {
                let s = sF()
                  , a = this.xo(e, t.toUriEncodedString());
                I("RestConnection", `Sending RPC '${e}' ${s}:`, a, n);
                let o = {
                    "google-cloud-resource-prefix": this.vo,
                    "x-goog-request-params": this.Co
                };
                return this.Oo(o, r, i),
                this.No(e, a, o, n).then(t => (I("RestConnection", `Received RPC '${e}' ${s}: `, t),
                t), t => {
                    throw T("RestConnection", `RPC '${e}' ${s} failed with error: `, t, "url: ", a, "request:", n),
                    t
                }
                )
            }
            Lo(e, t, n, r, i, s) {
                return this.Mo(e, t, n, r, i)
            }
            Oo(e, t, n) {
                e["X-Goog-Api-Client"] = function() {
                    return "gl-js/ fire/" + y
                }(),
                e["Content-Type"] = "text/plain",
                this.databaseInfo.appId && (e["X-Firebase-GMPID"] = this.databaseInfo.appId),
                t && t.headers.forEach( (t, n) => e[n] = t),
                n && n.headers.forEach( (t, n) => e[n] = t)
            }
            xo(e, t) {
                let n = sV[e];
                return `${this.Do}/v1/${t}:${n}`
            }
            terminate() {}
        }
        {
            constructor(e) {
                super(e),
                this.forceLongPolling = e.forceLongPolling,
                this.autoDetectLongPolling = e.autoDetectLongPolling,
                this.useFetchStreams = e.useFetchStreams,
                this.longPollingOptions = e.longPollingOptions
            }
            No(e, t, n, r) {
                let i = sF();
                return new Promise( (s, a) => {
                    let o = new d.JJ;
                    o.setWithCredentials(!0),
                    o.listenOnce(d.tw.COMPLETE, () => {
                        try {
                            switch (o.getLastErrorCode()) {
                            case d.jK.NO_ERROR:
                                let t = o.getResponseJson();
                                I(sO, `XHR for RPC '${e}' ${i} received:`, JSON.stringify(t)),
                                s(t);
                                break;
                            case d.jK.TIMEOUT:
                                I(sO, `RPC '${e}' ${i} timed out`),
                                a(new C(D.DEADLINE_EXCEEDED,"Request time out"));
                                break;
                            case d.jK.HTTP_ERROR:
                                let n = o.getStatus();
                                if (I(sO, `RPC '${e}' ${i} failed with status:`, n, "response text:", o.getResponseText()),
                                n > 0) {
                                    let e = o.getResponseJson();
                                    Array.isArray(e) && (e = e[0]);
                                    let t = null == e ? void 0 : e.error;
                                    if (t && t.status && t.message) {
                                        let e = function(e) {
                                            let t = e.toLowerCase().replace(/_/g, "-");
                                            return Object.values(D).indexOf(t) >= 0 ? t : D.UNKNOWN
                                        }(t.status);
                                        a(new C(e,t.message))
                                    } else
                                        a(new C(D.UNKNOWN,"Server responded with status " + o.getStatus()))
                                } else
                                    a(new C(D.UNAVAILABLE,"Connection failed."));
                                break;
                            default:
                                S()
                            }
                        } finally {
                            I(sO, `RPC '${e}' ${i} completed.`)
                        }
                    }
                    );
                    let l = JSON.stringify(r);
                    I(sO, `RPC '${e}' ${i} sending request:`, r),
                    o.send(t, "POST", l, n, 15)
                }
                )
            }
            Bo(e, t, n) {
                let i = sF()
                  , s = [this.Do, "/", "google.firestore.v1.Firestore", "/", e, "/channel"]
                  , a = (0,
                d.UE)()
                  , o = (0,
                d.FJ)()
                  , l = {
                    httpSessionIdParam: "gsessionid",
                    initMessageHeaders: {},
                    messageUrlParams: {
                        database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
                    },
                    sendRawJson: !0,
                    supportsCrossDomainXhr: !0,
                    internalChannelParams: {
                        forwardChannelRequestTimeoutMs: 6e5
                    },
                    forceLongPolling: this.forceLongPolling,
                    detectBufferingProxy: this.autoDetectLongPolling
                }
                  , u = this.longPollingOptions.timeoutSeconds;
                void 0 !== u && (l.longPollingTimeout = Math.round(1e3 * u)),
                this.useFetchStreams && (l.useFetchStreams = !0),
                this.Oo(l.initMessageHeaders, t, n),
                l.encodeInitMessageHeaders = !0;
                let c = s.join("");
                I(sO, `Creating RPC '${e}' stream ${i}: ${c}`, l);
                let h = a.createWebChannel(c, l)
                  , f = !1
                  , m = !1
                  , g = new sM({
                    Io: t => {
                        m ? I(sO, `Not sending because RPC '${e}' stream ${i} is closed:`, t) : (f || (I(sO, `Opening RPC '${e}' stream ${i} transport.`),
                        h.open(),
                        f = !0),
                        I(sO, `RPC '${e}' stream ${i} sending:`, t),
                        h.send(t))
                    }
                    ,
                    To: () => h.close()
                })
                  , p = (e, t, n) => {
                    e.listen(t, e => {
                        try {
                            n(e)
                        } catch (e) {
                            setTimeout( () => {
                                throw e
                            }
                            , 0)
                        }
                    }
                    )
                }
                ;
                return p(h, d.ii.EventType.OPEN, () => {
                    m || (I(sO, `RPC '${e}' stream ${i} transport opened.`),
                    g.yo())
                }
                ),
                p(h, d.ii.EventType.CLOSE, () => {
                    m || (m = !0,
                    I(sO, `RPC '${e}' stream ${i} transport closed`),
                    g.So())
                }
                ),
                p(h, d.ii.EventType.ERROR, t => {
                    m || (m = !0,
                    T(sO, `RPC '${e}' stream ${i} transport errored:`, t),
                    g.So(new C(D.UNAVAILABLE,"The operation could not be completed")))
                }
                ),
                p(h, d.ii.EventType.MESSAGE, t => {
                    var n;
                    if (!m) {
                        let s = t.data[0];
                        s || S();
                        let a = s.error || (null === (n = s[0]) || void 0 === n ? void 0 : n.error);
                        if (a) {
                            I(sO, `RPC '${e}' stream ${i} received error:`, a);
                            let t = a.status
                              , n = function(e) {
                                let t = r[e];
                                if (void 0 !== t)
                                    return n2(t)
                            }(t)
                              , s = a.message;
                            void 0 === n && (n = D.INTERNAL,
                            s = "Unknown error status: " + t + " with message " + a.message),
                            m = !0,
                            g.So(new C(n,s)),
                            h.close()
                        } else
                            I(sO, `RPC '${e}' stream ${i} received:`, s),
                            g.bo(s)
                    }
                }
                ),
                p(o, d.ju.STAT_EVENT, t => {
                    t.stat === d.kN.PROXY ? I(sO, `RPC '${e}' stream ${i} detected buffering proxy`) : t.stat === d.kN.NOPROXY && I(sO, `RPC '${e}' stream ${i} detected no buffering proxy`)
                }
                ),
                setTimeout( () => {
                    g.wo()
                }
                , 0),
                g
            }
        }
        function sP() {
            return "undefined" != typeof window ? window : null
        }
        function sq() {
            return "undefined" != typeof document ? document : null
        }
        function sU(e) {
            return new rd(e,!0)
        }
        class sB {
            constructor(e, t, n=1e3, r=1.5, i=6e4) {
                this.ui = e,
                this.timerId = t,
                this.ko = n,
                this.qo = r,
                this.Qo = i,
                this.Ko = 0,
                this.$o = null,
                this.Uo = Date.now(),
                this.reset()
            }
            reset() {
                this.Ko = 0
            }
            Wo() {
                this.Ko = this.Qo
            }
            Go(e) {
                this.cancel();
                let t = Math.floor(this.Ko + this.zo())
                  , n = Math.max(0, Date.now() - this.Uo)
                  , r = Math.max(0, t - n);
                r > 0 && I("ExponentialBackoff", `Backing off for ${r} ms (base delay: ${this.Ko} ms, delay with jitter: ${t} ms, last attempt: ${n} ms ago)`),
                this.$o = this.ui.enqueueAfterDelay(this.timerId, r, () => (this.Uo = Date.now(),
                e())),
                this.Ko *= this.qo,
                this.Ko < this.ko && (this.Ko = this.ko),
                this.Ko > this.Qo && (this.Ko = this.Qo)
            }
            jo() {
                null !== this.$o && (this.$o.skipDelay(),
                this.$o = null)
            }
            cancel() {
                null !== this.$o && (this.$o.cancel(),
                this.$o = null)
            }
            zo() {
                return (Math.random() - .5) * this.Ko
            }
        }
        class sz {
            constructor(e, t, n, r, i, s, a, o) {
                this.ui = e,
                this.Ho = n,
                this.Jo = r,
                this.connection = i,
                this.authCredentialsProvider = s,
                this.appCheckCredentialsProvider = a,
                this.listener = o,
                this.state = 0,
                this.Yo = 0,
                this.Zo = null,
                this.Xo = null,
                this.stream = null,
                this.e_ = 0,
                this.t_ = new sB(e,t)
            }
            n_() {
                return 1 === this.state || 5 === this.state || this.r_()
            }
            r_() {
                return 2 === this.state || 3 === this.state
            }
            start() {
                this.e_ = 0,
                4 !== this.state ? this.auth() : this.i_()
            }
            async stop() {
                this.n_() && await this.close(0)
            }
            s_() {
                this.state = 0,
                this.t_.reset()
            }
            o_() {
                this.r_() && null === this.Zo && (this.Zo = this.ui.enqueueAfterDelay(this.Ho, 6e4, () => this.__()))
            }
            a_(e) {
                this.u_(),
                this.stream.send(e)
            }
            async __() {
                if (this.r_())
                    return this.close(0)
            }
            u_() {
                this.Zo && (this.Zo.cancel(),
                this.Zo = null)
            }
            c_() {
                this.Xo && (this.Xo.cancel(),
                this.Xo = null)
            }
            async close(e, t) {
                this.u_(),
                this.c_(),
                this.t_.cancel(),
                this.Yo++,
                4 !== e ? this.t_.reset() : t && t.code === D.RESOURCE_EXHAUSTED ? (b(t.toString()),
                b("Using maximum backoff delay to prevent overloading the backend."),
                this.t_.Wo()) : t && t.code === D.UNAUTHENTICATED && 3 !== this.state && (this.authCredentialsProvider.invalidateToken(),
                this.appCheckCredentialsProvider.invalidateToken()),
                null !== this.stream && (this.l_(),
                this.stream.close(),
                this.stream = null),
                this.state = e,
                await this.listener.mo(t)
            }
            l_() {}
            auth() {
                this.state = 1;
                let e = this.h_(this.Yo)
                  , t = this.Yo;
                Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then( ([e,n]) => {
                    this.Yo === t && this.P_(e, n)
                }
                , t => {
                    e( () => {
                        let e = new C(D.UNKNOWN,"Fetching auth token failed: " + t.message);
                        return this.I_(e)
                    }
                    )
                }
                )
            }
            P_(e, t) {
                let n = this.h_(this.Yo);
                this.stream = this.T_(e, t),
                this.stream.Eo( () => {
                    n( () => this.listener.Eo())
                }
                ),
                this.stream.Ro( () => {
                    n( () => (this.state = 2,
                    this.Xo = this.ui.enqueueAfterDelay(this.Jo, 1e4, () => (this.r_() && (this.state = 3),
                    Promise.resolve())),
                    this.listener.Ro()))
                }
                ),
                this.stream.mo(e => {
                    n( () => this.I_(e))
                }
                ),
                this.stream.onMessage(e => {
                    n( () => 1 == ++this.e_ ? this.E_(e) : this.onNext(e))
                }
                )
            }
            i_() {
                this.state = 5,
                this.t_.Go(async () => {
                    this.state = 0,
                    this.start()
                }
                )
            }
            I_(e) {
                return I("PersistentStream", `close with error: ${e}`),
                this.stream = null,
                this.close(4, e)
            }
            h_(e) {
                return t => {
                    this.ui.enqueueAndForget( () => this.Yo === e ? t() : (I("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."),
                    Promise.resolve()))
                }
            }
        }
        class sK extends sz {
            constructor(e, t, n, r, i, s) {
                super(e, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", t, n, r, s),
                this.serializer = i
            }
            T_(e, t) {
                return this.connection.Bo("Listen", e, t)
            }
            E_(e) {
                return this.onNext(e)
            }
            onNext(e) {
                this.t_.reset();
                let t = function(e, t) {
                    let n;
                    if ("targetChange"in t) {
                        var r, i;
                        t.targetChange;
                        let s = "NO_CHANGE" === (r = t.targetChange.targetChangeType || "NO_CHANGE") ? 0 : "ADD" === r ? 1 : "REMOVE" === r ? 2 : "CURRENT" === r ? 3 : "RESET" === r ? 4 : S()
                          , a = t.targetChange.targetIds || []
                          , o = (i = t.targetChange.resumeToken,
                        e.useProto3Json ? (void 0 === i || "string" == typeof i || S(),
                        e7.fromBase64String(i || "")) : (void 0 === i || i instanceof m || i instanceof Uint8Array || S(),
                        e7.fromUint8Array(i || new Uint8Array)))
                          , l = t.targetChange.cause;
                        n = new ri(s,a,o,l && new C(void 0 === l.code ? D.UNKNOWN : n2(l.code),l.message || "") || null)
                    } else if ("documentChange"in t) {
                        t.documentChange;
                        let r = t.documentChange;
                        r.document,
                        r.document.name,
                        r.document.updateTime;
                        let i = rI(e, r.document.name)
                          , s = rp(r.document.updateTime)
                          , a = r.document.createTime ? rp(r.document.createTime) : K.min()
                          , o = new tk({
                            mapValue: {
                                fields: r.document.fields
                            }
                        })
                          , l = tA.newFoundDocument(i, s, a, o);
                        n = new rn(r.targetIds || [],r.removedTargetIds || [],l.key,l)
                    } else if ("documentDelete"in t) {
                        t.documentDelete;
                        let r = t.documentDelete;
                        r.document;
                        let i = rI(e, r.document)
                          , s = r.readTime ? rp(r.readTime) : K.min()
                          , a = tA.newNoDocument(i, s);
                        n = new rn([],r.removedTargetIds || [],a.key,a)
                    } else if ("documentRemove"in t) {
                        t.documentRemove;
                        let r = t.documentRemove;
                        r.document;
                        let i = rI(e, r.document);
                        n = new rn([],r.removedTargetIds || [],i,null)
                    } else {
                        if (!("filter"in t))
                            return S();
                        {
                            t.filter;
                            let e = t.filter;
                            e.targetId;
                            let {count: r=0, unchangedNames: i} = e
                              , s = new n0(r,i);
                            n = new rr(e.targetId,s)
                        }
                    }
                    return n
                }(this.serializer, e)
                  , n = function(e) {
                    if (!("targetChange"in e))
                        return K.min();
                    let t = e.targetChange;
                    return t.targetIds && t.targetIds.length ? K.min() : t.readTime ? rp(t.readTime) : K.min()
                }(e);
                return this.listener.d_(t, n)
            }
            A_(e) {
                let t = {};
                t.database = rE(this.serializer),
                t.addTarget = function(e, t) {
                    let n;
                    let r = t.target;
                    if ((n = t2(r) ? {
                        documents: rk(e, r)
                    } : {
                        query: rA(e, r)._t
                    }).targetId = t.targetId,
                    t.resumeToken.approximateByteSize() > 0) {
                        n.resumeToken = rg(e, t.resumeToken);
                        let r = rf(e, t.expectedCount);
                        null !== r && (n.expectedCount = r)
                    } else if (t.snapshotVersion.compareTo(K.min()) > 0) {
                        n.readTime = rm(e, t.snapshotVersion.toTimestamp());
                        let r = rf(e, t.expectedCount);
                        null !== r && (n.expectedCount = r)
                    }
                    return n
                }(this.serializer, e);
                let n = function(e, t) {
                    let n = function(e) {
                        switch (e) {
                        case "TargetPurposeListen":
                            return null;
                        case "TargetPurposeExistenceFilterMismatch":
                            return "existence-filter-mismatch";
                        case "TargetPurposeExistenceFilterMismatchBloom":
                            return "existence-filter-mismatch-bloom";
                        case "TargetPurposeLimboResolution":
                            return "limbo-document";
                        default:
                            return S()
                        }
                    }(t.purpose);
                    return null == n ? null : {
                        "goog-listen-tags": n
                    }
                }(this.serializer, e);
                n && (t.labels = n),
                this.a_(t)
            }
            R_(e) {
                let t = {};
                t.database = rE(this.serializer),
                t.removeTarget = e,
                this.a_(t)
            }
        }
        class sG extends sz {
            constructor(e, t, n, r, i, s) {
                super(e, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", t, n, r, s),
                this.serializer = i
            }
            get V_() {
                return this.e_ > 0
            }
            start() {
                this.lastStreamToken = void 0,
                super.start()
            }
            l_() {
                this.V_ && this.m_([])
            }
            T_(e, t) {
                return this.connection.Bo("Write", e, t)
            }
            E_(e) {
                return e.streamToken || S(),
                this.lastStreamToken = e.streamToken,
                e.writeResults && 0 !== e.writeResults.length && S(),
                this.listener.f_()
            }
            onNext(e) {
                var t, n;
                e.streamToken || S(),
                this.lastStreamToken = e.streamToken,
                this.t_.reset();
                let r = (t = e.writeResults,
                n = e.commitTime,
                t && t.length > 0 ? (void 0 !== n || S(),
                t.map(e => {
                    let t;
                    return (t = e.updateTime ? rp(e.updateTime) : rp(n)).isEqual(K.min()) && (t = rp(n)),
                    new nO(t,e.transformResults || [])
                }
                )) : [])
                  , i = rp(e.commitTime);
                return this.listener.g_(i, r)
            }
            p_() {
                let e = {};
                e.database = rE(this.serializer),
                this.a_(e)
            }
            m_(e) {
                let t = {
                    streamToken: this.lastStreamToken,
                    writes: e.map(e => rC(this.serializer, e))
                };
                this.a_(t)
            }
        }
        class s$ extends class {
        }
        {
            constructor(e, t, n, r) {
                super(),
                this.authCredentials = e,
                this.appCheckCredentials = t,
                this.connection = n,
                this.serializer = r,
                this.y_ = !1
            }
            w_() {
                if (this.y_)
                    throw new C(D.FAILED_PRECONDITION,"The client has already been terminated.")
            }
            Mo(e, t, n, r) {
                return this.w_(),
                Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then( ([i,s]) => this.connection.Mo(e, rw(t, n), r, i, s)).catch(e => {
                    throw "FirebaseError" === e.name ? (e.code === D.UNAUTHENTICATED && (this.authCredentials.invalidateToken(),
                    this.appCheckCredentials.invalidateToken()),
                    e) : new C(D.UNKNOWN,e.toString())
                }
                )
            }
            Lo(e, t, n, r, i) {
                return this.w_(),
                Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then( ([s,a]) => this.connection.Lo(e, rw(t, n), r, s, a, i)).catch(e => {
                    throw "FirebaseError" === e.name ? (e.code === D.UNAUTHENTICATED && (this.authCredentials.invalidateToken(),
                    this.appCheckCredentials.invalidateToken()),
                    e) : new C(D.UNKNOWN,e.toString())
                }
                )
            }
            terminate() {
                this.y_ = !0,
                this.connection.terminate()
            }
        }
        class sQ {
            constructor(e, t) {
                this.asyncQueue = e,
                this.onlineStateHandler = t,
                this.state = "Unknown",
                this.S_ = 0,
                this.b_ = null,
                this.D_ = !0
            }
            v_() {
                0 === this.S_ && (this.C_("Unknown"),
                this.b_ = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.b_ = null,
                this.F_("Backend didn't respond within 10 seconds."),
                this.C_("Offline"),
                Promise.resolve())))
            }
            M_(e) {
                "Online" === this.state ? this.C_("Unknown") : (this.S_++,
                this.S_ >= 1 && (this.x_(),
                this.F_(`Connection failed 1 times. Most recent error: ${e.toString()}`),
                this.C_("Offline")))
            }
            set(e) {
                this.x_(),
                this.S_ = 0,
                "Online" === e && (this.D_ = !1),
                this.C_(e)
            }
            C_(e) {
                e !== this.state && (this.state = e,
                this.onlineStateHandler(e))
            }
            F_(e) {
                let t = `Could not reach Cloud Firestore backend. ${e}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
                this.D_ ? (b(t),
                this.D_ = !1) : I("OnlineStateTracker", t)
            }
            x_() {
                null !== this.b_ && (this.b_.cancel(),
                this.b_ = null)
            }
        }
        class sj {
            constructor(e, t, n, r, i) {
                this.localStore = e,
                this.datastore = t,
                this.asyncQueue = n,
                this.remoteSyncer = {},
                this.O_ = [],
                this.N_ = new Map,
                this.L_ = new Set,
                this.B_ = [],
                this.k_ = i,
                this.k_._o(e => {
                    n.enqueueAndForget(async () => {
                        s2(this) && (I("RemoteStore", "Restarting streams for network reachability change."),
                        await async function(e) {
                            e.L_.add(4),
                            await sJ(e),
                            e.q_.set("Unknown"),
                            e.L_.delete(4),
                            await sW(e)
                        }(this))
                    }
                    )
                }
                ),
                this.q_ = new sQ(n,r)
            }
        }
        async function sW(e) {
            if (s2(e))
                for (let t of e.B_)
                    await t(!0)
        }
        async function sJ(e) {
            for (let t of e.B_)
                await t(!1)
        }
        function sH(e, t) {
            e.N_.has(t.targetId) || (e.N_.set(t.targetId, t),
            s1(e) ? s0(e) : al(e).r_() && sX(e, t))
        }
        function sY(e, t) {
            let n = al(e);
            e.N_.delete(t),
            n.r_() && sZ(e, t),
            0 === e.N_.size && (n.r_() ? n.o_() : s2(e) && e.q_.set("Unknown"))
        }
        function sX(e, t) {
            if (e.Q_.xe(t.targetId),
            t.resumeToken.approximateByteSize() > 0 || t.snapshotVersion.compareTo(K.min()) > 0) {
                let n = e.remoteSyncer.getRemoteKeysForTarget(t.targetId).size;
                t = t.withExpectedCount(n)
            }
            al(e).A_(t)
        }
        function sZ(e, t) {
            e.Q_.xe(t),
            al(e).R_(t)
        }
        function s0(e) {
            e.Q_ = new ra({
                getRemoteKeysForTarget: t => e.remoteSyncer.getRemoteKeysForTarget(t),
                ot: t => e.N_.get(t) || null,
                tt: () => e.datastore.serializer.databaseId
            }),
            al(e).start(),
            e.q_.v_()
        }
        function s1(e) {
            return s2(e) && !al(e).n_() && e.N_.size > 0
        }
        function s2(e) {
            return 0 === e.L_.size
        }
        async function s5(e) {
            e.q_.set("Online")
        }
        async function s4(e) {
            e.N_.forEach( (t, n) => {
                sX(e, t)
            }
            )
        }
        async function s8(e, t) {
            e.Q_ = void 0,
            s1(e) ? (e.q_.M_(t),
            s0(e)) : e.q_.set("Unknown")
        }
        async function s3(e, t, n) {
            if (e.q_.set("Online"),
            t instanceof ri && 2 === t.state && t.cause)
                try {
                    await async function(e, t) {
                        let n = t.cause;
                        for (let r of t.targetIds)
                            e.N_.has(r) && (await e.remoteSyncer.rejectListen(r, n),
                            e.N_.delete(r),
                            e.Q_.removeTarget(r))
                    }(e, t)
                } catch (n) {
                    I("RemoteStore", "Failed to remove targets %s: %s ", t.targetIds.join(","), n),
                    await s6(e, n)
                }
            else if (t instanceof rn ? e.Q_.Ke(t) : t instanceof rr ? e.Q_.He(t) : e.Q_.We(t),
            !n.isEqual(K.min()))
                try {
                    let t = await sc(e.localStore);
                    n.compareTo(t) >= 0 && await function(e, t) {
                        let n = e.Q_.rt(t);
                        return n.targetChanges.forEach( (n, r) => {
                            if (n.resumeToken.approximateByteSize() > 0) {
                                let i = e.N_.get(r);
                                i && e.N_.set(r, i.withResumeToken(n.resumeToken, t))
                            }
                        }
                        ),
                        n.targetMismatches.forEach( (t, n) => {
                            let r = e.N_.get(t);
                            if (!r)
                                return;
                            e.N_.set(t, r.withResumeToken(e7.EMPTY_BYTE_STRING, r.snapshotVersion)),
                            sZ(e, t);
                            let i = new rL(r.target,t,n,r.sequenceNumber);
                            sX(e, i)
                        }
                        ),
                        e.remoteSyncer.applyRemoteEvent(n)
                    }(e, n)
                } catch (t) {
                    I("RemoteStore", "Failed to raise snapshot:", t),
                    await s6(e, t)
                }
        }
        async function s6(e, t, n) {
            if (!em(t))
                throw t;
            e.L_.add(1),
            await sJ(e),
            e.q_.set("Offline"),
            n || (n = () => sc(e.localStore)),
            e.asyncQueue.enqueueRetryable(async () => {
                I("RemoteStore", "Retrying IndexedDB access"),
                await n(),
                e.L_.delete(1),
                await sW(e)
            }
            )
        }
        function s9(e, t) {
            return t().catch(n => s6(e, n, t))
        }
        async function s7(e) {
            let t = au(e)
              , n = e.O_.length > 0 ? e.O_[e.O_.length - 1].batchId : -1;
            for (; s2(e) && e.O_.length < 10; )
                try {
                    let r = await function(e, t) {
                        return e.persistence.runTransaction("Get next mutation batch", "readonly", n => (void 0 === t && (t = -1),
                        e.mutationQueue.getNextMutationBatchAfterBatchId(n, t)))
                    }(e.localStore, n);
                    if (null === r) {
                        0 === e.O_.length && t.o_();
                        break
                    }
                    n = r.batchId,
                    function(e, t) {
                        e.O_.push(t);
                        let n = au(e);
                        n.r_() && n.V_ && n.m_(t.mutations)
                    }(e, r)
                } catch (t) {
                    await s6(e, t)
                }
            ae(e) && at(e)
        }
        function ae(e) {
            return s2(e) && !au(e).n_() && e.O_.length > 0
        }
        function at(e) {
            au(e).start()
        }
        async function an(e) {
            au(e).p_()
        }
        async function ar(e) {
            let t = au(e);
            for (let n of e.O_)
                t.m_(n.mutations)
        }
        async function ai(e, t, n) {
            let r = e.O_.shift()
              , i = nY.from(r, t, n);
            await s9(e, () => e.remoteSyncer.applySuccessfulWrite(i)),
            await s7(e)
        }
        async function as(e, t) {
            t && au(e).V_ && await async function(e, t) {
                var n;
                if (n1(n = t.code) && n !== D.ABORTED) {
                    let n = e.O_.shift();
                    au(e).s_(),
                    await s9(e, () => e.remoteSyncer.rejectFailedWrite(n.batchId, t)),
                    await s7(e)
                }
            }(e, t),
            ae(e) && at(e)
        }
        async function aa(e, t) {
            e.asyncQueue.verifyOperationInProgress(),
            I("RemoteStore", "RemoteStore received new credentials");
            let n = s2(e);
            e.L_.add(3),
            await sJ(e),
            n && e.q_.set("Unknown"),
            await e.remoteSyncer.handleCredentialChange(t),
            e.L_.delete(3),
            await sW(e)
        }
        async function ao(e, t) {
            t ? (e.L_.delete(2),
            await sW(e)) : t || (e.L_.add(2),
            await sJ(e),
            e.q_.set("Unknown"))
        }
        function al(e) {
            var t, n, r;
            return e.K_ || (e.K_ = (t = e.datastore,
            n = e.asyncQueue,
            r = {
                Eo: s5.bind(null, e),
                Ro: s4.bind(null, e),
                mo: s8.bind(null, e),
                d_: s3.bind(null, e)
            },
            t.w_(),
            new sK(n,t.connection,t.authCredentials,t.appCheckCredentials,t.serializer,r)),
            e.B_.push(async t => {
                t ? (e.K_.s_(),
                s1(e) ? s0(e) : e.q_.set("Unknown")) : (await e.K_.stop(),
                e.Q_ = void 0)
            }
            )),
            e.K_
        }
        function au(e) {
            var t, n, r;
            return e.U_ || (e.U_ = (t = e.datastore,
            n = e.asyncQueue,
            r = {
                Eo: () => Promise.resolve(),
                Ro: an.bind(null, e),
                mo: as.bind(null, e),
                f_: ar.bind(null, e),
                g_: ai.bind(null, e)
            },
            t.w_(),
            new sG(n,t.connection,t.authCredentials,t.appCheckCredentials,t.serializer,r)),
            e.B_.push(async t => {
                t ? (e.U_.s_(),
                await s7(e)) : (await e.U_.stop(),
                e.O_.length > 0 && (I("RemoteStore", `Stopping write stream with ${e.O_.length} pending writes`),
                e.O_ = []))
            }
            )),
            e.U_
        }
        class ac {
            constructor(e, t, n, r, i) {
                this.asyncQueue = e,
                this.timerId = t,
                this.targetTimeMs = n,
                this.op = r,
                this.removalCallback = i,
                this.deferred = new N,
                this.then = this.deferred.promise.then.bind(this.deferred.promise),
                this.deferred.promise.catch(e => {}
                )
            }
            get promise() {
                return this.deferred.promise
            }
            static createAndSchedule(e, t, n, r, i) {
                let s = new ac(e,t,Date.now() + n,r,i);
                return s.start(n),
                s
            }
            start(e) {
                this.timerHandle = setTimeout( () => this.handleDelayElapsed(), e)
            }
            skipDelay() {
                return this.handleDelayElapsed()
            }
            cancel(e) {
                null !== this.timerHandle && (this.clearTimeout(),
                this.deferred.reject(new C(D.CANCELLED,"Operation cancelled" + (e ? ": " + e : ""))))
            }
            handleDelayElapsed() {
                this.asyncQueue.enqueueAndForget( () => null !== this.timerHandle ? (this.clearTimeout(),
                this.op().then(e => this.deferred.resolve(e))) : Promise.resolve())
            }
            clearTimeout() {
                null !== this.timerHandle && (this.removalCallback(this),
                clearTimeout(this.timerHandle),
                this.timerHandle = null)
            }
        }
        function ah(e, t) {
            if (b("AsyncQueue", `${t}: ${e}`),
            em(e))
                return new C(D.UNAVAILABLE,`${t}: ${e}`);
            throw e
        }
        class ad {
            constructor(e) {
                this.comparator = e ? (t, n) => e(t, n) || W.comparator(t.key, n.key) : (e, t) => W.comparator(e.key, t.key),
                this.keyedMap = ng(),
                this.sortedSet = new e0(this.comparator)
            }
            static emptySet(e) {
                return new ad(e.comparator)
            }
            has(e) {
                return null != this.keyedMap.get(e)
            }
            get(e) {
                return this.keyedMap.get(e)
            }
            first() {
                return this.sortedSet.minKey()
            }
            last() {
                return this.sortedSet.maxKey()
            }
            isEmpty() {
                return this.sortedSet.isEmpty()
            }
            indexOf(e) {
                let t = this.keyedMap.get(e);
                return t ? this.sortedSet.indexOf(t) : -1
            }
            get size() {
                return this.sortedSet.size
            }
            forEach(e) {
                this.sortedSet.inorderTraversal( (t, n) => (e(t),
                !1))
            }
            add(e) {
                let t = this.delete(e.key);
                return t.copy(t.keyedMap.insert(e.key, e), t.sortedSet.insert(e, null))
            }
            delete(e) {
                let t = this.get(e);
                return t ? this.copy(this.keyedMap.remove(e), this.sortedSet.remove(t)) : this
            }
            isEqual(e) {
                if (!(e instanceof ad) || this.size !== e.size)
                    return !1;
                let t = this.sortedSet.getIterator()
                  , n = e.sortedSet.getIterator();
                for (; t.hasNext(); ) {
                    let e = t.getNext().key
                      , r = n.getNext().key;
                    if (!e.isEqual(r))
                        return !1
                }
                return !0
            }
            toString() {
                let e = [];
                return this.forEach(t => {
                    e.push(t.toString())
                }
                ),
                0 === e.length ? "DocumentSet ()" : "DocumentSet (\n  " + e.join("  \n") + "\n)"
            }
            copy(e, t) {
                let n = new ad;
                return n.comparator = this.comparator,
                n.keyedMap = e,
                n.sortedSet = t,
                n
            }
        }
        class af {
            constructor() {
                this.W_ = new e0(W.comparator)
            }
            track(e) {
                let t = e.doc.key
                  , n = this.W_.get(t);
                n ? 0 !== e.type && 3 === n.type ? this.W_ = this.W_.insert(t, e) : 3 === e.type && 1 !== n.type ? this.W_ = this.W_.insert(t, {
                    type: n.type,
                    doc: e.doc
                }) : 2 === e.type && 2 === n.type ? this.W_ = this.W_.insert(t, {
                    type: 2,
                    doc: e.doc
                }) : 2 === e.type && 0 === n.type ? this.W_ = this.W_.insert(t, {
                    type: 0,
                    doc: e.doc
                }) : 1 === e.type && 0 === n.type ? this.W_ = this.W_.remove(t) : 1 === e.type && 2 === n.type ? this.W_ = this.W_.insert(t, {
                    type: 1,
                    doc: n.doc
                }) : 0 === e.type && 1 === n.type ? this.W_ = this.W_.insert(t, {
                    type: 2,
                    doc: e.doc
                }) : S() : this.W_ = this.W_.insert(t, e)
            }
            G_() {
                let e = [];
                return this.W_.inorderTraversal( (t, n) => {
                    e.push(n)
                }
                ),
                e
            }
        }
        class am {
            constructor(e, t, n, r, i, s, a, o, l) {
                this.query = e,
                this.docs = t,
                this.oldDocs = n,
                this.docChanges = r,
                this.mutatedKeys = i,
                this.fromCache = s,
                this.syncStateChanged = a,
                this.excludesMetadataChanges = o,
                this.hasCachedResults = l
            }
            static fromInitialDocuments(e, t, n, r, i) {
                let s = [];
                return t.forEach(e => {
                    s.push({
                        type: 0,
                        doc: e
                    })
                }
                ),
                new am(e,t,ad.emptySet(t),s,n,r,!0,!1,i)
            }
            get hasPendingWrites() {
                return !this.mutatedKeys.isEmpty()
            }
            isEqual(e) {
                if (!(this.fromCache === e.fromCache && this.hasCachedResults === e.hasCachedResults && this.syncStateChanged === e.syncStateChanged && this.mutatedKeys.isEqual(e.mutatedKeys) && na(this.query, e.query) && this.docs.isEqual(e.docs) && this.oldDocs.isEqual(e.oldDocs)))
                    return !1;
                let t = this.docChanges
                  , n = e.docChanges;
                if (t.length !== n.length)
                    return !1;
                for (let e = 0; e < t.length; e++)
                    if (t[e].type !== n[e].type || !t[e].doc.isEqual(n[e].doc))
                        return !1;
                return !0
            }
        }
        class ag {
            constructor() {
                this.z_ = void 0,
                this.j_ = []
            }
            H_() {
                return this.j_.some(e => e.J_())
            }
        }
        class ap {
            constructor() {
                this.queries = ay(),
                this.onlineState = "Unknown",
                this.Y_ = new Set
            }
            terminate() {
                !function(e, t) {
                    let n = e.queries;
                    e.queries = ay(),
                    n.forEach( (e, n) => {
                        for (let e of n.j_)
                            e.onError(t)
                    }
                    )
                }(this, new C(D.ABORTED,"Firestore shutting down"))
            }
        }
        function ay() {
            return new nd(e => no(e),na)
        }
        async function aw(e, t) {
            let n = 3
              , r = t.query
              , i = e.queries.get(r);
            i ? !i.H_() && t.J_() && (n = 2) : (i = new ag,
            n = t.J_() ? 0 : 1);
            try {
                switch (n) {
                case 0:
                    i.z_ = await e.onListen(r, !0);
                    break;
                case 1:
                    i.z_ = await e.onListen(r, !1);
                    break;
                case 2:
                    await e.onFirstRemoteStoreListen(r)
                }
            } catch (n) {
                let e = ah(n, `Initialization of query '${nl(t.query)}' failed`);
                return void t.onError(e)
            }
            e.queries.set(r, i),
            i.j_.push(t),
            t.Z_(e.onlineState),
            i.z_ && t.X_(i.z_) && ab(e)
        }
        async function av(e, t) {
            let n = t.query
              , r = 3
              , i = e.queries.get(n);
            if (i) {
                let e = i.j_.indexOf(t);
                e >= 0 && (i.j_.splice(e, 1),
                0 === i.j_.length ? r = t.J_() ? 0 : 1 : !i.H_() && t.J_() && (r = 2))
            }
            switch (r) {
            case 0:
                return e.queries.delete(n),
                e.onUnlisten(n, !0);
            case 1:
                return e.queries.delete(n),
                e.onUnlisten(n, !1);
            case 2:
                return e.onLastRemoteStoreUnlisten(n);
            default:
                return
            }
        }
        function a_(e, t) {
            let n = !1;
            for (let r of t) {
                let t = r.query
                  , i = e.queries.get(t);
                if (i) {
                    for (let e of i.j_)
                        e.X_(r) && (n = !0);
                    i.z_ = r
                }
            }
            n && ab(e)
        }
        function aI(e, t, n) {
            let r = e.queries.get(t);
            if (r)
                for (let e of r.j_)
                    e.onError(n);
            e.queries.delete(t)
        }
        function ab(e) {
            e.Y_.forEach(e => {
                e.next()
            }
            )
        }
        (a = s || (s = {})).ea = "default",
        a.Cache = "cache";
        class aT {
            constructor(e, t, n) {
                this.query = e,
                this.ta = t,
                this.na = !1,
                this.ra = null,
                this.onlineState = "Unknown",
                this.options = n || {}
            }
            X_(e) {
                if (!this.options.includeMetadataChanges) {
                    let t = [];
                    for (let n of e.docChanges)
                        3 !== n.type && t.push(n);
                    e = new am(e.query,e.docs,e.oldDocs,t,e.mutatedKeys,e.fromCache,e.syncStateChanged,!0,e.hasCachedResults)
                }
                let t = !1;
                return this.na ? this.ia(e) && (this.ta.next(e),
                t = !0) : this.sa(e, this.onlineState) && (this.oa(e),
                t = !0),
                this.ra = e,
                t
            }
            onError(e) {
                this.ta.error(e)
            }
            Z_(e) {
                this.onlineState = e;
                let t = !1;
                return this.ra && !this.na && this.sa(this.ra, e) && (this.oa(this.ra),
                t = !0),
                t
            }
            sa(e, t) {
                return !(e.fromCache && this.J_()) || (!this.options._a || !("Offline" !== t)) && (!e.docs.isEmpty() || e.hasCachedResults || "Offline" === t)
            }
            ia(e) {
                if (e.docChanges.length > 0)
                    return !0;
                let t = this.ra && this.ra.hasPendingWrites !== e.hasPendingWrites;
                return !(!e.syncStateChanged && !t) && !0 === this.options.includeMetadataChanges
            }
            oa(e) {
                e = am.fromInitialDocuments(e.query, e.docs, e.mutatedKeys, e.fromCache, e.hasCachedResults),
                this.na = !0,
                this.ta.next(e)
            }
            J_() {
                return this.options.source !== s.Cache
            }
        }
        class aE {
            constructor(e, t) {
                this.aa = e,
                this.byteLength = t
            }
            ua() {
                return "metadata"in this.aa
            }
        }
        class aS {
            constructor(e) {
                this.serializer = e
            }
            Es(e) {
                return rI(this.serializer, e)
            }
            ds(e) {
                return e.metadata.exists ? rD(this.serializer, e.document, !1) : tA.newNoDocument(this.Es(e.metadata.name), this.As(e.metadata.readTime))
            }
            As(e) {
                return rp(e)
            }
        }
        class ax {
            constructor(e, t, n) {
                this.ca = e,
                this.localStore = t,
                this.serializer = n,
                this.queries = [],
                this.documents = [],
                this.collectionGroups = new Set,
                this.progress = aD(e)
            }
            la(e) {
                this.progress.bytesLoaded += e.byteLength;
                let t = this.progress.documentsLoaded;
                if (e.aa.namedQuery)
                    this.queries.push(e.aa.namedQuery);
                else if (e.aa.documentMetadata) {
                    this.documents.push({
                        metadata: e.aa.documentMetadata
                    }),
                    e.aa.documentMetadata.exists || ++t;
                    let n = $.fromString(e.aa.documentMetadata.name);
                    this.collectionGroups.add(n.get(n.length - 2))
                } else
                    e.aa.document && (this.documents[this.documents.length - 1].document = e.aa.document,
                    ++t);
                return t !== this.progress.documentsLoaded ? (this.progress.documentsLoaded = t,
                Object.assign({}, this.progress)) : null
            }
            ha(e) {
                let t = new Map
                  , n = new aS(this.serializer);
                for (let r of e)
                    if (r.metadata.queries) {
                        let e = n.Es(r.metadata.name);
                        for (let n of r.metadata.queries) {
                            let r = (t.get(n) || n_()).add(e);
                            t.set(n, r)
                        }
                    }
                return t
            }
            async complete() {
                let e = await sw(this.localStore, new aS(this.serializer), this.documents, this.ca.id)
                  , t = this.ha(this.documents);
                for (let e of this.queries)
                    await sv(this.localStore, e, t.get(e.name));
                return this.progress.taskState = "Success",
                {
                    progress: this.progress,
                    Pa: this.collectionGroups,
                    Ia: e
                }
            }
        }
        function aD(e) {
            return {
                taskState: "Running",
                documentsLoaded: 0,
                bytesLoaded: 0,
                totalDocuments: e.totalDocuments,
                totalBytes: e.totalBytes
            }
        }
        class aC {
            constructor(e) {
                this.key = e
            }
        }
        class aN {
            constructor(e) {
                this.key = e
            }
        }
        class ak {
            constructor(e, t) {
                this.query = e,
                this.Ta = t,
                this.Ea = null,
                this.hasCachedResults = !1,
                this.current = !1,
                this.da = n_(),
                this.mutatedKeys = n_(),
                this.Aa = nh(e),
                this.Ra = new ad(this.Aa)
            }
            get Va() {
                return this.Ta
            }
            ma(e, t) {
                let n = t ? t.fa : new af
                  , r = t ? t.Ra : this.Ra
                  , i = t ? t.mutatedKeys : this.mutatedKeys
                  , s = r
                  , a = !1
                  , o = "F" === this.query.limitType && r.size === this.query.limit ? r.last() : null
                  , l = "L" === this.query.limitType && r.size === this.query.limit ? r.first() : null;
                if (e.inorderTraversal( (e, t) => {
                    let u = r.get(e)
                      , c = nu(this.query, t) ? t : null
                      , h = !!u && this.mutatedKeys.has(u.key)
                      , d = !!c && (c.hasLocalMutations || this.mutatedKeys.has(c.key) && c.hasCommittedMutations)
                      , f = !1;
                    u && c ? u.data.isEqual(c.data) ? h !== d && (n.track({
                        type: 3,
                        doc: c
                    }),
                    f = !0) : this.ga(u, c) || (n.track({
                        type: 2,
                        doc: c
                    }),
                    f = !0,
                    (o && this.Aa(c, o) > 0 || l && 0 > this.Aa(c, l)) && (a = !0)) : !u && c ? (n.track({
                        type: 0,
                        doc: c
                    }),
                    f = !0) : u && !c && (n.track({
                        type: 1,
                        doc: u
                    }),
                    f = !0,
                    (o || l) && (a = !0)),
                    f && (c ? (s = s.add(c),
                    i = d ? i.add(e) : i.delete(e)) : (s = s.delete(e),
                    i = i.delete(e)))
                }
                ),
                null !== this.query.limit)
                    for (; s.size > this.query.limit; ) {
                        let e = "F" === this.query.limitType ? s.last() : s.first();
                        s = s.delete(e.key),
                        i = i.delete(e.key),
                        n.track({
                            type: 1,
                            doc: e
                        })
                    }
                return {
                    Ra: s,
                    fa: n,
                    ns: a,
                    mutatedKeys: i
                }
            }
            ga(e, t) {
                return e.hasLocalMutations && t.hasCommittedMutations && !t.hasLocalMutations
            }
            applyChanges(e, t, n, r) {
                let i = this.Ra;
                this.Ra = e.Ra,
                this.mutatedKeys = e.mutatedKeys;
                let s = e.fa.G_();
                s.sort( (e, t) => (function(e, t) {
                    let n = e => {
                        switch (e) {
                        case 0:
                            return 1;
                        case 2:
                        case 3:
                            return 2;
                        case 1:
                            return 0;
                        default:
                            return S()
                        }
                    }
                    ;
                    return n(e) - n(t)
                }
                )(e.type, t.type) || this.Aa(e.doc, t.doc)),
                this.pa(n),
                r = null != r && r;
                let a = t && !r ? this.ya() : []
                  , o = 0 === this.da.size && this.current && !r ? 1 : 0
                  , l = o !== this.Ea;
                return (this.Ea = o,
                0 !== s.length || l) ? {
                    snapshot: new am(this.query,e.Ra,i,s,e.mutatedKeys,0 === o,l,!1,!!n && n.resumeToken.approximateByteSize() > 0),
                    wa: a
                } : {
                    wa: a
                }
            }
            Z_(e) {
                return this.current && "Offline" === e ? (this.current = !1,
                this.applyChanges({
                    Ra: this.Ra,
                    fa: new af,
                    mutatedKeys: this.mutatedKeys,
                    ns: !1
                }, !1)) : {
                    wa: []
                }
            }
            Sa(e) {
                return !this.Ta.has(e) && !!this.Ra.has(e) && !this.Ra.get(e).hasLocalMutations
            }
            pa(e) {
                e && (e.addedDocuments.forEach(e => this.Ta = this.Ta.add(e)),
                e.modifiedDocuments.forEach(e => {}
                ),
                e.removedDocuments.forEach(e => this.Ta = this.Ta.delete(e)),
                this.current = e.current)
            }
            ya() {
                if (!this.current)
                    return [];
                let e = this.da;
                this.da = n_(),
                this.Ra.forEach(e => {
                    this.Sa(e.key) && (this.da = this.da.add(e.key))
                }
                );
                let t = [];
                return e.forEach(e => {
                    this.da.has(e) || t.push(new aN(e))
                }
                ),
                this.da.forEach(n => {
                    e.has(n) || t.push(new aC(n))
                }
                ),
                t
            }
            ba(e) {
                this.Ta = e.Ts,
                this.da = n_();
                let t = this.ma(e.documents);
                return this.applyChanges(t, !0)
            }
            Da() {
                return am.fromInitialDocuments(this.query, this.Ra, this.mutatedKeys, 0 === this.Ea, this.hasCachedResults)
            }
        }
        class aA {
            constructor(e, t, n) {
                this.query = e,
                this.targetId = t,
                this.view = n
            }
        }
        class aR {
            constructor(e) {
                this.key = e,
                this.va = !1
            }
        }
        class aF {
            constructor(e, t, n, r, i, s) {
                this.localStore = e,
                this.remoteStore = t,
                this.eventManager = n,
                this.sharedClientState = r,
                this.currentUser = i,
                this.maxConcurrentLimboResolutions = s,
                this.Ca = {},
                this.Fa = new nd(e => no(e),na),
                this.Ma = new Map,
                this.xa = new Set,
                this.Oa = new e0(W.comparator),
                this.Na = new Map,
                this.La = new iX,
                this.Ba = {},
                this.ka = new Map,
                this.qa = iC.kn(),
                this.onlineState = "Unknown",
                this.Qa = void 0
            }
            get isPrimaryClient() {
                return !0 === this.Qa
            }
        }
        async function aV(e, t, n=!0) {
            let r;
            let i = ot(e)
              , s = i.Fa.get(t);
            return s ? (i.sharedClientState.addLocalQueryTarget(s.targetId),
            r = s.view.Da()) : r = await aO(i, t, n, !0),
            r
        }
        async function aM(e, t) {
            let n = ot(e);
            await aO(n, t, !0, !1)
        }
        async function aO(e, t, n, r) {
            let i;
            let s = await sd(e.localStore, nt(t))
              , a = s.targetId
              , o = e.sharedClientState.addLocalQueryTarget(a, n);
            return r && (i = await aL(e, t, a, "current" === o, s.resumeToken)),
            e.isPrimaryClient && n && sH(e.remoteStore, s),
            i
        }
        async function aL(e, t, n, r, i) {
            e.Ka = (t, n, r) => (async function(e, t, n, r) {
                let i = t.view.ma(n);
                i.ns && (i = await sm(e.localStore, t.query, !1).then( ({documents: e}) => t.view.ma(e, i)));
                let s = r && r.targetChanges.get(t.targetId)
                  , a = r && null != r.targetMismatches.get(t.targetId)
                  , o = t.view.applyChanges(i, e.isPrimaryClient, s, a);
                return aY(e, t.targetId, o.wa),
                o.snapshot
            }
            )(e, t, n, r);
            let s = await sm(e.localStore, t, !0)
              , a = new ak(t,s.Ts)
              , o = a.ma(s.documents)
              , l = rt.createSynthesizedTargetChangeForCurrentChange(n, r && "Offline" !== e.onlineState, i)
              , u = a.applyChanges(o, e.isPrimaryClient, l);
            aY(e, n, u.wa);
            let c = new aA(t,n,a);
            return e.Fa.set(t, c),
            e.Ma.has(n) ? e.Ma.get(n).push(t) : e.Ma.set(n, [t]),
            u.snapshot
        }
        async function aP(e, t, n) {
            let r = e.Fa.get(t)
              , i = e.Ma.get(r.targetId);
            if (i.length > 1)
                return e.Ma.set(r.targetId, i.filter(e => !na(e, t))),
                void e.Fa.delete(t);
            e.isPrimaryClient ? (e.sharedClientState.removeLocalQueryTarget(r.targetId),
            e.sharedClientState.isActiveQueryTarget(r.targetId) || await sf(e.localStore, r.targetId, !1).then( () => {
                e.sharedClientState.clearQueryState(r.targetId),
                n && sY(e.remoteStore, r.targetId),
                aJ(e, r.targetId)
            }
            ).catch(eo)) : (aJ(e, r.targetId),
            await sf(e.localStore, r.targetId, !0))
        }
        async function aq(e, t) {
            let n = e.Fa.get(t)
              , r = e.Ma.get(n.targetId);
            e.isPrimaryClient && 1 === r.length && (e.sharedClientState.removeLocalQueryTarget(n.targetId),
            sY(e.remoteStore, n.targetId))
        }
        async function aU(e, t, n) {
            let r = on(e);
            try {
                var i;
                let e;
                let s = await function(e, t) {
                    let n, r;
                    let i = z.now()
                      , s = t.reduce( (e, t) => e.add(t.key), n_());
                    return e.persistence.runTransaction("Locally write mutations", "readwrite", a => {
                        let o = nf
                          , l = n_();
                        return e.cs.getEntries(a, s).next(e => {
                            (o = e).forEach( (e, t) => {
                                t.isValidDocument() || (l = l.add(e))
                            }
                            )
                        }
                        ).next( () => e.localDocuments.getOverlayedDocuments(a, o)).next(r => {
                            n = r;
                            let s = [];
                            for (let e of t) {
                                let t = function(e, t) {
                                    let n = null;
                                    for (let r of e.fieldTransforms) {
                                        let e = t.data.field(r.field)
                                          , i = nx(r.transform, e || null);
                                        null != i && (null === n && (n = tk.empty()),
                                        n.set(r.field, i))
                                    }
                                    return n || null
                                }(e, n.get(e.key).overlayedDocument);
                                null != t && s.push(new nG(e.key,t,function e(t) {
                                    let n = [];
                                    return eY(t.fields, (t, r) => {
                                        let i = new j([t]);
                                        if (tT(r)) {
                                            let t = e(r.mapValue).fields;
                                            if (0 === t.length)
                                                n.push(i);
                                            else
                                                for (let e of t)
                                                    n.push(i.child(e))
                                        } else
                                            n.push(i)
                                    }
                                    ),
                                    new e3(n)
                                }(t.value.mapValue),nL.exists(!0)))
                            }
                            return e.mutationQueue.addMutationBatch(a, i, s, t)
                        }
                        ).next(t => {
                            r = t;
                            let i = t.applyToLocalDocumentSet(n, l);
                            return e.documentOverlayCache.saveOverlays(a, t.batchId, i)
                        }
                        )
                    }
                    ).then( () => ({
                        batchId: r.batchId,
                        changes: np(n)
                    }))
                }(r.localStore, t);
                r.sharedClientState.addPendingMutation(s.batchId),
                i = s.batchId,
                (e = r.Ba[r.currentUser.toKey()]) || (e = new e0(U)),
                e = e.insert(i, n),
                r.Ba[r.currentUser.toKey()] = e,
                await aZ(r, s.changes),
                await s7(r.remoteStore)
            } catch (t) {
                let e = ah(t, "Failed to persist write");
                n.reject(e)
            }
        }
        async function aB(e, t) {
            try {
                let n = await function(e, t) {
                    let n = t.snapshotVersion
                      , r = e.os;
                    return e.persistence.runTransaction("Apply remote event", "readwrite-primary", i => {
                        let s = e.cs.newChangeBuffer({
                            trackRemovals: !0
                        });
                        r = e.os;
                        let a = [];
                        t.targetChanges.forEach( (s, o) => {
                            var l;
                            let u = r.get(o);
                            if (!u)
                                return;
                            a.push(e.Ur.removeMatchingKeys(i, s.removedDocuments, o).next( () => e.Ur.addMatchingKeys(i, s.addedDocuments, o)));
                            let c = u.withSequenceNumber(i.currentSequenceNumber);
                            null !== t.targetMismatches.get(o) ? c = c.withResumeToken(e7.EMPTY_BYTE_STRING, K.min()).withLastLimboFreeSnapshotVersion(K.min()) : s.resumeToken.approximateByteSize() > 0 && (c = c.withResumeToken(s.resumeToken, n)),
                            r = r.insert(o, c),
                            l = c,
                            (0 === u.resumeToken.approximateByteSize() || l.snapshotVersion.toMicroseconds() - u.snapshotVersion.toMicroseconds() >= 3e8 || s.addedDocuments.size + s.modifiedDocuments.size + s.removedDocuments.size > 0) && a.push(e.Ur.updateTargetData(i, c))
                        }
                        );
                        let o = nf
                          , l = n_();
                        if (t.documentUpdates.forEach(n => {
                            t.resolvedLimboDocuments.has(n) && a.push(e.persistence.referenceDelegate.updateLimboDocument(i, n))
                        }
                        ),
                        a.push(sh(i, s, t.documentUpdates).next(e => {
                            o = e.Ps,
                            l = e.Is
                        }
                        )),
                        !n.isEqual(K.min())) {
                            let t = e.Ur.getLastRemoteSnapshotVersion(i).next(t => e.Ur.setTargetsMetadata(i, i.currentSequenceNumber, n));
                            a.push(t)
                        }
                        return el.waitFor(a).next( () => s.apply(i)).next( () => e.localDocuments.getLocalViewOfDocuments(i, o, l)).next( () => o)
                    }
                    ).then(t => (e.os = r,
                    t))
                }(e.localStore, t);
                t.targetChanges.forEach( (t, n) => {
                    let r = e.Na.get(n);
                    r && (t.addedDocuments.size + t.modifiedDocuments.size + t.removedDocuments.size <= 1 || S(),
                    t.addedDocuments.size > 0 ? r.va = !0 : t.modifiedDocuments.size > 0 ? r.va || S() : t.removedDocuments.size > 0 && (r.va || S(),
                    r.va = !1))
                }
                ),
                await aZ(e, n, t)
            } catch (e) {
                await eo(e)
            }
        }
        function az(e, t, n) {
            var r;
            if (e.isPrimaryClient && 0 === n || !e.isPrimaryClient && 1 === n) {
                let n;
                let i = [];
                e.Fa.forEach( (e, n) => {
                    let r = n.view.Z_(t);
                    r.snapshot && i.push(r.snapshot)
                }
                ),
                (r = e.eventManager).onlineState = t,
                n = !1,
                r.queries.forEach( (e, r) => {
                    for (let e of r.j_)
                        e.Z_(t) && (n = !0)
                }
                ),
                n && ab(r),
                i.length && e.Ca.d_(i),
                e.onlineState = t,
                e.isPrimaryClient && e.sharedClientState.setOnlineState(t)
            }
        }
        async function aK(e, t, n) {
            e.sharedClientState.updateQueryState(t, "rejected", n);
            let r = e.Na.get(t)
              , i = r && r.key;
            if (i) {
                let n = new e0(W.comparator);
                n = n.insert(i, tA.newNoDocument(i, K.min()));
                let r = n_().add(i)
                  , s = new re(K.min(),new Map,new e0(U),n,r);
                await aB(e, s),
                e.Oa = e.Oa.remove(i),
                e.Na.delete(t),
                aX(e)
            } else
                await sf(e.localStore, t, !1).then( () => aJ(e, t, n)).catch(eo)
        }
        async function aG(e, t) {
            var n;
            let r = t.batch.batchId;
            try {
                let i = await (n = e.localStore).persistence.runTransaction("Acknowledge batch", "readwrite-primary", e => {
                    let r = t.batch.keys()
                      , i = n.cs.newChangeBuffer({
                        trackRemovals: !0
                    });
                    return (function(e, t, n, r) {
                        let i = n.batch
                          , s = i.keys()
                          , a = el.resolve();
                        return s.forEach(e => {
                            a = a.next( () => r.getEntry(t, e)).next(t => {
                                let s = n.docVersions.get(e);
                                null !== s || S(),
                                0 > t.version.compareTo(s) && (i.applyToRemoteDocument(t, n),
                                t.isValidDocument() && (t.setReadTime(n.commitVersion),
                                r.addEntry(t)))
                            }
                            )
                        }
                        ),
                        a.next( () => e.mutationQueue.removeMutationBatch(t, i))
                    }
                    )(n, e, t, i).next( () => i.apply(e)).next( () => n.mutationQueue.performConsistencyCheck(e)).next( () => n.documentOverlayCache.removeOverlaysForBatchId(e, r, t.batch.batchId)).next( () => n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(e, function(e) {
                        let t = n_();
                        for (let n = 0; n < e.mutationResults.length; ++n)
                            e.mutationResults[n].transformResults.length > 0 && (t = t.add(e.batch.mutations[n].key));
                        return t
                    }(t))).next( () => n.localDocuments.getDocuments(e, r))
                }
                );
                aW(e, r, null),
                aj(e, r),
                e.sharedClientState.updateMutationState(r, "acknowledged"),
                await aZ(e, i)
            } catch (e) {
                await eo(e)
            }
        }
        async function a$(e, t, n) {
            var r;
            try {
                let i = await (r = e.localStore).persistence.runTransaction("Reject batch", "readwrite-primary", e => {
                    let n;
                    return r.mutationQueue.lookupMutationBatch(e, t).next(t => (null !== t || S(),
                    n = t.keys(),
                    r.mutationQueue.removeMutationBatch(e, t))).next( () => r.mutationQueue.performConsistencyCheck(e)).next( () => r.documentOverlayCache.removeOverlaysForBatchId(e, n, t)).next( () => r.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(e, n)).next( () => r.localDocuments.getDocuments(e, n))
                }
                );
                aW(e, t, n),
                aj(e, t),
                e.sharedClientState.updateMutationState(t, "rejected", n),
                await aZ(e, i)
            } catch (e) {
                await eo(e)
            }
        }
        async function aQ(e, t) {
            var n;
            s2(e.remoteStore) || I("SyncEngine", "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled.");
            try {
                let r = await (n = e.localStore).persistence.runTransaction("Get highest unacknowledged batch id", "readonly", e => n.mutationQueue.getHighestUnacknowledgedBatchId(e));
                if (-1 === r)
                    return void t.resolve();
                let i = e.ka.get(r) || [];
                i.push(t),
                e.ka.set(r, i)
            } catch (n) {
                let e = ah(n, "Initialization of waitForPendingWrites() operation failed");
                t.reject(e)
            }
        }
        function aj(e, t) {
            (e.ka.get(t) || []).forEach(e => {
                e.resolve()
            }
            ),
            e.ka.delete(t)
        }
        function aW(e, t, n) {
            let r = e.Ba[e.currentUser.toKey()];
            if (r) {
                let i = r.get(t);
                i && (n ? i.reject(n) : i.resolve(),
                r = r.remove(t)),
                e.Ba[e.currentUser.toKey()] = r
            }
        }
        function aJ(e, t, n=null) {
            for (let r of (e.sharedClientState.removeLocalQueryTarget(t),
            e.Ma.get(t)))
                e.Fa.delete(r),
                n && e.Ca.$a(r, n);
            e.Ma.delete(t),
            e.isPrimaryClient && e.La.gr(t).forEach(t => {
                e.La.containsKey(t) || aH(e, t)
            }
            )
        }
        function aH(e, t) {
            e.xa.delete(t.path.canonicalString());
            let n = e.Oa.get(t);
            null !== n && (sY(e.remoteStore, n),
            e.Oa = e.Oa.remove(t),
            e.Na.delete(n),
            aX(e))
        }
        function aY(e, t, n) {
            for (let r of n)
                r instanceof aC ? (e.La.addReference(r.key, t),
                function(e, t) {
                    let n = t.key
                      , r = n.path.canonicalString();
                    e.Oa.get(n) || e.xa.has(r) || (I("SyncEngine", "New document in limbo: " + n),
                    e.xa.add(r),
                    aX(e))
                }(e, r)) : r instanceof aN ? (I("SyncEngine", "Document no longer in limbo: " + r.key),
                e.La.removeReference(r.key, t),
                e.La.containsKey(r.key) || aH(e, r.key)) : S()
        }
        function aX(e) {
            for (; e.xa.size > 0 && e.Oa.size < e.maxConcurrentLimboResolutions; ) {
                let t = e.xa.values().next().value;
                e.xa.delete(t);
                let n = new W($.fromString(t))
                  , r = e.qa.next();
                e.Na.set(r, new aR(n)),
                e.Oa = e.Oa.insert(n, r),
                sH(e.remoteStore, new rL(nt(t6(n.path)),r,"TargetPurposeLimboResolution",eI.oe))
            }
        }
        async function aZ(e, t, n) {
            let r = []
              , i = []
              , s = [];
            e.Fa.isEmpty() || (e.Fa.forEach( (a, o) => {
                s.push(e.Ka(o, t, n).then(t => {
                    var s;
                    if ((t || n) && e.isPrimaryClient) {
                        let r = t ? !t.fromCache : null === (s = null == n ? void 0 : n.targetChanges.get(o.targetId)) || void 0 === s ? void 0 : s.current;
                        e.sharedClientState.updateQueryState(o.targetId, r ? "current" : "not-current")
                    }
                    if (t) {
                        r.push(t);
                        let e = ss.Wi(o.targetId, t);
                        i.push(e)
                    }
                }
                ))
            }
            ),
            await Promise.all(s),
            e.Ca.d_(r),
            await async function(e, t) {
                try {
                    await e.persistence.runTransaction("notifyLocalViewChanges", "readwrite", n => el.forEach(t, t => el.forEach(t.$i, r => e.persistence.referenceDelegate.addReference(n, t.targetId, r)).next( () => el.forEach(t.Ui, r => e.persistence.referenceDelegate.removeReference(n, t.targetId, r)))))
                } catch (e) {
                    if (!em(e))
                        throw e;
                    I("LocalStore", "Failed to update sequence numbers: " + e)
                }
                for (let n of t) {
                    let t = n.targetId;
                    if (!n.fromCache) {
                        let n = e.os.get(t)
                          , r = n.snapshotVersion
                          , i = n.withLastLimboFreeSnapshotVersion(r);
                        e.os = e.os.insert(t, i)
                    }
                }
            }(e.localStore, i))
        }
        async function a0(e, t) {
            var n;
            if (!e.currentUser.isEqual(t)) {
                I("SyncEngine", "User change. New user:", t.toKey());
                let r = await su(e.localStore, t);
                e.currentUser = t,
                n = "'waitForPendingWrites' promise is rejected due to a user change.",
                e.ka.forEach(e => {
                    e.forEach(e => {
                        e.reject(new C(D.CANCELLED,n))
                    }
                    )
                }
                ),
                e.ka.clear(),
                e.sharedClientState.handleUserChange(t, r.removedBatchIds, r.addedBatchIds),
                await aZ(e, r.hs)
            }
        }
        function a1(e, t) {
            let n = e.Na.get(t);
            if (n && n.va)
                return n_().add(n.key);
            {
                let n = n_()
                  , r = e.Ma.get(t);
                if (!r)
                    return n;
                for (let t of r) {
                    let r = e.Fa.get(t);
                    n = n.unionWith(r.view.Va)
                }
                return n
            }
        }
        async function a2(e, t) {
            let n = await sm(e.localStore, t.query, !0)
              , r = t.view.ba(n);
            return e.isPrimaryClient && aY(e, t.targetId, r.wa),
            r
        }
        async function a5(e, t) {
            return sp(e.localStore, t).then(t => aZ(e, t))
        }
        async function a4(e, t, n, r) {
            let i = await function(e, t) {
                let n = e.mutationQueue;
                return e.persistence.runTransaction("Lookup mutation documents", "readonly", r => n.Mn(r, t).next(t => t ? e.localDocuments.getDocuments(r, t) : el.resolve(null)))
            }(e.localStore, t);
            null !== i ? ("pending" === n ? await s7(e.remoteStore) : "acknowledged" === n || "rejected" === n ? (aW(e, t, r || null),
            aj(e, t),
            function(e, t) {
                e.mutationQueue.On(t)
            }(e.localStore, t)) : S(),
            await aZ(e, i)) : I("SyncEngine", "Cannot apply mutation batch with id: " + t)
        }
        async function a8(e, t) {
            if (ot(e),
            on(e),
            !0 === t && !0 !== e.Qa) {
                let t = e.sharedClientState.getAllActiveQueryTargets()
                  , n = await a3(e, t.toArray());
                for (let t of (e.Qa = !0,
                await ao(e.remoteStore, !0),
                n))
                    sH(e.remoteStore, t)
            } else if (!1 === t && !1 !== e.Qa) {
                let t = []
                  , n = Promise.resolve();
                e.Ma.forEach( (r, i) => {
                    e.sharedClientState.isLocalQueryTarget(i) ? t.push(i) : n = n.then( () => (aJ(e, i),
                    sf(e.localStore, i, !0))),
                    sY(e.remoteStore, i)
                }
                ),
                await n,
                await a3(e, t),
                e.Na.forEach( (t, n) => {
                    sY(e.remoteStore, n)
                }
                ),
                e.La.pr(),
                e.Na = new Map,
                e.Oa = new e0(W.comparator),
                e.Qa = !1,
                await ao(e.remoteStore, !1)
            }
        }
        async function a3(e, t, n) {
            let r = []
              , i = [];
            for (let n of t) {
                let t;
                let s = e.Ma.get(n);
                if (s && 0 !== s.length)
                    for (let n of (t = await sd(e.localStore, nt(s[0])),
                    s)) {
                        let t = e.Fa.get(n)
                          , r = await a2(e, t);
                        r.snapshot && i.push(r.snapshot)
                    }
                else {
                    let r = await sg(e.localStore, n);
                    t = await sd(e.localStore, r),
                    await aL(e, a6(r), n, !1, t.resumeToken)
                }
                r.push(t)
            }
            return e.Ca.d_(i),
            r
        }
        function a6(e) {
            var t, n, r, i;
            return t = e.path,
            n = e.collectionGroup,
            r = e.orderBy,
            i = e.filters,
            new t3(t,n,r,i,e.limit,"F",e.startAt,e.endAt)
        }
        function a9(e) {
            return e.localStore.persistence.Qi()
        }
        async function a7(e, t, n, r) {
            if (e.Qa)
                return void I("SyncEngine", "Ignoring unexpected query state notification.");
            let i = e.Ma.get(t);
            if (i && i.length > 0)
                switch (n) {
                case "current":
                case "not-current":
                    {
                        let r = await sp(e.localStore, nc(i[0]))
                          , s = re.createSynthesizedRemoteEventForCurrentChange(t, "current" === n, e7.EMPTY_BYTE_STRING);
                        await aZ(e, r, s);
                        break
                    }
                case "rejected":
                    await sf(e.localStore, t, !0),
                    aJ(e, t, r);
                    break;
                default:
                    S()
                }
        }
        async function oe(e, t, n) {
            let r = ot(e);
            if (r.Qa) {
                for (let e of t) {
                    if (r.Ma.has(e) && r.sharedClientState.isActiveQueryTarget(e)) {
                        I("SyncEngine", "Adding an already active target " + e);
                        continue
                    }
                    let t = await sg(r.localStore, e)
                      , n = await sd(r.localStore, t);
                    await aL(r, a6(t), n.targetId, !1, n.resumeToken),
                    sH(r.remoteStore, n)
                }
                for (let e of n)
                    r.Ma.has(e) && await sf(r.localStore, e, !1).then( () => {
                        sY(r.remoteStore, e),
                        aJ(r, e)
                    }
                    ).catch(eo)
            }
        }
        function ot(e) {
            return e.remoteStore.remoteSyncer.applyRemoteEvent = aB.bind(null, e),
            e.remoteStore.remoteSyncer.getRemoteKeysForTarget = a1.bind(null, e),
            e.remoteStore.remoteSyncer.rejectListen = aK.bind(null, e),
            e.Ca.d_ = a_.bind(null, e.eventManager),
            e.Ca.$a = aI.bind(null, e.eventManager),
            e
        }
        function on(e) {
            return e.remoteStore.remoteSyncer.applySuccessfulWrite = aG.bind(null, e),
            e.remoteStore.remoteSyncer.rejectFailedWrite = a$.bind(null, e),
            e
        }
        class or {
            constructor() {
                this.kind = "memory",
                this.synchronizeTabs = !1
            }
            async initialize(e) {
                this.serializer = sU(e.databaseInfo.databaseId),
                this.sharedClientState = this.Wa(e),
                this.persistence = this.Ga(e),
                await this.persistence.start(),
                this.localStore = this.za(e),
                this.gcScheduler = this.ja(e, this.localStore),
                this.indexBackfillerScheduler = this.Ha(e, this.localStore)
            }
            ja(e, t) {
                return null
            }
            Ha(e, t) {
                return null
            }
            za(e) {
                var t;
                return t = this.persistence,
                new sl(t,new so,e.initialUser,this.serializer)
            }
            Ga(e) {
                return new i4(i3.Zr,this.serializer)
            }
            Wa(e) {
                return new sN
            }
            async terminate() {
                var e, t;
                null === (e = this.gcScheduler) || void 0 === e || e.stop(),
                null === (t = this.indexBackfillerScheduler) || void 0 === t || t.stop(),
                this.sharedClientState.shutdown(),
                await this.persistence.shutdown()
            }
        }
        or.provider = {
            build: () => new or
        };
        class oi extends or {
            constructor(e) {
                super(),
                this.cacheSizeBytes = e
            }
            ja(e, t) {
                return this.persistence.referenceDelegate instanceof i6 || S(),
                new iM(this.persistence.referenceDelegate.garbageCollector,e.asyncQueue,t)
            }
            Ga(e) {
                let t = void 0 !== this.cacheSizeBytes ? i_.withCacheSize(this.cacheSizeBytes) : i_.DEFAULT;
                return new i4(e => i6.Zr(e, t),this.serializer)
            }
        }
        class os extends or {
            constructor(e, t, n) {
                super(),
                this.Ja = e,
                this.cacheSizeBytes = t,
                this.forceOwnership = n,
                this.kind = "persistent",
                this.synchronizeTabs = !1
            }
            async initialize(e) {
                await super.initialize(e),
                await this.Ja.initialize(this, e),
                await on(this.Ja.syncEngine),
                await s7(this.Ja.remoteStore),
                await this.persistence.yi( () => (this.gcScheduler && !this.gcScheduler.started && this.gcScheduler.start(),
                this.indexBackfillerScheduler && !this.indexBackfillerScheduler.started && this.indexBackfillerScheduler.start(),
                Promise.resolve()))
            }
            za(e) {
                var t;
                return t = this.persistence,
                new sl(t,new so,e.initialUser,this.serializer)
            }
            ja(e, t) {
                return new iM(this.persistence.referenceDelegate.garbageCollector,e.asyncQueue,t)
            }
            Ha(e, t) {
                let n = new e_(t,this.persistence);
                return new ev(e.asyncQueue,n)
            }
            Ga(e) {
                let t = si(e.databaseInfo.databaseId, e.databaseInfo.persistenceKey)
                  , n = void 0 !== this.cacheSizeBytes ? i_.withCacheSize(this.cacheSizeBytes) : i_.DEFAULT;
                return new st(this.synchronizeTabs,t,e.clientId,n,e.asyncQueue,sP(),sq(),this.serializer,this.sharedClientState,!!this.forceOwnership)
            }
            Wa(e) {
                return new sN
            }
        }
        class oa extends os {
            constructor(e, t) {
                super(e, t, !1),
                this.Ja = e,
                this.cacheSizeBytes = t,
                this.synchronizeTabs = !0
            }
            async initialize(e) {
                await super.initialize(e);
                let t = this.Ja.syncEngine;
                this.sharedClientState instanceof sC && (this.sharedClientState.syncEngine = {
                    no: a4.bind(null, t),
                    ro: a7.bind(null, t),
                    io: oe.bind(null, t),
                    Qi: a9.bind(null, t),
                    eo: a5.bind(null, t)
                },
                await this.sharedClientState.start()),
                await this.persistence.yi(async e => {
                    await a8(this.Ja.syncEngine, e),
                    this.gcScheduler && (e && !this.gcScheduler.started ? this.gcScheduler.start() : e || this.gcScheduler.stop()),
                    this.indexBackfillerScheduler && (e && !this.indexBackfillerScheduler.started ? this.indexBackfillerScheduler.start() : e || this.indexBackfillerScheduler.stop())
                }
                )
            }
            Wa(e) {
                let t = sP();
                if (!sC.D(t))
                    throw new C(D.UNIMPLEMENTED,"IndexedDB persistence is only available on platforms that support LocalStorage.");
                let n = si(e.databaseInfo.databaseId, e.databaseInfo.persistenceKey);
                return new sC(t,e.asyncQueue,n,e.clientId,e.initialUser)
            }
        }
        class oo {
            async initialize(e, t) {
                this.localStore || (this.localStore = e.localStore,
                this.sharedClientState = e.sharedClientState,
                this.datastore = this.createDatastore(t),
                this.remoteStore = this.createRemoteStore(t),
                this.eventManager = this.createEventManager(t),
                this.syncEngine = this.createSyncEngine(t, !e.synchronizeTabs),
                this.sharedClientState.onlineStateHandler = e => az(this.syncEngine, e, 1),
                this.remoteStore.remoteSyncer.handleCredentialChange = a0.bind(null, this.syncEngine),
                await ao(this.remoteStore, this.syncEngine.isPrimaryClient))
            }
            createEventManager(e) {
                return new ap
            }
            createDatastore(e) {
                let t = sU(e.databaseInfo.databaseId)
                  , n = new sL(e.databaseInfo);
                return new s$(e.authCredentials,e.appCheckCredentials,n,t)
            }
            createRemoteStore(e) {
                var t;
                return t = this.localStore,
                new sj(t,this.datastore,e.asyncQueue,e => az(this.syncEngine, e, 0),sA.D() ? new sA : new sk)
            }
            createSyncEngine(e, t) {
                return function(e, t, n, r, i, s, a) {
                    let o = new aF(e,t,n,r,i,s);
                    return a && (o.Qa = !0),
                    o
                }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, e.initialUser, e.maxConcurrentLimboResolutions, t)
            }
            async terminate() {
                var e, t;
                await async function(e) {
                    I("RemoteStore", "RemoteStore shutting down."),
                    e.L_.add(5),
                    await sJ(e),
                    e.k_.shutdown(),
                    e.q_.set("Unknown")
                }(this.remoteStore),
                null === (e = this.datastore) || void 0 === e || e.terminate(),
                null === (t = this.eventManager) || void 0 === t || t.terminate()
            }
        }
        function ol(e, t=10240) {
            let n = 0;
            return {
                async read() {
                    if (n < e.byteLength) {
                        let r = {
                            value: e.slice(n, n + t),
                            done: !1
                        };
                        return n += t,
                        r
                    }
                    return {
                        done: !0
                    }
                },
                async cancel() {},
                releaseLock() {},
                closed: Promise.resolve()
            }
        }
        oo.provider = {
            build: () => new oo
        };
        class ou {
            constructor(e) {
                this.observer = e,
                this.muted = !1
            }
            next(e) {
                this.muted || this.observer.next && this.Ya(this.observer.next, e)
            }
            error(e) {
                this.muted || (this.observer.error ? this.Ya(this.observer.error, e) : b("Uncaught Error in snapshot listener:", e.toString()))
            }
            Za() {
                this.muted = !0
            }
            Ya(e, t) {
                setTimeout( () => {
                    this.muted || e(t)
                }
                , 0)
            }
        }
        class oc {
            constructor(e, t) {
                this.Xa = e,
                this.serializer = t,
                this.metadata = new N,
                this.buffer = new Uint8Array,
                this.eu = new TextDecoder("utf-8"),
                this.tu().then(e => {
                    e && e.ua() ? this.metadata.resolve(e.aa.metadata) : this.metadata.reject(Error(`The first element of the bundle is not a metadata, it is
             ${JSON.stringify(null == e ? void 0 : e.aa)}`))
                }
                , e => this.metadata.reject(e))
            }
            close() {
                return this.Xa.cancel()
            }
            async getMetadata() {
                return this.metadata.promise
            }
            async Ua() {
                return await this.getMetadata(),
                this.tu()
            }
            async tu() {
                let e = await this.nu();
                if (null === e)
                    return null;
                let t = this.eu.decode(e)
                  , n = Number(t);
                return isNaN(n) && this.ru(`length string (${t}) is not valid number`),
                new aE(JSON.parse(await this.iu(n)),e.length + n)
            }
            su() {
                return this.buffer.findIndex(e => 123 === e)
            }
            async nu() {
                for (; 0 > this.su() && !await this.ou(); )
                    ;
                if (0 === this.buffer.length)
                    return null;
                let e = this.su();
                e < 0 && this.ru("Reached the end of bundle when a length string is expected.");
                let t = this.buffer.slice(0, e);
                return this.buffer = this.buffer.slice(e),
                t
            }
            async iu(e) {
                for (; this.buffer.length < e; )
                    await this.ou() && this.ru("Reached the end of bundle when more is expected.");
                let t = this.eu.decode(this.buffer.slice(0, e));
                return this.buffer = this.buffer.slice(e),
                t
            }
            ru(e) {
                throw this.Xa.cancel(),
                Error(`Invalid bundle format: ${e}`)
            }
            async ou() {
                let e = await this.Xa.read();
                if (!e.done) {
                    let t = new Uint8Array(this.buffer.length + e.value.length);
                    t.set(this.buffer),
                    t.set(e.value, this.buffer.length),
                    this.buffer = t
                }
                return e.done
            }
        }
        class oh {
            constructor(e) {
                this.datastore = e,
                this.readVersions = new Map,
                this.mutations = [],
                this.committed = !1,
                this.lastTransactionError = null,
                this.writtenDocs = new Set
            }
            async lookup(e) {
                if (this.ensureCommitNotCalled(),
                this.mutations.length > 0)
                    throw this.lastTransactionError = new C(D.INVALID_ARGUMENT,"Firestore transactions require all reads to be executed before all writes."),
                    this.lastTransactionError;
                let t = await async function(e, t) {
                    let n = {
                        documents: t.map(t => r_(e.serializer, t))
                    }
                      , r = await e.Lo("BatchGetDocuments", e.serializer.databaseId, $.emptyPath(), n, t.length)
                      , i = new Map;
                    r.forEach(t => {
                        var n;
                        let r = (n = e.serializer,
                        "found"in t ? function(e, t) {
                            t.found || S(),
                            t.found.name,
                            t.found.updateTime;
                            let n = rI(e, t.found.name)
                              , r = rp(t.found.updateTime)
                              , i = t.found.createTime ? rp(t.found.createTime) : K.min()
                              , s = new tk({
                                mapValue: {
                                    fields: t.found.fields
                                }
                            });
                            return tA.newFoundDocument(n, r, i, s)
                        }(n, t) : "missing"in t ? function(e, t) {
                            t.missing || S(),
                            t.readTime || S();
                            let n = rI(e, t.missing)
                              , r = rp(t.readTime);
                            return tA.newNoDocument(n, r)
                        }(n, t) : S());
                        i.set(r.key.toString(), r)
                    }
                    );
                    let s = [];
                    return t.forEach(e => {
                        let t = i.get(e.toString());
                        t || S(),
                        s.push(t)
                    }
                    ),
                    s
                }(this.datastore, e);
                return t.forEach(e => this.recordVersion(e)),
                t
            }
            set(e, t) {
                this.write(t.toMutation(e, this.precondition(e))),
                this.writtenDocs.add(e.toString())
            }
            update(e, t) {
                try {
                    this.write(t.toMutation(e, this.preconditionForUpdate(e)))
                } catch (e) {
                    this.lastTransactionError = e
                }
                this.writtenDocs.add(e.toString())
            }
            delete(e) {
                this.write(new nW(e,this.precondition(e))),
                this.writtenDocs.add(e.toString())
            }
            async commit() {
                if (this.ensureCommitNotCalled(),
                this.lastTransactionError)
                    throw this.lastTransactionError;
                let e = this.readVersions;
                this.mutations.forEach(t => {
                    e.delete(t.key.toString())
                }
                ),
                e.forEach( (e, t) => {
                    let n = W.fromPath(t);
                    this.mutations.push(new nJ(n,this.precondition(n)))
                }
                ),
                await async function(e, t) {
                    let n = {
                        writes: t.map(t => rC(e.serializer, t))
                    };
                    await e.Mo("Commit", e.serializer.databaseId, $.emptyPath(), n)
                }(this.datastore, this.mutations),
                this.committed = !0
            }
            recordVersion(e) {
                let t;
                if (e.isFoundDocument())
                    t = e.version;
                else {
                    if (!e.isNoDocument())
                        throw S();
                    t = K.min()
                }
                let n = this.readVersions.get(e.key.toString());
                if (n) {
                    if (!t.isEqual(n))
                        throw new C(D.ABORTED,"Document version changed between two reads.")
                } else
                    this.readVersions.set(e.key.toString(), t)
            }
            precondition(e) {
                let t = this.readVersions.get(e.toString());
                return !this.writtenDocs.has(e.toString()) && t ? t.isEqual(K.min()) ? nL.exists(!1) : nL.updateTime(t) : nL.none()
            }
            preconditionForUpdate(e) {
                let t = this.readVersions.get(e.toString());
                if (!this.writtenDocs.has(e.toString()) && t) {
                    if (t.isEqual(K.min()))
                        throw new C(D.INVALID_ARGUMENT,"Can't update a document that doesn't exist.");
                    return nL.updateTime(t)
                }
                return nL.exists(!0)
            }
            write(e) {
                this.ensureCommitNotCalled(),
                this.mutations.push(e)
            }
            ensureCommitNotCalled() {}
        }
        class od {
            constructor(e, t, n, r, i) {
                this.asyncQueue = e,
                this.datastore = t,
                this.options = n,
                this.updateFunction = r,
                this.deferred = i,
                this._u = n.maxAttempts,
                this.t_ = new sB(this.asyncQueue,"transaction_retry")
            }
            au() {
                this._u -= 1,
                this.uu()
            }
            uu() {
                this.t_.Go(async () => {
                    let e = new oh(this.datastore)
                      , t = this.cu(e);
                    t && t.then(t => {
                        this.asyncQueue.enqueueAndForget( () => e.commit().then( () => {
                            this.deferred.resolve(t)
                        }
                        ).catch(e => {
                            this.lu(e)
                        }
                        ))
                    }
                    ).catch(e => {
                        this.lu(e)
                    }
                    )
                }
                )
            }
            cu(e) {
                try {
                    let t = this.updateFunction(e);
                    return !eb(t) && t.catch && t.then ? t : (this.deferred.reject(Error("Transaction callback must return a Promise")),
                    null)
                } catch (e) {
                    return this.deferred.reject(e),
                    null
                }
            }
            lu(e) {
                this._u > 0 && this.hu(e) ? (this._u -= 1,
                this.asyncQueue.enqueueAndForget( () => (this.uu(),
                Promise.resolve()))) : this.deferred.reject(e)
            }
            hu(e) {
                if ("FirebaseError" === e.name) {
                    let t = e.code;
                    return "aborted" === t || "failed-precondition" === t || "already-exists" === t || !n1(t)
                }
                return !1
            }
        }
        class of {
            constructor(e, t, n, r, i) {
                this.authCredentials = e,
                this.appCheckCredentials = t,
                this.asyncQueue = n,
                this.databaseInfo = r,
                this.user = p.UNAUTHENTICATED,
                this.clientId = q.newId(),
                this.authCredentialListener = () => Promise.resolve(),
                this.appCheckCredentialListener = () => Promise.resolve(),
                this._uninitializedComponentsProvider = i,
                this.authCredentials.start(n, async e => {
                    I("FirestoreClient", "Received user=", e.uid),
                    await this.authCredentialListener(e),
                    this.user = e
                }
                ),
                this.appCheckCredentials.start(n, e => (I("FirestoreClient", "Received new app check token=", e),
                this.appCheckCredentialListener(e, this.user)))
            }
            get configuration() {
                return {
                    asyncQueue: this.asyncQueue,
                    databaseInfo: this.databaseInfo,
                    clientId: this.clientId,
                    authCredentials: this.authCredentials,
                    appCheckCredentials: this.appCheckCredentials,
                    initialUser: this.user,
                    maxConcurrentLimboResolutions: 100
                }
            }
            setCredentialChangeListener(e) {
                this.authCredentialListener = e
            }
            setAppCheckTokenChangeListener(e) {
                this.appCheckCredentialListener = e
            }
            terminate() {
                this.asyncQueue.enterRestrictedMode();
                let e = new N;
                return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
                    try {
                        this._onlineComponents && await this._onlineComponents.terminate(),
                        this._offlineComponents && await this._offlineComponents.terminate(),
                        this.authCredentials.shutdown(),
                        this.appCheckCredentials.shutdown(),
                        e.resolve()
                    } catch (n) {
                        let t = ah(n, "Failed to shutdown persistence");
                        e.reject(t)
                    }
                }
                ),
                e.promise
            }
        }
        async function om(e, t) {
            e.asyncQueue.verifyOperationInProgress(),
            I("FirestoreClient", "Initializing OfflineComponentProvider");
            let n = e.configuration;
            await t.initialize(n);
            let r = n.initialUser;
            e.setCredentialChangeListener(async e => {
                r.isEqual(e) || (await su(t.localStore, e),
                r = e)
            }
            ),
            t.persistence.setDatabaseDeletedListener( () => e.terminate()),
            e._offlineComponents = t
        }
        async function og(e, t) {
            e.asyncQueue.verifyOperationInProgress();
            let n = await op(e);
            I("FirestoreClient", "Initializing OnlineComponentProvider"),
            await t.initialize(n, e.configuration),
            e.setCredentialChangeListener(e => aa(t.remoteStore, e)),
            e.setAppCheckTokenChangeListener( (e, n) => aa(t.remoteStore, n)),
            e._onlineComponents = t
        }
        async function op(e) {
            if (!e._offlineComponents) {
                if (e._uninitializedComponentsProvider) {
                    I("FirestoreClient", "Using user provided OfflineComponentProvider");
                    try {
                        await om(e, e._uninitializedComponentsProvider._offline)
                    } catch (t) {
                        if (!("FirebaseError" === t.name ? t.code === D.FAILED_PRECONDITION || t.code === D.UNIMPLEMENTED : !("undefined" != typeof DOMException && t instanceof DOMException) || 22 === t.code || 20 === t.code || 11 === t.code))
                            throw t;
                        T("Error using user provided cache. Falling back to memory cache: " + t),
                        await om(e, new or)
                    }
                } else
                    I("FirestoreClient", "Using default OfflineComponentProvider"),
                    await om(e, new or)
            }
            return e._offlineComponents
        }
        async function oy(e) {
            return e._onlineComponents || (e._uninitializedComponentsProvider ? (I("FirestoreClient", "Using user provided OnlineComponentProvider"),
            await og(e, e._uninitializedComponentsProvider._online)) : (I("FirestoreClient", "Using default OnlineComponentProvider"),
            await og(e, new oo))),
            e._onlineComponents
        }
        function ow(e) {
            return op(e).then(e => e.persistence)
        }
        function ov(e) {
            return op(e).then(e => e.localStore)
        }
        function o_(e) {
            return oy(e).then(e => e.remoteStore)
        }
        function oI(e) {
            return oy(e).then(e => e.syncEngine)
        }
        function ob(e) {
            return oy(e).then(e => e.datastore)
        }
        async function oT(e) {
            let t = await oy(e)
              , n = t.eventManager;
            return n.onListen = aV.bind(null, t.syncEngine),
            n.onUnlisten = aP.bind(null, t.syncEngine),
            n.onFirstRemoteStoreListen = aM.bind(null, t.syncEngine),
            n.onLastRemoteStoreUnlisten = aq.bind(null, t.syncEngine),
            n
        }
        function oE(e, t, n={}) {
            let r = new N;
            return e.asyncQueue.enqueueAndForget(async () => (function(e, t, n, r, i) {
                let s = new ou({
                    next: o => {
                        s.Za(),
                        t.enqueueAndForget( () => av(e, a));
                        let l = o.docs.has(n);
                        !l && o.fromCache ? i.reject(new C(D.UNAVAILABLE,"Failed to get document because the client is offline.")) : l && o.fromCache && r && "server" === r.source ? i.reject(new C(D.UNAVAILABLE,'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : i.resolve(o)
                    }
                    ,
                    error: e => i.reject(e)
                })
                  , a = new aT(t6(n.path),s,{
                    includeMetadataChanges: !0,
                    _a: !0
                });
                return aw(e, a)
            }
            )(await oT(e), e.asyncQueue, t, n, r)),
            r.promise
        }
        function oS(e, t, n={}) {
            let r = new N;
            return e.asyncQueue.enqueueAndForget(async () => (function(e, t, n, r, i) {
                let s = new ou({
                    next: n => {
                        s.Za(),
                        t.enqueueAndForget( () => av(e, a)),
                        n.fromCache && "server" === r.source ? i.reject(new C(D.UNAVAILABLE,'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : i.resolve(n)
                    }
                    ,
                    error: e => i.reject(e)
                })
                  , a = new aT(n,s,{
                    includeMetadataChanges: !0,
                    _a: !0
                });
                return aw(e, a)
            }
            )(await oT(e), e.asyncQueue, t, n, r)),
            r.promise
        }
        function ox(e) {
            let t = {};
            return void 0 !== e.timeoutSeconds && (t.timeoutSeconds = e.timeoutSeconds),
            t
        }
        let oD = new Map;
        function oC(e, t, n) {
            if (!n)
                throw new C(D.INVALID_ARGUMENT,`Function ${e}() cannot be called with an empty ${t}.`)
        }
        function oN(e, t, n, r) {
            if (!0 === t && !0 === r)
                throw new C(D.INVALID_ARGUMENT,`${e} and ${n} cannot be used together.`)
        }
        function ok(e) {
            if (!W.isDocumentKey(e))
                throw new C(D.INVALID_ARGUMENT,`Invalid document reference. Document references must have an even number of segments, but ${e} has ${e.length}.`)
        }
        function oA(e) {
            if (W.isDocumentKey(e))
                throw new C(D.INVALID_ARGUMENT,`Invalid collection reference. Collection references must have an odd number of segments, but ${e} has ${e.length}.`)
        }
        function oR(e) {
            if (void 0 === e)
                return "undefined";
            if (null === e)
                return "null";
            if ("string" == typeof e)
                return e.length > 20 && (e = `${e.substring(0, 20)}...`),
                JSON.stringify(e);
            if ("number" == typeof e || "boolean" == typeof e)
                return "" + e;
            if ("object" == typeof e) {
                if (e instanceof Array)
                    return "an array";
                {
                    var t;
                    let n = (t = e).constructor ? t.constructor.name : null;
                    return n ? `a custom ${n} object` : "an object"
                }
            }
            return "function" == typeof e ? "a function" : S()
        }
        function oF(e, t) {
            if ("_delegate"in e && (e = e._delegate),
            !(e instanceof t)) {
                if (t.name === e.constructor.name)
                    throw new C(D.INVALID_ARGUMENT,"Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
                {
                    let n = oR(e);
                    throw new C(D.INVALID_ARGUMENT,`Expected type '${t.name}', but it was: ${n}`)
                }
            }
            return e
        }
        function oV(e, t) {
            if (t <= 0)
                throw new C(D.INVALID_ARGUMENT,`Function ${e}() requires a positive number, but it was: ${t}.`)
        }
        class oM {
            constructor(e) {
                var t, n;
                if (void 0 === e.host) {
                    if (void 0 !== e.ssl)
                        throw new C(D.INVALID_ARGUMENT,"Can't provide ssl option if host option is not set");
                    this.host = "firestore.googleapis.com",
                    this.ssl = !0
                } else
                    this.host = e.host,
                    this.ssl = null === (t = e.ssl) || void 0 === t || t;
                if (this.credentials = e.credentials,
                this.ignoreUndefinedProperties = !!e.ignoreUndefinedProperties,
                this.localCache = e.localCache,
                void 0 === e.cacheSizeBytes)
                    this.cacheSizeBytes = 41943040;
                else {
                    if (-1 !== e.cacheSizeBytes && e.cacheSizeBytes < 1048576)
                        throw new C(D.INVALID_ARGUMENT,"cacheSizeBytes must be at least 1048576");
                    this.cacheSizeBytes = e.cacheSizeBytes
                }
                oN("experimentalForceLongPolling", e.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", e.experimentalAutoDetectLongPolling),
                this.experimentalForceLongPolling = !!e.experimentalForceLongPolling,
                this.experimentalForceLongPolling ? this.experimentalAutoDetectLongPolling = !1 : void 0 === e.experimentalAutoDetectLongPolling ? this.experimentalAutoDetectLongPolling = !0 : this.experimentalAutoDetectLongPolling = !!e.experimentalAutoDetectLongPolling,
                this.experimentalLongPollingOptions = ox(null !== (n = e.experimentalLongPollingOptions) && void 0 !== n ? n : {}),
                function(e) {
                    if (void 0 !== e.timeoutSeconds) {
                        if (isNaN(e.timeoutSeconds))
                            throw new C(D.INVALID_ARGUMENT,`invalid long polling timeout: ${e.timeoutSeconds} (must not be NaN)`);
                        if (e.timeoutSeconds < 5)
                            throw new C(D.INVALID_ARGUMENT,`invalid long polling timeout: ${e.timeoutSeconds} (minimum allowed value is 5)`);
                        if (e.timeoutSeconds > 30)
                            throw new C(D.INVALID_ARGUMENT,`invalid long polling timeout: ${e.timeoutSeconds} (maximum allowed value is 30)`)
                    }
                }(this.experimentalLongPollingOptions),
                this.useFetchStreams = !!e.useFetchStreams
            }
            isEqual(e) {
                var t, n;
                return this.host === e.host && this.ssl === e.ssl && this.credentials === e.credentials && this.cacheSizeBytes === e.cacheSizeBytes && this.experimentalForceLongPolling === e.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === e.experimentalAutoDetectLongPolling && (t = this.experimentalLongPollingOptions,
                n = e.experimentalLongPollingOptions,
                t.timeoutSeconds === n.timeoutSeconds) && this.ignoreUndefinedProperties === e.ignoreUndefinedProperties && this.useFetchStreams === e.useFetchStreams
            }
        }
        class oO {
            constructor(e, t, n, r) {
                this._authCredentials = e,
                this._appCheckCredentials = t,
                this._databaseId = n,
                this._app = r,
                this.type = "firestore-lite",
                this._persistenceKey = "(lite)",
                this._settings = new oM({}),
                this._settingsFrozen = !1,
                this._terminateTask = "notTerminated"
            }
            get app() {
                if (!this._app)
                    throw new C(D.FAILED_PRECONDITION,"Firestore was not initialized using the Firebase SDK. 'app' is not available");
                return this._app
            }
            get _initialized() {
                return this._settingsFrozen
            }
            get _terminated() {
                return "notTerminated" !== this._terminateTask
            }
            _setSettings(e) {
                if (this._settingsFrozen)
                    throw new C(D.FAILED_PRECONDITION,"Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
                this._settings = new oM(e),
                void 0 !== e.credentials && (this._authCredentials = function(e) {
                    if (!e)
                        return new A;
                    switch (e.type) {
                    case "firstParty":
                        return new M(e.sessionIndex || "0",e.iamToken || null,e.authTokenFactory || null);
                    case "provider":
                        return e.client;
                    default:
                        throw new C(D.INVALID_ARGUMENT,"makeAuthCredentialsProvider failed due to invalid credential type")
                    }
                }(e.credentials))
            }
            _getSettings() {
                return this._settings
            }
            _freezeSettings() {
                return this._settingsFrozen = !0,
                this._settings
            }
            _delete() {
                return "notTerminated" === this._terminateTask && (this._terminateTask = this._terminate()),
                this._terminateTask
            }
            async _restart() {
                "notTerminated" === this._terminateTask ? await this._terminate() : this._terminateTask = "notTerminated"
            }
            toJSON() {
                return {
                    app: this._app,
                    databaseId: this._databaseId,
                    settings: this._settings
                }
            }
            _terminate() {
                return function(e) {
                    let t = oD.get(e);
                    t && (I("ComponentProvider", "Removing Datastore"),
                    oD.delete(e),
                    t.terminate())
                }(this),
                Promise.resolve()
            }
        }
        function oL(e, t, n, r={}) {
            var i;
            let s = (e = oF(e, oO))._getSettings()
              , a = `${t}:${n}`;
            if ("firestore.googleapis.com" !== s.host && s.host !== a && T("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used."),
            e._setSettings(Object.assign(Object.assign({}, s), {
                host: a,
                ssl: !1
            })),
            r.mockUserToken) {
                let t, n;
                if ("string" == typeof r.mockUserToken)
                    t = r.mockUserToken,
                    n = p.MOCK_USER;
                else {
                    t = (0,
                    c.Sg)(r.mockUserToken, null === (i = e._app) || void 0 === i ? void 0 : i.options.projectId);
                    let s = r.mockUserToken.sub || r.mockUserToken.user_id;
                    if (!s)
                        throw new C(D.INVALID_ARGUMENT,"mockUserToken must contain 'sub' or 'user_id' field!");
                    n = new p(s)
                }
                e._authCredentials = new R(new k(t,n))
            }
        }
        class oP {
            constructor(e, t, n) {
                this.converter = t,
                this._query = n,
                this.type = "query",
                this.firestore = e
            }
            withConverter(e) {
                return new oP(this.firestore,e,this._query)
            }
        }
        class oq {
            constructor(e, t, n) {
                this.converter = t,
                this._key = n,
                this.type = "document",
                this.firestore = e
            }
            get _path() {
                return this._key.path
            }
            get id() {
                return this._key.path.lastSegment()
            }
            get path() {
                return this._key.path.canonicalString()
            }
            get parent() {
                return new oU(this.firestore,this.converter,this._key.path.popLast())
            }
            withConverter(e) {
                return new oq(this.firestore,e,this._key)
            }
        }
        class oU extends oP {
            constructor(e, t, n) {
                super(e, t, t6(n)),
                this._path = n,
                this.type = "collection"
            }
            get id() {
                return this._query.path.lastSegment()
            }
            get path() {
                return this._query.path.canonicalString()
            }
            get parent() {
                let e = this._path.popLast();
                return e.isEmpty() ? null : new oq(this.firestore,null,new W(e))
            }
            withConverter(e) {
                return new oU(this.firestore,e,this._path)
            }
        }
        function oB(e, t, ...n) {
            if (e = (0,
            c.m9)(e),
            oC("collection", "path", t),
            e instanceof oO) {
                let r = $.fromString(t, ...n);
                return oA(r),
                new oU(e,null,r)
            }
            {
                if (!(e instanceof oq || e instanceof oU))
                    throw new C(D.INVALID_ARGUMENT,"Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
                let r = e._path.child($.fromString(t, ...n));
                return oA(r),
                new oU(e.firestore,null,r)
            }
        }
        function oz(e, t) {
            if (e = oF(e, oO),
            oC("collectionGroup", "collection id", t),
            t.indexOf("/") >= 0)
                throw new C(D.INVALID_ARGUMENT,`Invalid collection ID '${t}' passed to function collectionGroup(). Collection IDs must not contain '/'.`);
            return new oP(e,null,new t3($.emptyPath(),t))
        }
        function oK(e, t, ...n) {
            if (e = (0,
            c.m9)(e),
            1 == arguments.length && (t = q.newId()),
            oC("doc", "path", t),
            e instanceof oO) {
                let r = $.fromString(t, ...n);
                return ok(r),
                new oq(e,null,new W(r))
            }
            {
                if (!(e instanceof oq || e instanceof oU))
                    throw new C(D.INVALID_ARGUMENT,"Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
                let r = e._path.child($.fromString(t, ...n));
                return ok(r),
                new oq(e.firestore,e instanceof oU ? e.converter : null,new W(r))
            }
        }
        function oG(e, t) {
            return e = (0,
            c.m9)(e),
            t = (0,
            c.m9)(t),
            (e instanceof oq || e instanceof oU) && (t instanceof oq || t instanceof oU) && e.firestore === t.firestore && e.path === t.path && e.converter === t.converter
        }
        function o$(e, t) {
            return e = (0,
            c.m9)(e),
            t = (0,
            c.m9)(t),
            e instanceof oP && t instanceof oP && e.firestore === t.firestore && na(e._query, t._query) && e.converter === t.converter
        }
        class oQ {
            constructor(e=Promise.resolve()) {
                this.Pu = [],
                this.Iu = !1,
                this.Tu = [],
                this.Eu = null,
                this.du = !1,
                this.Au = !1,
                this.Ru = [],
                this.t_ = new sB(this,"async_queue_retry"),
                this.Vu = () => {
                    let e = sq();
                    e && I("AsyncQueue", "Visibility state changed to " + e.visibilityState),
                    this.t_.jo()
                }
                ,
                this.mu = e;
                let t = sq();
                t && "function" == typeof t.addEventListener && t.addEventListener("visibilitychange", this.Vu)
            }
            get isShuttingDown() {
                return this.Iu
            }
            enqueueAndForget(e) {
                this.enqueue(e)
            }
            enqueueAndForgetEvenWhileRestricted(e) {
                this.fu(),
                this.gu(e)
            }
            enterRestrictedMode(e) {
                if (!this.Iu) {
                    this.Iu = !0,
                    this.Au = e || !1;
                    let t = sq();
                    t && "function" == typeof t.removeEventListener && t.removeEventListener("visibilitychange", this.Vu)
                }
            }
            enqueue(e) {
                if (this.fu(),
                this.Iu)
                    return new Promise( () => {}
                    );
                let t = new N;
                return this.gu( () => this.Iu && this.Au ? Promise.resolve() : (e().then(t.resolve, t.reject),
                t.promise)).then( () => t.promise)
            }
            enqueueRetryable(e) {
                this.enqueueAndForget( () => (this.Pu.push(e),
                this.pu()))
            }
            async pu() {
                if (0 !== this.Pu.length) {
                    try {
                        await this.Pu[0](),
                        this.Pu.shift(),
                        this.t_.reset()
                    } catch (e) {
                        if (!em(e))
                            throw e;
                        I("AsyncQueue", "Operation failed with retryable error: " + e)
                    }
                    this.Pu.length > 0 && this.t_.Go( () => this.pu())
                }
            }
            gu(e) {
                let t = this.mu.then( () => (this.du = !0,
                e().catch(e => {
                    let t;
                    throw this.Eu = e,
                    this.du = !1,
                    b("INTERNAL UNHANDLED ERROR: ", (t = e.message || "",
                    e.stack && (t = e.stack.includes(e.message) ? e.stack : e.message + "\n" + e.stack),
                    t)),
                    e
                }
                ).then(e => (this.du = !1,
                e))));
                return this.mu = t,
                t
            }
            enqueueAfterDelay(e, t, n) {
                this.fu(),
                this.Ru.indexOf(e) > -1 && (t = 0);
                let r = ac.createAndSchedule(this, e, t, n, e => this.yu(e));
                return this.Tu.push(r),
                r
            }
            fu() {
                this.Eu && S()
            }
            verifyOperationInProgress() {}
            async wu() {
                let e;
                do
                    e = this.mu,
                    await e;
                while (e !== this.mu)
            }
            Su(e) {
                for (let t of this.Tu)
                    if (t.timerId === e)
                        return !0;
                return !1
            }
            bu(e) {
                return this.wu().then( () => {
                    for (let t of (this.Tu.sort( (e, t) => e.targetTimeMs - t.targetTimeMs),
                    this.Tu))
                        if (t.skipDelay(),
                        "all" !== e && t.timerId === e)
                            break;
                    return this.wu()
                }
                )
            }
            Du(e) {
                this.Ru.push(e)
            }
            yu(e) {
                let t = this.Tu.indexOf(e);
                this.Tu.splice(t, 1)
            }
        }
        function oj(e) {
            return function(e, t) {
                if ("object" != typeof e || null === e)
                    return !1;
                for (let n of t)
                    if (n in e && "function" == typeof e[n])
                        return !0;
                return !1
            }(e, ["next", "error", "complete"])
        }
        class oW {
            constructor() {
                this._progressObserver = {},
                this._taskCompletionResolver = new N,
                this._lastProgress = {
                    taskState: "Running",
                    totalBytes: 0,
                    totalDocuments: 0,
                    bytesLoaded: 0,
                    documentsLoaded: 0
                }
            }
            onProgress(e, t, n) {
                this._progressObserver = {
                    next: e,
                    error: t,
                    complete: n
                }
            }
            catch(e) {
                return this._taskCompletionResolver.promise.catch(e)
            }
            then(e, t) {
                return this._taskCompletionResolver.promise.then(e, t)
            }
            _completeWith(e) {
                this._updateProgress(e),
                this._progressObserver.complete && this._progressObserver.complete(),
                this._taskCompletionResolver.resolve(e)
            }
            _failWith(e) {
                this._lastProgress.taskState = "Error",
                this._progressObserver.next && this._progressObserver.next(this._lastProgress),
                this._progressObserver.error && this._progressObserver.error(e),
                this._taskCompletionResolver.reject(e)
            }
            _updateProgress(e) {
                this._lastProgress = e,
                this._progressObserver.next && this._progressObserver.next(e)
            }
        }
        let oJ = -1;
        class oH extends oO {
            constructor(e, t, n, r) {
                super(e, t, n, r),
                this.type = "firestore",
                this._queue = new oQ,
                this._persistenceKey = (null == r ? void 0 : r.name) || "[DEFAULT]"
            }
            async _terminate() {
                if (this._firestoreClient) {
                    let e = this._firestoreClient.terminate();
                    this._queue = new oQ(e),
                    this._firestoreClient = void 0,
                    await e
                }
            }
        }
        function oY(e, t, n) {
            n || (n = "(default)");
            let r = (0,
            o.qX)(e, "firestore");
            if (r.isInitialized(n)) {
                let e = r.getImmediate({
                    identifier: n
                })
                  , i = r.getOptions(n);
                if ((0,
                c.vZ)(i, t))
                    return e;
                throw new C(D.FAILED_PRECONDITION,"initializeFirestore() has already been called with different options. To avoid this error, call initializeFirestore() with the same options as when it was originally called, or call getFirestore() to return the already initialized instance.")
            }
            if (void 0 !== t.cacheSizeBytes && void 0 !== t.localCache)
                throw new C(D.INVALID_ARGUMENT,"cache and cacheSizeBytes cannot be specified at the same time as cacheSizeBytes willbe deprecated. Instead, specify the cache size in the cache object");
            if (void 0 !== t.cacheSizeBytes && -1 !== t.cacheSizeBytes && t.cacheSizeBytes < 1048576)
                throw new C(D.INVALID_ARGUMENT,"cacheSizeBytes must be at least 1048576");
            return r.initialize({
                options: t,
                instanceIdentifier: n
            })
        }
        function oX(e, t) {
            let n = "object" == typeof e ? e : (0,
            o.Mq)()
              , r = (0,
            o.qX)(n, "firestore").getImmediate({
                identifier: "string" == typeof e ? e : t || "(default)"
            });
            if (!r._initialized) {
                let e = (0,
                c.P0)("firestore");
                e && oL(r, ...e)
            }
            return r
        }
        function oZ(e) {
            if (e._terminated)
                throw new C(D.FAILED_PRECONDITION,"The client has already been terminated.");
            return e._firestoreClient || o0(e),
            e._firestoreClient
        }
        function o0(e) {
            var t, n, r, i;
            let s = e._freezeSettings()
              , a = (i = e._databaseId,
            new to(i,(null === (t = e._app) || void 0 === t ? void 0 : t.options.appId) || "",e._persistenceKey,s.host,s.ssl,s.experimentalForceLongPolling,s.experimentalAutoDetectLongPolling,ox(s.experimentalLongPollingOptions),s.useFetchStreams));
            e._componentsProvider || (null === (n = s.localCache) || void 0 === n ? void 0 : n._offlineComponentProvider) && (null === (r = s.localCache) || void 0 === r ? void 0 : r._onlineComponentProvider) && (e._componentsProvider = {
                _offline: s.localCache._offlineComponentProvider,
                _online: s.localCache._onlineComponentProvider
            }),
            e._firestoreClient = new of(e._authCredentials,e._appCheckCredentials,e._queue,a,e._componentsProvider && function(e) {
                let t = null == e ? void 0 : e._online.build();
                return {
                    _offline: null == e ? void 0 : e._offline.build(t),
                    _online: t
                }
            }(e._componentsProvider))
        }
        function o1(e, t) {
            T("enableIndexedDbPersistence() will be deprecated in the future, you can use `FirestoreSettings.cache` instead.");
            let n = e._freezeSettings();
            return o5(e, oo.provider, {
                build: e => new os(e,n.cacheSizeBytes,null == t ? void 0 : t.forceOwnership)
            }),
            Promise.resolve()
        }
        async function o2(e) {
            T("enableMultiTabIndexedDbPersistence() will be deprecated in the future, you can use `FirestoreSettings.cache` instead.");
            let t = e._freezeSettings();
            o5(e, oo.provider, {
                build: e => new oa(e,t.cacheSizeBytes)
            })
        }
        function o5(e, t, n) {
            if ((e = oF(e, oH))._firestoreClient || e._terminated)
                throw new C(D.FAILED_PRECONDITION,"Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.");
            if (e._componentsProvider || e._getSettings().localCache)
                throw new C(D.FAILED_PRECONDITION,"SDK cache is already specified.");
            e._componentsProvider = {
                _online: t,
                _offline: n
            },
            o0(e)
        }
        function o4(e) {
            if (e._initialized && !e._terminated)
                throw new C(D.FAILED_PRECONDITION,"Persistence can only be cleared before a Firestore instance is initialized or after it is terminated.");
            let t = new N;
            return e._queue.enqueueAndForgetEvenWhileRestricted(async () => {
                try {
                    await async function(e) {
                        if (!ec.D())
                            return Promise.resolve();
                        await ec.delete(e + "main")
                    }(si(e._databaseId, e._persistenceKey)),
                    t.resolve()
                } catch (e) {
                    t.reject(e)
                }
            }
            ),
            t.promise
        }
        function o8(e) {
            return function(e) {
                let t = new N;
                return e.asyncQueue.enqueueAndForget(async () => aQ(await oI(e), t)),
                t.promise
            }(oZ(e = oF(e, oH)))
        }
        function o3(e) {
            var t;
            return (t = oZ(e = oF(e, oH))).asyncQueue.enqueue(async () => {
                let e = await ow(t)
                  , n = await o_(t);
                return e.setNetworkEnabled(!0),
                n.L_.delete(0),
                sW(n)
            }
            )
        }
        function o6(e) {
            var t;
            return (t = oZ(e = oF(e, oH))).asyncQueue.enqueue(async () => {
                let e = await ow(t)
                  , n = await o_(t);
                return e.setNetworkEnabled(!1),
                async function(e) {
                    e.L_.add(0),
                    await sJ(e),
                    e.q_.set("Offline")
                }(n)
            }
            )
        }
        function o9(e) {
            return (0,
            o.wN)(e.app, "firestore", e._databaseId.database),
            e._delete()
        }
        function o7(e, t) {
            let n = oZ(e = oF(e, oH))
              , r = new oW;
            return function(e, t, n, r) {
                var i;
                let s = (i = sU(t),
                new oc(function(e, t) {
                    if (e instanceof Uint8Array)
                        return ol(e, void 0);
                    if (e instanceof ArrayBuffer)
                        return ol(new Uint8Array(e), void 0);
                    if (e instanceof ReadableStream)
                        return e.getReader();
                    throw Error("Source of `toByteStreamReader` has to be a ArrayBuffer or ReadableStream")
                }("string" == typeof n ? n4().encode(n) : n),i));
                e.asyncQueue.enqueueAndForget(async () => {
                    !function(e, t, n) {
                        (async function(e, t, n) {
                            try {
                                var r;
                                let i = await t.getMetadata();
                                if (await function(e, t) {
                                    let n = rp(t.createTime);
                                    return e.persistence.runTransaction("hasNewerBundle", "readonly", n => e.Gr.getBundleMetadata(n, t.id)).then(e => !!e && e.createTime.compareTo(n) >= 0)
                                }(e.localStore, i))
                                    return await t.close(),
                                    n._completeWith({
                                        taskState: "Success",
                                        documentsLoaded: i.totalDocuments,
                                        bytesLoaded: i.totalBytes,
                                        totalDocuments: i.totalDocuments,
                                        totalBytes: i.totalBytes
                                    }),
                                    Promise.resolve(new Set);
                                n._updateProgress(aD(i));
                                let s = new ax(i,e.localStore,t.serializer)
                                  , a = await t.Ua();
                                for (; a; ) {
                                    let e = await s.la(a);
                                    e && n._updateProgress(e),
                                    a = await t.Ua()
                                }
                                let o = await s.complete();
                                return await aZ(e, o.Ia, void 0),
                                await (r = e.localStore).persistence.runTransaction("Save bundle", "readwrite", e => r.Gr.saveBundleMetadata(e, i)),
                                n._completeWith(o.progress),
                                Promise.resolve(o.Pa)
                            } catch (e) {
                                return T("SyncEngine", `Loading bundle failed with ${e}`),
                                n._failWith(e),
                                Promise.resolve(new Set)
                            }
                        }
                        )(e, t, n).then(t => {
                            e.sharedClientState.notifyBundleLoaded(t)
                        }
                        )
                    }(await oI(e), s, r)
                }
                )
            }(n, e._databaseId, t, r),
            r
        }
        function le(e, t) {
            var n;
            return (n = oZ(e = oF(e, oH))).asyncQueue.enqueue(async () => {
                var e;
                return (e = await ov(n)).persistence.runTransaction("Get named query", "readonly", n => e.Gr.getNamedQuery(n, t))
            }
            ).then(t => t ? new oP(e,null,t.query) : null)
        }
        class lt {
            constructor(e="count", t) {
                this._internalFieldPath = t,
                this.type = "AggregateField",
                this.aggregateType = e
            }
        }
        class ln {
            constructor(e, t, n) {
                this._userDataWriter = t,
                this._data = n,
                this.type = "AggregateQuerySnapshot",
                this.query = e
            }
            data() {
                return this._userDataWriter.convertObjectMap(this._data)
            }
        }
        class lr {
            constructor(e) {
                this._byteString = e
            }
            static fromBase64String(e) {
                try {
                    return new lr(e7.fromBase64String(e))
                } catch (e) {
                    throw new C(D.INVALID_ARGUMENT,"Failed to construct data from Base64 string: " + e)
                }
            }
            static fromUint8Array(e) {
                return new lr(e7.fromUint8Array(e))
            }
            toBase64() {
                return this._byteString.toBase64()
            }
            toUint8Array() {
                return this._byteString.toUint8Array()
            }
            toString() {
                return "Bytes(base64: " + this.toBase64() + ")"
            }
            isEqual(e) {
                return this._byteString.isEqual(e._byteString)
            }
        }
        class li {
            constructor(...e) {
                for (let t = 0; t < e.length; ++t)
                    if (0 === e[t].length)
                        throw new C(D.INVALID_ARGUMENT,"Invalid field name at argument $(i + 1). Field names must not be empty.");
                this._internalPath = new j(e)
            }
            isEqual(e) {
                return this._internalPath.isEqual(e._internalPath)
            }
        }
        function ls() {
            return new li("__name__")
        }
        class la {
            constructor(e) {
                this._methodName = e
            }
        }
        class lo {
            constructor(e, t) {
                if (!isFinite(e) || e < -90 || e > 90)
                    throw new C(D.INVALID_ARGUMENT,"Latitude must be a number between -90 and 90, but was: " + e);
                if (!isFinite(t) || t < -180 || t > 180)
                    throw new C(D.INVALID_ARGUMENT,"Longitude must be a number between -180 and 180, but was: " + t);
                this._lat = e,
                this._long = t
            }
            get latitude() {
                return this._lat
            }
            get longitude() {
                return this._long
            }
            isEqual(e) {
                return this._lat === e._lat && this._long === e._long
            }
            toJSON() {
                return {
                    latitude: this._lat,
                    longitude: this._long
                }
            }
            _compareTo(e) {
                return U(this._lat, e._lat) || U(this._long, e._long)
            }
        }
        class ll {
            constructor(e) {
                this._values = (e || []).map(e => e)
            }
            toArray() {
                return this._values.map(e => e)
            }
            isEqual(e) {
                return function(e, t) {
                    if (e.length !== t.length)
                        return !1;
                    for (let n = 0; n < e.length; ++n)
                        if (e[n] !== t[n])
                            return !1;
                    return !0
                }(this._values, e._values)
            }
        }
        let lu = /^__.*__$/;
        class lc {
            constructor(e, t, n) {
                this.data = e,
                this.fieldMask = t,
                this.fieldTransforms = n
            }
            toMutation(e, t) {
                return null !== this.fieldMask ? new nG(e,this.data,this.fieldMask,t,this.fieldTransforms) : new nK(e,this.data,t,this.fieldTransforms)
            }
        }
        class lh {
            constructor(e, t, n) {
                this.data = e,
                this.fieldMask = t,
                this.fieldTransforms = n
            }
            toMutation(e, t) {
                return new nG(e,this.data,this.fieldMask,t,this.fieldTransforms)
            }
        }
        function ld(e) {
            switch (e) {
            case 0:
            case 2:
            case 1:
                return !0;
            case 3:
            case 4:
                return !1;
            default:
                throw S()
            }
        }
        class lf {
            constructor(e, t, n, r, i, s) {
                this.settings = e,
                this.databaseId = t,
                this.serializer = n,
                this.ignoreUndefinedProperties = r,
                void 0 === i && this.vu(),
                this.fieldTransforms = i || [],
                this.fieldMask = s || []
            }
            get path() {
                return this.settings.path
            }
            get Cu() {
                return this.settings.Cu
            }
            Fu(e) {
                return new lf(Object.assign(Object.assign({}, this.settings), e),this.databaseId,this.serializer,this.ignoreUndefinedProperties,this.fieldTransforms,this.fieldMask)
            }
            Mu(e) {
                var t;
                let n = null === (t = this.path) || void 0 === t ? void 0 : t.child(e)
                  , r = this.Fu({
                    path: n,
                    xu: !1
                });
                return r.Ou(e),
                r
            }
            Nu(e) {
                var t;
                let n = null === (t = this.path) || void 0 === t ? void 0 : t.child(e)
                  , r = this.Fu({
                    path: n,
                    xu: !1
                });
                return r.vu(),
                r
            }
            Lu(e) {
                return this.Fu({
                    path: void 0,
                    xu: !0
                })
            }
            Bu(e) {
                return lF(e, this.settings.methodName, this.settings.ku || !1, this.path, this.settings.qu)
            }
            contains(e) {
                return void 0 !== this.fieldMask.find(t => e.isPrefixOf(t)) || void 0 !== this.fieldTransforms.find(t => e.isPrefixOf(t.field))
            }
            vu() {
                if (this.path)
                    for (let e = 0; e < this.path.length; e++)
                        this.Ou(this.path.get(e))
            }
            Ou(e) {
                if (0 === e.length)
                    throw this.Bu("Document fields must not be empty");
                if (ld(this.Cu) && lu.test(e))
                    throw this.Bu('Document fields cannot begin and end with "__"')
            }
        }
        class lm {
            constructor(e, t, n) {
                this.databaseId = e,
                this.ignoreUndefinedProperties = t,
                this.serializer = n || sU(e)
            }
            Qu(e, t, n, r=!1) {
                return new lf({
                    Cu: e,
                    methodName: t,
                    qu: n,
                    path: j.emptyPath(),
                    xu: !1,
                    ku: r
                },this.databaseId,this.serializer,this.ignoreUndefinedProperties)
            }
        }
        function lg(e) {
            let t = e._freezeSettings()
              , n = sU(e._databaseId);
            return new lm(e._databaseId,!!t.ignoreUndefinedProperties,n)
        }
        function lp(e, t, n, r, i, s={}) {
            let a, o;
            let l = e.Qu(s.merge || s.mergeFields ? 2 : 0, t, n, i);
            lN("Data must be an object, but it was:", l, r);
            let u = lD(r, l);
            if (s.merge)
                a = new e3(l.fieldMask),
                o = l.fieldTransforms;
            else if (s.mergeFields) {
                let e = [];
                for (let r of s.mergeFields) {
                    let i = lk(t, r, n);
                    if (!l.contains(i))
                        throw new C(D.INVALID_ARGUMENT,`Field '${i}' is specified in your field mask but missing from your input data.`);
                    lV(e, i) || e.push(i)
                }
                a = new e3(e),
                o = l.fieldTransforms.filter(e => a.covers(e.field))
            } else
                a = null,
                o = l.fieldTransforms;
            return new lc(new tk(u),a,o)
        }
        class ly extends la {
            _toFieldTransform(e) {
                if (2 !== e.Cu)
                    throw 1 === e.Cu ? e.Bu(`${this._methodName}() can only appear at the top level of your update data`) : e.Bu(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
                return e.fieldMask.push(e.path),
                null
            }
            isEqual(e) {
                return e instanceof ly
            }
        }
        function lw(e, t, n) {
            return new lf({
                Cu: 3,
                qu: t.settings.qu,
                methodName: e._methodName,
                xu: n
            },t.databaseId,t.serializer,t.ignoreUndefinedProperties)
        }
        class lv extends la {
            _toFieldTransform(e) {
                return new nM(e.path,new nD)
            }
            isEqual(e) {
                return e instanceof lv
            }
        }
        class l_ extends la {
            constructor(e, t) {
                super(e),
                this.Ku = t
            }
            _toFieldTransform(e) {
                let t = lw(this, e, !0)
                  , n = new nC(this.Ku.map(e => lx(e, t)));
                return new nM(e.path,n)
            }
            isEqual(e) {
                return e instanceof l_ && (0,
                c.vZ)(this.Ku, e.Ku)
            }
        }
        class lI extends la {
            constructor(e, t) {
                super(e),
                this.Ku = t
            }
            _toFieldTransform(e) {
                let t = lw(this, e, !0)
                  , n = new nk(this.Ku.map(e => lx(e, t)));
                return new nM(e.path,n)
            }
            isEqual(e) {
                return e instanceof lI && (0,
                c.vZ)(this.Ku, e.Ku)
            }
        }
        class lb extends la {
            constructor(e, t) {
                super(e),
                this.$u = t
            }
            _toFieldTransform(e) {
                let t = new nR(e.serializer,nE(e.serializer, this.$u));
                return new nM(e.path,t)
            }
            isEqual(e) {
                return e instanceof lb && this.$u === e.$u
            }
        }
        function lT(e, t, n, r) {
            let i = e.Qu(1, t, n);
            lN("Data must be an object, but it was:", i, r);
            let s = []
              , a = tk.empty();
            return eY(r, (e, r) => {
                let o = lR(t, e, n);
                r = (0,
                c.m9)(r);
                let l = i.Nu(o);
                if (r instanceof ly)
                    s.push(o);
                else {
                    let e = lx(r, l);
                    null != e && (s.push(o),
                    a.set(o, e))
                }
            }
            ),
            new lh(a,new e3(s),i.fieldTransforms)
        }
        function lE(e, t, n, r, i, s) {
            let a = e.Qu(1, t, n)
              , o = [lk(t, r, n)]
              , l = [i];
            if (s.length % 2 != 0)
                throw new C(D.INVALID_ARGUMENT,`Function ${t}() needs to be called with an even number of arguments that alternate between field names and values.`);
            for (let e = 0; e < s.length; e += 2)
                o.push(lk(t, s[e])),
                l.push(s[e + 1]);
            let u = []
              , h = tk.empty();
            for (let e = o.length - 1; e >= 0; --e)
                if (!lV(u, o[e])) {
                    let t = o[e]
                      , n = l[e];
                    n = (0,
                    c.m9)(n);
                    let r = a.Nu(t);
                    if (n instanceof ly)
                        u.push(t);
                    else {
                        let e = lx(n, r);
                        null != e && (u.push(t),
                        h.set(t, e))
                    }
                }
            return new lh(h,new e3(u),a.fieldTransforms)
        }
        function lS(e, t, n, r=!1) {
            return lx(n, e.Qu(r ? 4 : 3, t))
        }
        function lx(e, t) {
            if (lC(e = (0,
            c.m9)(e)))
                return lN("Unsupported field value:", t, e),
                lD(e, t);
            if (e instanceof la)
                return function(e, t) {
                    if (!ld(t.Cu))
                        throw t.Bu(`${e._methodName}() can only be used with update() and set()`);
                    if (!t.path)
                        throw t.Bu(`${e._methodName}() is not currently supported inside arrays`);
                    let n = e._toFieldTransform(t);
                    n && t.fieldTransforms.push(n)
                }(e, t),
                null;
            if (void 0 === e && t.ignoreUndefinedProperties)
                return null;
            if (t.path && t.fieldMask.push(t.path),
            e instanceof Array) {
                if (t.settings.xu && 4 !== t.Cu)
                    throw t.Bu("Nested arrays are not supported");
                return function(e, t) {
                    let n = []
                      , r = 0;
                    for (let i of e) {
                        let e = lx(i, t.Lu(r));
                        null == e && (e = {
                            nullValue: "NULL_VALUE"
                        }),
                        n.push(e),
                        r++
                    }
                    return {
                        arrayValue: {
                            values: n
                        }
                    }
                }(e, t)
            }
            return function(e, t) {
                if (null === (e = (0,
                c.m9)(e)))
                    return {
                        nullValue: "NULL_VALUE"
                    };
                if ("number" == typeof e)
                    return nE(t.serializer, e);
                if ("boolean" == typeof e)
                    return {
                        booleanValue: e
                    };
                if ("string" == typeof e)
                    return {
                        stringValue: e
                    };
                if (e instanceof Date) {
                    let n = z.fromDate(e);
                    return {
                        timestampValue: rm(t.serializer, n)
                    }
                }
                if (e instanceof z) {
                    let n = new z(e.seconds,1e3 * Math.floor(e.nanoseconds / 1e3));
                    return {
                        timestampValue: rm(t.serializer, n)
                    }
                }
                if (e instanceof lo)
                    return {
                        geoPointValue: {
                            latitude: e.latitude,
                            longitude: e.longitude
                        }
                    };
                if (e instanceof lr)
                    return {
                        bytesValue: rg(t.serializer, e._byteString)
                    };
                if (e instanceof oq) {
                    let n = t.databaseId
                      , r = e.firestore._databaseId;
                    if (!r.isEqual(n))
                        throw t.Bu(`Document reference is for database ${r.projectId}/${r.database} but should be for database ${n.projectId}/${n.database}`);
                    return {
                        referenceValue: ry(e.firestore._databaseId || t.databaseId, e._key.path)
                    }
                }
                if (e instanceof ll)
                    return {
                        mapValue: {
                            fields: {
                                __type__: {
                                    stringValue: "__vector__"
                                },
                                value: {
                                    arrayValue: {
                                        values: e.toArray().map(e => {
                                            if ("number" != typeof e)
                                                throw t.Bu("VectorValues must only contain numeric values.");
                                            return nb(t.serializer, e)
                                        }
                                        )
                                    }
                                }
                            }
                        }
                    };
                throw t.Bu(`Unsupported field value: ${oR(e)}`)
            }(e, t)
        }
        function lD(e, t) {
            let n = {};
            return eZ(e) ? t.path && t.path.length > 0 && t.fieldMask.push(t.path) : eY(e, (e, r) => {
                let i = lx(r, t.Mu(e));
                null != i && (n[e] = i)
            }
            ),
            {
                mapValue: {
                    fields: n
                }
            }
        }
        function lC(e) {
            return !("object" != typeof e || null === e || e instanceof Array || e instanceof Date || e instanceof z || e instanceof lo || e instanceof lr || e instanceof oq || e instanceof la || e instanceof ll)
        }
        function lN(e, t, n) {
            if (!lC(n) || !("object" == typeof n && null !== n && (Object.getPrototypeOf(n) === Object.prototype || null === Object.getPrototypeOf(n)))) {
                let r = oR(n);
                throw "an object" === r ? t.Bu(e + " a custom object") : t.Bu(e + " " + r)
            }
        }
        function lk(e, t, n) {
            if ((t = (0,
            c.m9)(t))instanceof li)
                return t._internalPath;
            if ("string" == typeof t)
                return lR(e, t);
            throw lF("Field path arguments must be of type string or ", e, !1, void 0, n)
        }
        let lA = RegExp("[~\\*/\\[\\]]");
        function lR(e, t, n) {
            if (t.search(lA) >= 0)
                throw lF(`Invalid field path (${t}). Paths must not contain '~', '*', '/', '[', or ']'`, e, !1, void 0, n);
            try {
                return new li(...t.split("."))._internalPath
            } catch (r) {
                throw lF(`Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, e, !1, void 0, n)
            }
        }
        function lF(e, t, n, r, i) {
            let s = r && !r.isEmpty()
              , a = void 0 !== i
              , o = `Function ${t}() called with invalid data`;
            n && (o += " (via `toFirestore()`)"),
            o += ". ";
            let l = "";
            return (s || a) && (l += " (found",
            s && (l += ` in field ${r}`),
            a && (l += ` in document ${i}`),
            l += ")"),
            new C(D.INVALID_ARGUMENT,o + e + l)
        }
        function lV(e, t) {
            return e.some(e => e.isEqual(t))
        }
        class lM {
            constructor(e, t, n, r, i) {
                this._firestore = e,
                this._userDataWriter = t,
                this._key = n,
                this._document = r,
                this._converter = i
            }
            get id() {
                return this._key.path.lastSegment()
            }
            get ref() {
                return new oq(this._firestore,this._converter,this._key)
            }
            exists() {
                return null !== this._document
            }
            data() {
                if (this._document) {
                    if (this._converter) {
                        let e = new lO(this._firestore,this._userDataWriter,this._key,this._document,null);
                        return this._converter.fromFirestore(e)
                    }
                    return this._userDataWriter.convertValue(this._document.data.value)
                }
            }
            get(e) {
                if (this._document) {
                    let t = this._document.data.field(lL("DocumentSnapshot.get", e));
                    if (null !== t)
                        return this._userDataWriter.convertValue(t)
                }
            }
        }
        class lO extends lM {
            data() {
                return super.data()
            }
        }
        function lL(e, t) {
            return "string" == typeof t ? lR(e, t) : t instanceof li ? t._internalPath : t._delegate._internalPath
        }
        function lP(e) {
            if ("L" === e.limitType && 0 === e.explicitOrderBy.length)
                throw new C(D.UNIMPLEMENTED,"limitToLast() queries require specifying at least one orderBy() clause")
        }
        class lq {
        }
        class lU extends lq {
        }
        function lB(e, t, ...n) {
            let r = [];
            for (let i of (t instanceof lq && r.push(t),
            function(e) {
                let t = e.filter(e => e instanceof lG).length
                  , n = e.filter(e => e instanceof lz).length;
                if (t > 1 || t > 0 && n > 0)
                    throw new C(D.INVALID_ARGUMENT,"InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.")
            }(r = r.concat(n)),
            r))
                e = i._apply(e);
            return e
        }
        class lz extends lU {
            constructor(e, t, n) {
                super(),
                this._field = e,
                this._op = t,
                this._value = n,
                this.type = "where"
            }
            static _create(e, t, n) {
                return new lz(e,t,n)
            }
            _apply(e) {
                let t = this._parse(e);
                return l6(e._query, t),
                new oP(e.firestore,e.converter,ni(e._query, t))
            }
            _parse(e) {
                let t = lg(e.firestore);
                return function(e, t, n, r, i, s, a) {
                    let o;
                    if (i.isKeyField()) {
                        if ("array-contains" === s || "array-contains-any" === s)
                            throw new C(D.INVALID_ARGUMENT,`Invalid Query. You can't perform '${s}' queries on documentId().`);
                        if ("in" === s || "not-in" === s) {
                            l3(a, s);
                            let t = [];
                            for (let n of a)
                                t.push(l8(r, e, n));
                            o = {
                                arrayValue: {
                                    values: t
                                }
                            }
                        } else
                            o = l8(r, e, a)
                    } else
                        "in" !== s && "not-in" !== s && "array-contains-any" !== s || l3(a, s),
                        o = lS(n, t, a, "in" === s || "not-in" === s);
                    return tL.create(i, s, o)
                }(e._query, "where", t, e.firestore._databaseId, this._field, this._op, this._value)
            }
        }
        function lK(e, t, n) {
            let r = lL("where", e);
            return lz._create(r, t, n)
        }
        class lG extends lq {
            constructor(e, t) {
                super(),
                this.type = e,
                this._queryConstraints = t
            }
            static _create(e, t) {
                return new lG(e,t)
            }
            _parse(e) {
                let t = this._queryConstraints.map(t => t._parse(e)).filter(e => e.getFilters().length > 0);
                return 1 === t.length ? t[0] : tP.create(t, this._getOperator())
            }
            _apply(e) {
                let t = this._parse(e);
                return 0 === t.getFilters().length ? e : (function(e, t) {
                    let n = e;
                    for (let e of t.getFlattenedFilters())
                        l6(n, e),
                        n = ni(n, e)
                }(e._query, t),
                new oP(e.firestore,e.converter,ni(e._query, t)))
            }
            _getQueryConstraints() {
                return this._queryConstraints
            }
            _getOperator() {
                return "and" === this.type ? "and" : "or"
            }
        }
        function l$(...e) {
            return e.forEach(e => l9("or", e)),
            lG._create("or", e)
        }
        function lQ(...e) {
            return e.forEach(e => l9("and", e)),
            lG._create("and", e)
        }
        class lj extends lU {
            constructor(e, t) {
                super(),
                this._field = e,
                this._direction = t,
                this.type = "orderBy"
            }
            static _create(e, t) {
                return new lj(e,t)
            }
            _apply(e) {
                let t = function(e, t, n) {
                    if (null !== e.startAt)
                        throw new C(D.INVALID_ARGUMENT,"Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
                    if (null !== e.endAt)
                        throw new C(D.INVALID_ARGUMENT,"Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
                    return new tM(t,n)
                }(e._query, this._field, this._direction);
                return new oP(e.firestore,e.converter,function(e, t) {
                    let n = e.explicitOrderBy.concat([t]);
                    return new t3(e.path,e.collectionGroup,n,e.filters.slice(),e.limit,e.limitType,e.startAt,e.endAt)
                }(e._query, t))
            }
        }
        function lW(e, t="asc") {
            let n = lL("orderBy", e);
            return lj._create(n, t)
        }
        class lJ extends lU {
            constructor(e, t, n) {
                super(),
                this.type = e,
                this._limit = t,
                this._limitType = n
            }
            static _create(e, t, n) {
                return new lJ(e,t,n)
            }
            _apply(e) {
                return new oP(e.firestore,e.converter,ns(e._query, this._limit, this._limitType))
            }
        }
        function lH(e) {
            return oV("limit", e),
            lJ._create("limit", e, "F")
        }
        function lY(e) {
            return oV("limitToLast", e),
            lJ._create("limitToLast", e, "L")
        }
        class lX extends lU {
            constructor(e, t, n) {
                super(),
                this.type = e,
                this._docOrFields = t,
                this._inclusive = n
            }
            static _create(e, t, n) {
                return new lX(e,t,n)
            }
            _apply(e) {
                var t;
                let n = l4(e, this.type, this._docOrFields, this._inclusive);
                return new oP(e.firestore,e.converter,new t3((t = e._query).path,t.collectionGroup,t.explicitOrderBy.slice(),t.filters.slice(),t.limit,t.limitType,n,t.endAt))
            }
        }
        function lZ(...e) {
            return lX._create("startAt", e, !0)
        }
        function l0(...e) {
            return lX._create("startAfter", e, !1)
        }
        class l1 extends lU {
            constructor(e, t, n) {
                super(),
                this.type = e,
                this._docOrFields = t,
                this._inclusive = n
            }
            static _create(e, t, n) {
                return new l1(e,t,n)
            }
            _apply(e) {
                var t;
                let n = l4(e, this.type, this._docOrFields, this._inclusive);
                return new oP(e.firestore,e.converter,new t3((t = e._query).path,t.collectionGroup,t.explicitOrderBy.slice(),t.filters.slice(),t.limit,t.limitType,t.startAt,n))
            }
        }
        function l2(...e) {
            return l1._create("endBefore", e, !1)
        }
        function l5(...e) {
            return l1._create("endAt", e, !0)
        }
        function l4(e, t, n, r) {
            if (n[0] = (0,
            c.m9)(n[0]),
            n[0]instanceof lM)
                return function(e, t, n, r, i) {
                    if (!r)
                        throw new C(D.NOT_FOUND,`Can't use a DocumentSnapshot that doesn't exist for ${n}().`);
                    let s = [];
                    for (let n of ne(e))
                        if (n.field.isKeyField())
                            s.push(tw(t, r.key));
                        else {
                            let e = r.data.field(n.field);
                            if (ti(e))
                                throw new C(D.INVALID_ARGUMENT,'Invalid query. You are trying to start or end a query using a document for which the field "' + n.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
                            if (null === e) {
                                let e = n.field.canonicalString();
                                throw new C(D.INVALID_ARGUMENT,`Invalid query. You are trying to start or end a query using a document for which the field '${e}' (used as the orderBy) does not exist.`)
                            }
                            s.push(e)
                        }
                    return new tR(s,i)
                }(e._query, e.firestore._databaseId, t, n[0]._document, r);
            {
                let i = lg(e.firestore);
                return function(e, t, n, r, i, s) {
                    let a = e.explicitOrderBy;
                    if (i.length > a.length)
                        throw new C(D.INVALID_ARGUMENT,`Too many arguments provided to ${r}(). The number of arguments must be less than or equal to the number of orderBy() clauses`);
                    let o = [];
                    for (let s = 0; s < i.length; s++) {
                        let l = i[s];
                        if (a[s].field.isKeyField()) {
                            if ("string" != typeof l)
                                throw new C(D.INVALID_ARGUMENT,`Invalid query. Expected a string for document ID in ${r}(), but got a ${typeof l}`);
                            if (!t7(e) && -1 !== l.indexOf("/"))
                                throw new C(D.INVALID_ARGUMENT,`Invalid query. When querying a collection and ordering by documentId(), the value passed to ${r}() must be a plain document ID, but '${l}' contains a slash.`);
                            let n = e.path.child($.fromString(l));
                            if (!W.isDocumentKey(n))
                                throw new C(D.INVALID_ARGUMENT,`Invalid query. When querying a collection group and ordering by documentId(), the value passed to ${r}() must result in a valid document path, but '${n}' is not because it contains an odd number of segments.`);
                            let i = new W(n);
                            o.push(tw(t, i))
                        } else {
                            let e = lS(n, r, l);
                            o.push(e)
                        }
                    }
                    return new tR(o,s)
                }(e._query, e.firestore._databaseId, i, t, n, r)
            }
        }
        function l8(e, t, n) {
            if ("string" == typeof (n = (0,
            c.m9)(n))) {
                if ("" === n)
                    throw new C(D.INVALID_ARGUMENT,"Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");
                if (!t7(t) && -1 !== n.indexOf("/"))
                    throw new C(D.INVALID_ARGUMENT,`Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`);
                let r = t.path.child($.fromString(n));
                if (!W.isDocumentKey(r))
                    throw new C(D.INVALID_ARGUMENT,`Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${r}' is not because it has an odd number of segments (${r.length}).`);
                return tw(e, new W(r))
            }
            if (n instanceof oq)
                return tw(e, n._key);
            throw new C(D.INVALID_ARGUMENT,`Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${oR(n)}.`)
        }
        function l3(e, t) {
            if (!Array.isArray(e) || 0 === e.length)
                throw new C(D.INVALID_ARGUMENT,`Invalid Query. A non-empty array is required for '${t.toString()}' filters.`)
        }
        function l6(e, t) {
            let n = function(e, t) {
                for (let n of e)
                    for (let e of n.getFlattenedFilters())
                        if (t.indexOf(e.op) >= 0)
                            return e.op;
                return null
            }(e.filters, function(e) {
                switch (e) {
                case "!=":
                    return ["!=", "not-in"];
                case "array-contains-any":
                case "in":
                    return ["not-in"];
                case "not-in":
                    return ["array-contains-any", "in", "not-in", "!="];
                default:
                    return []
                }
            }(t.op));
            if (null !== n)
                throw n === t.op ? new C(D.INVALID_ARGUMENT,`Invalid query. You cannot use more than one '${t.op.toString()}' filter.`) : new C(D.INVALID_ARGUMENT,`Invalid query. You cannot use '${t.op.toString()}' filters with '${n.toString()}' filters.`)
        }
        function l9(e, t) {
            if (!(t instanceof lz || t instanceof lG))
                throw new C(D.INVALID_ARGUMENT,`Function ${e}() requires AppliableConstraints created with a call to 'where(...)', 'or(...)', or 'and(...)'.`)
        }
        class l7 {
            convertValue(e, t="none") {
                switch (th(e)) {
                case 0:
                    return null;
                case 1:
                    return e.booleanValue;
                case 2:
                    return tn(e.integerValue || e.doubleValue);
                case 3:
                    return this.convertTimestamp(e.timestampValue);
                case 4:
                    return this.convertServerTimestamp(e, t);
                case 5:
                    return e.stringValue;
                case 6:
                    return this.convertBytes(tr(e.bytesValue));
                case 7:
                    return this.convertReference(e.referenceValue);
                case 8:
                    return this.convertGeoPoint(e.geoPointValue);
                case 9:
                    return this.convertArray(e.arrayValue, t);
                case 11:
                    return this.convertObject(e.mapValue, t);
                case 10:
                    return this.convertVectorValue(e.mapValue);
                default:
                    throw S()
                }
            }
            convertObject(e, t) {
                return this.convertObjectMap(e.fields, t)
            }
            convertObjectMap(e, t="none") {
                let n = {};
                return eY(e, (e, r) => {
                    n[e] = this.convertValue(r, t)
                }
                ),
                n
            }
            convertVectorValue(e) {
                var t, n, r;
                return new ll(null === (r = null === (n = null === (t = e.fields) || void 0 === t ? void 0 : t.value.arrayValue) || void 0 === n ? void 0 : n.values) || void 0 === r ? void 0 : r.map(e => tn(e.doubleValue)))
            }
            convertGeoPoint(e) {
                return new lo(tn(e.latitude),tn(e.longitude))
            }
            convertArray(e, t) {
                return (e.values || []).map(e => this.convertValue(e, t))
            }
            convertServerTimestamp(e, t) {
                switch (t) {
                case "previous":
                    let n = ts(e);
                    return null == n ? null : this.convertValue(n, t);
                case "estimate":
                    return this.convertTimestamp(ta(e));
                default:
                    return null
                }
            }
            convertTimestamp(e) {
                let t = tt(e);
                return new z(t.seconds,t.nanos)
            }
            convertDocumentKey(e, t) {
                let n = $.fromString(e);
                rO(n) || S();
                let r = new tl(n.get(1),n.get(3))
                  , i = new W(n.popFirst(5));
                return r.isEqual(t) || b(`Document ${i} contains a document reference within a different database (${r.projectId}/${r.database}) which is not supported. It will be treated as a reference in the current database (${t.projectId}/${t.database}) instead.`),
                i
            }
        }
        function ue(e, t, n) {
            return e ? n && (n.merge || n.mergeFields) ? e.toFirestore(t, n) : e.toFirestore(t) : t
        }
        class ut extends l7 {
            constructor(e) {
                super(),
                this.firestore = e
            }
            convertBytes(e) {
                return new lr(e)
            }
            convertReference(e) {
                let t = this.convertDocumentKey(e, this.firestore._databaseId);
                return new oq(this.firestore,null,t)
            }
        }
        function un(e) {
            return new lt("sum",lk("sum", e))
        }
        function ur(e) {
            return new lt("avg",lk("average", e))
        }
        function ui() {
            return new lt("count")
        }
        function us(e, t) {
            var n, r;
            return e instanceof lt && t instanceof lt && e.aggregateType === t.aggregateType && (null === (n = e._internalFieldPath) || void 0 === n ? void 0 : n.canonicalString()) === (null === (r = t._internalFieldPath) || void 0 === r ? void 0 : r.canonicalString())
        }
        function ua(e, t) {
            return o$(e.query, t.query) && (0,
            c.vZ)(e.data(), t.data())
        }
        class uo {
            constructor(e, t) {
                this.hasPendingWrites = e,
                this.fromCache = t
            }
            isEqual(e) {
                return this.hasPendingWrites === e.hasPendingWrites && this.fromCache === e.fromCache
            }
        }
        class ul extends lM {
            constructor(e, t, n, r, i, s) {
                super(e, t, n, r, s),
                this._firestore = e,
                this._firestoreImpl = e,
                this.metadata = i
            }
            exists() {
                return super.exists()
            }
            data(e={}) {
                if (this._document) {
                    if (this._converter) {
                        let t = new uu(this._firestore,this._userDataWriter,this._key,this._document,this.metadata,null);
                        return this._converter.fromFirestore(t, e)
                    }
                    return this._userDataWriter.convertValue(this._document.data.value, e.serverTimestamps)
                }
            }
            get(e, t={}) {
                if (this._document) {
                    let n = this._document.data.field(lL("DocumentSnapshot.get", e));
                    if (null !== n)
                        return this._userDataWriter.convertValue(n, t.serverTimestamps)
                }
            }
        }
        class uu extends ul {
            data(e={}) {
                return super.data(e)
            }
        }
        class uc {
            constructor(e, t, n, r) {
                this._firestore = e,
                this._userDataWriter = t,
                this._snapshot = r,
                this.metadata = new uo(r.hasPendingWrites,r.fromCache),
                this.query = n
            }
            get docs() {
                let e = [];
                return this.forEach(t => e.push(t)),
                e
            }
            get size() {
                return this._snapshot.docs.size
            }
            get empty() {
                return 0 === this.size
            }
            forEach(e, t) {
                this._snapshot.docs.forEach(n => {
                    e.call(t, new uu(this._firestore,this._userDataWriter,n.key,n,new uo(this._snapshot.mutatedKeys.has(n.key),this._snapshot.fromCache),this.query.converter))
                }
                )
            }
            docChanges(e={}) {
                let t = !!e.includeMetadataChanges;
                if (t && this._snapshot.excludesMetadataChanges)
                    throw new C(D.INVALID_ARGUMENT,"To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
                return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === t || (this._cachedChanges = function(e, t) {
                    if (e._snapshot.oldDocs.isEmpty()) {
                        let t = 0;
                        return e._snapshot.docChanges.map(n => {
                            let r = new uu(e._firestore,e._userDataWriter,n.doc.key,n.doc,new uo(e._snapshot.mutatedKeys.has(n.doc.key),e._snapshot.fromCache),e.query.converter);
                            return n.doc,
                            {
                                type: "added",
                                doc: r,
                                oldIndex: -1,
                                newIndex: t++
                            }
                        }
                        )
                    }
                    {
                        let n = e._snapshot.oldDocs;
                        return e._snapshot.docChanges.filter(e => t || 3 !== e.type).map(t => {
                            let r = new uu(e._firestore,e._userDataWriter,t.doc.key,t.doc,new uo(e._snapshot.mutatedKeys.has(t.doc.key),e._snapshot.fromCache),e.query.converter)
                              , i = -1
                              , s = -1;
                            return 0 !== t.type && (i = n.indexOf(t.doc.key),
                            n = n.delete(t.doc.key)),
                            1 !== t.type && (s = (n = n.add(t.doc)).indexOf(t.doc.key)),
                            {
                                type: function(e) {
                                    switch (e) {
                                    case 0:
                                        return "added";
                                    case 2:
                                    case 3:
                                        return "modified";
                                    case 1:
                                        return "removed";
                                    default:
                                        return S()
                                    }
                                }(t.type),
                                doc: r,
                                oldIndex: i,
                                newIndex: s
                            }
                        }
                        )
                    }
                }(this, t),
                this._cachedChangesIncludeMetadataChanges = t),
                this._cachedChanges
            }
        }
        function uh(e, t) {
            return e instanceof ul && t instanceof ul ? e._firestore === t._firestore && e._key.isEqual(t._key) && (null === e._document ? null === t._document : e._document.isEqual(t._document)) && e._converter === t._converter : e instanceof uc && t instanceof uc && e._firestore === t._firestore && o$(e.query, t.query) && e.metadata.isEqual(t.metadata) && e._snapshot.isEqual(t._snapshot)
        }
        function ud(e) {
            e = oF(e, oq);
            let t = oF(e.firestore, oH);
            return oE(oZ(t), e._key).then(n => ux(t, e, n))
        }
        class uf extends l7 {
            constructor(e) {
                super(),
                this.firestore = e
            }
            convertBytes(e) {
                return new lr(e)
            }
            convertReference(e) {
                let t = this.convertDocumentKey(e, this.firestore._databaseId);
                return new oq(this.firestore,null,t)
            }
        }
        function um(e) {
            e = oF(e, oq);
            let t = oF(e.firestore, oH)
              , n = oZ(t)
              , r = new uf(t);
            return (function(e, t) {
                let n = new N;
                return e.asyncQueue.enqueueAndForget(async () => (async function(e, t, n) {
                    try {
                        let r = await e.persistence.runTransaction("read document", "readonly", n => e.localDocuments.getDocument(n, t));
                        r.isFoundDocument() ? n.resolve(r) : r.isNoDocument() ? n.resolve(null) : n.reject(new C(D.UNAVAILABLE,"Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)"))
                    } catch (r) {
                        let e = ah(r, `Failed to get document '${t} from cache`);
                        n.reject(e)
                    }
                }
                )(await ov(e), t, n)),
                n.promise
            }
            )(n, e._key).then(n => new ul(t,r,e._key,n,new uo(null !== n && n.hasLocalMutations,!0),e.converter))
        }
        function ug(e) {
            e = oF(e, oq);
            let t = oF(e.firestore, oH);
            return oE(oZ(t), e._key, {
                source: "server"
            }).then(n => ux(t, e, n))
        }
        function up(e) {
            e = oF(e, oP);
            let t = oF(e.firestore, oH)
              , n = oZ(t)
              , r = new uf(t);
            return lP(e._query),
            oS(n, e._query).then(n => new uc(t,r,e,n))
        }
        function uy(e) {
            e = oF(e, oP);
            let t = oF(e.firestore, oH)
              , n = oZ(t)
              , r = new uf(t);
            return (function(e, t) {
                let n = new N;
                return e.asyncQueue.enqueueAndForget(async () => (async function(e, t, n) {
                    try {
                        let r = await sm(e, t, !0)
                          , i = new ak(t,r.Ts)
                          , s = i.ma(r.documents)
                          , a = i.applyChanges(s, !1);
                        n.resolve(a.snapshot)
                    } catch (r) {
                        let e = ah(r, `Failed to execute query '${t} against cache`);
                        n.reject(e)
                    }
                }
                )(await ov(e), t, n)),
                n.promise
            }
            )(n, e._query).then(n => new uc(t,r,e,n))
        }
        function uw(e) {
            e = oF(e, oP);
            let t = oF(e.firestore, oH)
              , n = oZ(t)
              , r = new uf(t);
            return oS(n, e._query, {
                source: "server"
            }).then(n => new uc(t,r,e,n))
        }
        function uv(e, t, n) {
            e = oF(e, oq);
            let r = oF(e.firestore, oH)
              , i = ue(e.converter, t, n);
            return uS(r, [lp(lg(r), "setDoc", e._key, i, null !== e.converter, n).toMutation(e._key, nL.none())])
        }
        function u_(e, t, n, ...r) {
            e = oF(e, oq);
            let i = oF(e.firestore, oH)
              , s = lg(i);
            return uS(i, [("string" == typeof (t = (0,
            c.m9)(t)) || t instanceof li ? lE(s, "updateDoc", e._key, t, n, r) : lT(s, "updateDoc", e._key, t)).toMutation(e._key, nL.exists(!0))])
        }
        function uI(e) {
            return uS(oF(e.firestore, oH), [new nW(e._key,nL.none())])
        }
        function ub(e, t) {
            let n = oF(e.firestore, oH)
              , r = oK(e)
              , i = ue(e.converter, t);
            return uS(n, [lp(lg(e.firestore), "addDoc", r._key, i, null !== e.converter, {}).toMutation(r._key, nL.exists(!1))]).then( () => r)
        }
        function uT(e, ...t) {
            var n, r, i;
            let s, a, o;
            e = (0,
            c.m9)(e);
            let l = {
                includeMetadataChanges: !1,
                source: "default"
            }
              , u = 0;
            "object" != typeof t[0] || oj(t[u]) || (l = t[u],
            u++);
            let h = {
                includeMetadataChanges: l.includeMetadataChanges,
                source: l.source
            };
            if (oj(t[u])) {
                let e = t[u];
                t[u] = null === (n = e.next) || void 0 === n ? void 0 : n.bind(e),
                t[u + 1] = null === (r = e.error) || void 0 === r ? void 0 : r.bind(e),
                t[u + 2] = null === (i = e.complete) || void 0 === i ? void 0 : i.bind(e)
            }
            if (e instanceof oq)
                a = oF(e.firestore, oH),
                o = t6(e._key.path),
                s = {
                    next: n => {
                        t[u] && t[u](ux(a, e, n))
                    }
                    ,
                    error: t[u + 1],
                    complete: t[u + 2]
                };
            else {
                let n = oF(e, oP);
                a = oF(n.firestore, oH),
                o = n._query;
                let r = new uf(a);
                s = {
                    next: e => {
                        t[u] && t[u](new uc(a,r,n,e))
                    }
                    ,
                    error: t[u + 1],
                    complete: t[u + 2]
                },
                lP(e._query)
            }
            return function(e, t, n, r) {
                let i = new ou(r)
                  , s = new aT(t,i,n);
                return e.asyncQueue.enqueueAndForget(async () => aw(await oT(e), s)),
                () => {
                    i.Za(),
                    e.asyncQueue.enqueueAndForget(async () => av(await oT(e), s))
                }
            }(oZ(a), o, h, s)
        }
        function uE(e, t) {
            return function(e, t) {
                let n = new ou(t);
                return e.asyncQueue.enqueueAndForget(async () => {
                    (await oT(e)).Y_.add(n),
                    n.next()
                }
                ),
                () => {
                    n.Za(),
                    e.asyncQueue.enqueueAndForget(async () => (function(e, t) {
                        e.Y_.delete(t)
                    }
                    )(await oT(e), n))
                }
            }(oZ(e = oF(e, oH)), oj(t) ? t : {
                next: t
            })
        }
        function uS(e, t) {
            return function(e, t) {
                let n = new N;
                return e.asyncQueue.enqueueAndForget(async () => aU(await oI(e), t, n)),
                n.promise
            }(oZ(e), t)
        }
        function ux(e, t, n) {
            let r = n.docs.get(t._key)
              , i = new uf(e);
            return new ul(e,i,t._key,r,new uo(n.hasPendingWrites,n.fromCache),t.converter)
        }
        function uD(e) {
            return uC(e, {
                count: ui()
            })
        }
        function uC(e, t) {
            let n = oF(e.firestore, oH)
              , r = oZ(n)
              , i = eX(t, (e, t) => new nZ(t,e.aggregateType,e._internalFieldPath));
            return (function(e, t, n) {
                let r = new N;
                return e.asyncQueue.enqueueAndForget(async () => {
                    try {
                        let i = await ob(e);
                        r.resolve(async function(e, t, n) {
                            var r;
                            let {request: i, ut: s, parent: a} = rR(e.serializer, nn(t), n);
                            e.connection.Fo || delete i.parent;
                            let o = (await e.Lo("RunAggregationQuery", e.serializer.databaseId, a, i, 1)).filter(e => !!e.result);
                            1 === o.length || S();
                            let l = null === (r = o[0].result) || void 0 === r ? void 0 : r.aggregateFields;
                            return Object.keys(l).reduce( (e, t) => (e[s[t]] = l[t],
                            e), {})
                        }(i, t, n))
                    } catch (e) {
                        r.reject(e)
                    }
                }
                ),
                r.promise
            }
            )(r, e._query, i).then(t => new ln(e,new uf(n),t))
        }
        class uN {
            constructor(e) {
                this.kind = "memory",
                this._onlineComponentProvider = oo.provider,
                (null == e ? void 0 : e.garbageCollector) ? this._offlineComponentProvider = e.garbageCollector._offlineComponentProvider : this._offlineComponentProvider = or.provider
            }
            toJSON() {
                return {
                    kind: this.kind
                }
            }
        }
        class uk {
            constructor(e) {
                let t;
                this.kind = "persistent",
                (null == e ? void 0 : e.tabManager) ? (e.tabManager._initialize(e),
                t = e.tabManager) : (t = uq(void 0))._initialize(e),
                this._onlineComponentProvider = t._onlineComponentProvider,
                this._offlineComponentProvider = t._offlineComponentProvider
            }
            toJSON() {
                return {
                    kind: this.kind
                }
            }
        }
        class uA {
            constructor() {
                this.kind = "memoryEager",
                this._offlineComponentProvider = or.provider
            }
            toJSON() {
                return {
                    kind: this.kind
                }
            }
        }
        class uR {
            constructor(e) {
                this.kind = "memoryLru",
                this._offlineComponentProvider = {
                    build: () => new oi(e)
                }
            }
            toJSON() {
                return {
                    kind: this.kind
                }
            }
        }
        function uF() {
            return new uA
        }
        function uV(e) {
            return new uR(null == e ? void 0 : e.cacheSizeBytes)
        }
        function uM(e) {
            return new uN(e)
        }
        function uO(e) {
            return new uk(e)
        }
        class uL {
            constructor(e) {
                this.forceOwnership = e,
                this.kind = "persistentSingleTab"
            }
            toJSON() {
                return {
                    kind: this.kind
                }
            }
            _initialize(e) {
                this._onlineComponentProvider = oo.provider,
                this._offlineComponentProvider = {
                    build: t => new os(t,null == e ? void 0 : e.cacheSizeBytes,this.forceOwnership)
                }
            }
        }
        class uP {
            constructor() {
                this.kind = "PersistentMultipleTab"
            }
            toJSON() {
                return {
                    kind: this.kind
                }
            }
            _initialize(e) {
                this._onlineComponentProvider = oo.provider,
                this._offlineComponentProvider = {
                    build: t => new oa(t,null == e ? void 0 : e.cacheSizeBytes)
                }
            }
        }
        function uq(e) {
            return new uL(null == e ? void 0 : e.forceOwnership)
        }
        function uU() {
            return new uP
        }
        let uB = {
            maxAttempts: 5
        };
        class uz {
            constructor(e, t) {
                this._firestore = e,
                this._commitHandler = t,
                this._mutations = [],
                this._committed = !1,
                this._dataReader = lg(e)
            }
            set(e, t, n) {
                this._verifyNotCommitted();
                let r = uK(e, this._firestore)
                  , i = ue(r.converter, t, n)
                  , s = lp(this._dataReader, "WriteBatch.set", r._key, i, null !== r.converter, n);
                return this._mutations.push(s.toMutation(r._key, nL.none())),
                this
            }
            update(e, t, n, ...r) {
                let i;
                this._verifyNotCommitted();
                let s = uK(e, this._firestore);
                return i = "string" == typeof (t = (0,
                c.m9)(t)) || t instanceof li ? lE(this._dataReader, "WriteBatch.update", s._key, t, n, r) : lT(this._dataReader, "WriteBatch.update", s._key, t),
                this._mutations.push(i.toMutation(s._key, nL.exists(!0))),
                this
            }
            delete(e) {
                this._verifyNotCommitted();
                let t = uK(e, this._firestore);
                return this._mutations = this._mutations.concat(new nW(t._key,nL.none())),
                this
            }
            commit() {
                return this._verifyNotCommitted(),
                this._committed = !0,
                this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve()
            }
            _verifyNotCommitted() {
                if (this._committed)
                    throw new C(D.FAILED_PRECONDITION,"A write batch can no longer be used after commit() has been called.")
            }
        }
        function uK(e, t) {
            if ((e = (0,
            c.m9)(e)).firestore !== t)
                throw new C(D.INVALID_ARGUMENT,"Provided document reference is from a different Firestore instance.");
            return e
        }
        class uG extends class {
            constructor(e, t) {
                this._firestore = e,
                this._transaction = t,
                this._dataReader = lg(e)
            }
            get(e) {
                let t = uK(e, this._firestore)
                  , n = new ut(this._firestore);
                return this._transaction.lookup([t._key]).then(e => {
                    if (!e || 1 !== e.length)
                        return S();
                    let r = e[0];
                    if (r.isFoundDocument())
                        return new lM(this._firestore,n,r.key,r,t.converter);
                    if (r.isNoDocument())
                        return new lM(this._firestore,n,t._key,null,t.converter);
                    throw S()
                }
                )
            }
            set(e, t, n) {
                let r = uK(e, this._firestore)
                  , i = ue(r.converter, t, n)
                  , s = lp(this._dataReader, "Transaction.set", r._key, i, null !== r.converter, n);
                return this._transaction.set(r._key, s),
                this
            }
            update(e, t, n, ...r) {
                let i;
                let s = uK(e, this._firestore);
                return i = "string" == typeof (t = (0,
                c.m9)(t)) || t instanceof li ? lE(this._dataReader, "Transaction.update", s._key, t, n, r) : lT(this._dataReader, "Transaction.update", s._key, t),
                this._transaction.update(s._key, i),
                this
            }
            delete(e) {
                let t = uK(e, this._firestore);
                return this._transaction.delete(t._key),
                this
            }
        }
        {
            constructor(e, t) {
                super(e, t),
                this._firestore = e
            }
            get(e) {
                let t = uK(e, this._firestore)
                  , n = new uf(this._firestore);
                return super.get(e).then(e => new ul(this._firestore,n,t._key,e._document,new uo(!1,!1),t.converter))
            }
        }
        function u$(e, t, n) {
            e = oF(e, oH);
            let r = Object.assign(Object.assign({}, uB), n);
            return !function(e) {
                if (e.maxAttempts < 1)
                    throw new C(D.INVALID_ARGUMENT,"Max attempts must be at least 1")
            }(r),
            function(e, t, n) {
                let r = new N;
                return e.asyncQueue.enqueueAndForget(async () => {
                    let i = await ob(e);
                    new od(e.asyncQueue,i,n,t,r).au()
                }
                ),
                r.promise
            }(oZ(e), n => t(new uG(e,n)), r)
        }
        function uQ() {
            return new ly("deleteField")
        }
        function uj() {
            return new lv("serverTimestamp")
        }
        function uW(...e) {
            return new l_("arrayUnion",e)
        }
        function uJ(...e) {
            return new lI("arrayRemove",e)
        }
        function uH(e) {
            return new lb("increment",e)
        }
        function uY(e) {
            return new ll(e)
        }
        function uX(e) {
            return oZ(e = oF(e, oH)),
            new uz(e,t => uS(e, t))
        }
        function uZ(e, t) {
            let n = oZ(e = oF(e, oH));
            if (!n._uninitializedComponentsProvider || "memory" === n._uninitializedComponentsProvider._offline.kind)
                return T("Cannot enable indexes when persistence is disabled"),
                Promise.resolve();
            let r = function(e) {
                let t = "string" == typeof e ? function(e) {
                    try {
                        return JSON.parse(e)
                    } catch (e) {
                        throw new C(D.INVALID_ARGUMENT,"Failed to parse JSON: " + (null == e ? void 0 : e.message))
                    }
                }(e) : e
                  , n = [];
                if (Array.isArray(t.indexes))
                    for (let e of t.indexes) {
                        let t = u0(e, "collectionGroup")
                          , r = [];
                        if (Array.isArray(e.fields))
                            for (let t of e.fields) {
                                let e = lR("setIndexConfiguration", u0(t, "fieldPath"));
                                "CONTAINS" === t.arrayConfig ? r.push(new Z(e,2)) : "ASCENDING" === t.order ? r.push(new Z(e,0)) : "DESCENDING" === t.order && r.push(new Z(e,1))
                            }
                        n.push(new J(J.UNKNOWN_ID,t,r,ee.empty()))
                    }
                return n
            }(t);
            return n.asyncQueue.enqueue(async () => (async function(e, t) {
                let n = e.indexManager
                  , r = [];
                return e.persistence.runTransaction("Configure indexes", "readwrite", e => n.getFieldIndexes(e).next(i => (function(e, t, n, r, i) {
                    t = [...t],
                    (e = [...e]).sort(n),
                    t.sort(n);
                    let s = e.length
                      , a = t.length
                      , o = 0
                      , l = 0;
                    for (; o < a && l < s; ) {
                        let s = n(e[l], t[o]);
                        s < 0 ? i(e[l++]) : s > 0 ? r(t[o++]) : (o++,
                        l++)
                    }
                    for (; o < a; )
                        r(t[o++]);
                    for (; l < s; )
                        i(e[l++])
                }
                )(i, t, X, t => {
                    r.push(n.addFieldIndex(e, t))
                }
                , t => {
                    r.push(n.deleteFieldIndex(e, t))
                }
                )).next( () => el.waitFor(r)))
            }
            )(await ov(n), r))
        }
        function u0(e, t) {
            if ("string" != typeof e[t])
                throw new C(D.INVALID_ARGUMENT,"Missing string value for: " + t);
            return e[t]
        }
        class u1 {
            constructor(e) {
                this._firestore = e,
                this.type = "PersistentCacheIndexManager"
            }
        }
        function u2(e) {
            var t;
            e = oF(e, oH);
            let n = u6.get(e);
            if (n)
                return n;
            if ("persistent" !== (null === (t = oZ(e)._uninitializedComponentsProvider) || void 0 === t ? void 0 : t._offline.kind))
                return null;
            let r = new u1(e);
            return u6.set(e, r),
            r
        }
        function u5(e) {
            u3(e, !0)
        }
        function u4(e) {
            u3(e, !1)
        }
        function u8(e) {
            var t;
            (t = oZ(e._firestore)).asyncQueue.enqueue(async () => (function(e) {
                let t = e.indexManager;
                return e.persistence.runTransaction("Delete All Indexes", "readwrite", e => t.deleteAllFieldIndexes(e))
            }
            )(await ov(t))).then(e => I("deleting all persistent cache indexes succeeded")).catch(e => T("deleting all persistent cache indexes failed", e))
        }
        function u3(e, t) {
            var n;
            (n = oZ(e._firestore)).asyncQueue.enqueue(async () => {
                (await ov(n)).ss.zi = t
            }
            ).then(e => I(`setting persistent cache index auto creation isEnabled=${t} succeeded`)).catch(e => T(`setting persistent cache index auto creation isEnabled=${t} failed`, e))
        }
        let u6 = new WeakMap;
        function u9(e) {
            var t;
            let n = null === (t = oZ(oF(e.firestore, oH))._onlineComponents) || void 0 === t ? void 0 : t.datastore.serializer;
            return void 0 === n ? null : rA(n, nt(e._query))._t
        }
        function u7(e, t) {
            var n;
            let r = eX(t, (e, t) => new nZ(t,e.aggregateType,e._internalFieldPath))
              , i = null === (n = oZ(oF(e.firestore, oH))._onlineComponents) || void 0 === n ? void 0 : n.datastore.serializer;
            return void 0 === i ? null : rR(i, nn(e._query), r, !0).request
        }
        class ce {
            constructor() {
                throw Error("instances of this class should not be created")
            }
            static onExistenceFilterMismatch(e) {
                return ct.instance.onExistenceFilterMismatch(e)
            }
        }
        class ct {
            constructor() {
                this.Uu = new Map
            }
            static get instance() {
                return cn || function(e) {
                    if (n5)
                        throw Error("a TestingHooksSpi instance is already set");
                    n5 = e
                }(cn = new ct),
                cn
            }
            et(e) {
                this.Uu.forEach(t => t(e))
            }
            onExistenceFilterMismatch(e) {
                let t = Symbol()
                  , n = this.Uu;
                return n.set(t, e),
                () => n.delete(t)
            }
        }
        let cn = null;
        !function(e, t=!0) {
            y = o.Jn,
            (0,
            o.Xd)(new l.wA("firestore", (e, {instanceIdentifier: n, options: r}) => {
                let i = e.getProvider("app").getImmediate()
                  , s = new oH(new F(e.getProvider("auth-internal")),new L(e.getProvider("app-check-internal")),function(e, t) {
                    if (!Object.prototype.hasOwnProperty.apply(e.options, ["projectId"]))
                        throw new C(D.INVALID_ARGUMENT,'"projectId" not provided in firebase.initializeApp.');
                    return new tl(e.options.projectId,t)
                }(i, n),i);
                return r = Object.assign({
                    useFetchStreams: t
                }, r),
                s._setSettings(r),
                s
            }
            ,"PUBLIC").setMultipleInstances(!0)),
            (0,
            o.KN)(g, "4.7.3", void 0),
            (0,
            o.KN)(g, "4.7.3", "esm2017")
        }()
    }
}]);
